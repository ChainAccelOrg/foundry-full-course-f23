welcome to the ultimate solidity smart contract web 3 blockchain developer course Foundry Edition previously we've done two other massive courses and tutorials like this one of them with JavaScript and one of them with python and then now one in pure solidity and combined those two videos have over 5 million views making them the most watched blockchain developer educational material on the planet and we're looking to do it all over again we've learned a ton for making those first two courses and we've taken all of those learnings from those two courses wrap them up into this one to make this one the best one yet if you're more interested in full stack development and working with JavaScript the hard hat one is still a phenomenal resource for you to get started however this one has a ton of advancements in it making it the most cutting-edge web3 developer course period having done one of these videos every year for the past three years I've been reached out to by countless develop helpers who are now full-time developers in the web3 space making a living doing well and contributing to web 3 and there are thousands that I have not met who have left comments or left me notes and I know we're going to do it again with this video If you're looking to become a web 3 solidity smart contract or blockchain developer or any of those terms this is the course for you and this course is for anybody and everybody no matter your blockchain or developer experience level and additionally we're going to be using artificial intelligence to accelerate our learning progress and I'm going to teach you not only how to become a blockchain developer but how to work with AI tools to make you a 10x developer if you have a little bit of developer experience before this this course will be even easier to get through but again don't worry if you've never coded before and for those who are already familiar with blockchain and smart contract development feel free to jump around the different modules in different sections and grab the learnings that you want I promise there's a lot of cutting edge information in here and maybe you need a brush up so so no matter if you're brand new to coding brand new to blockchain or you're an experienced smart contract engineer you're in the right place welcome to the edge of the rabbit hole let's get froggy for those of you who don't know me my name is Patrick Collins I'm a smart contract engineer security researcher and just lover of all things web3 I'm one of the co-founders of the smart contract auditing firm siphon Avid smart contract YouTuber co-creator of web3education.dev and I live in breathe smart contract development I absolutely love web3 blockchain and smart contracts and I love the power and the tools that they enable us to use but not only that I love taking blockchain developers like yourself watching this video right now on the journey to becoming a successful smart contract developer I think the key to web3 to blockchain to cryptocurrencies being successful is having a phenomenal Foundation of developers so I'm incredibly excited that you're here with me and for those who don't want to become blockchain developers the first two lessons of this course lesson zero and lesson one are foundational pieces of conceptual information for you just to understand how to get into this web3 thing so if you don't want to become a developer just stop once we get to the coding where my pythonistas here I'm working on an edition of this course purely in Python and Viper so stay tuned for that as well in any case I'm incredibly excited for your journey this is a data dump passion project of all the knowledge that I've collected over the past few years of working in this industry and being a smart contract developer myself and at this point I have the track record to show that I am 100 confident that if you follow along if you code along with us if you follow me on this journey it will come out the other side armed with the knowledge to be a positive force the cryptocurrency and blockchain Industry smart contract and solidity developers are massively in demand with an average salary being around 145 000 a year and with AI coming in place it's becoming even easier to get up to speed quickly but only those that understand the technology truly will be able to take advantage of all these advancements ai's get stuff wrong a lot so we especially need the knowledge to fact check whenever AIS get things wrong being here you have the opportunity to be a Pioneer ushering in the age of web 3 of cryptocurrency Blazing the trail of where this phenomenal industry has yet to go like I said this isn't the first time we've done this we've already helped so many developers get into space and we're going to give you the Cutting Edge most modern tools for Industries like defy nfts Dows tokens of credible smart contracts blockchains and everything else that you can think of once you finish this course it will be abundantly clear what you want your next steps to be and you'll have a ton of Economic Opportunity at your fingertips and opportunities to make a huge difference in this amazing industry however I can't just give it to you you have to come with me on this journey you have to take the step despite what you might think you know cryptocurrencies and smart contracts enable a more accountable World a more transparent World a more collaborative world a world where promises can't be broken and that's a world that I want to live in we'll learn more about the purpose of smart contracts and the purpose of blockchain technology in less than one of this course and then of course we'll teach you how to build it so before we even get started I want to give you a huge thank you for even being here on this video and listening and being interested and engaging in this phenomenal technology so thank you for being here and welcome to the rabbit hole because we're about to drop down with that being said let's get froggy so let's begin our journey by talking about some best practices that way you can get the absolute most out of this course and be as effective as possible now there are two links in the description that I want you to pause the video right now go in the description and click on and open up first one is web3education.dev and the second one is a GitHub link to a repo also known as a repository with all the code and all the lessons and everything we're going to be covering in this video the web3education.devsite is an education site that we're working on to have all of this video and everything else and all the Cutting Edge learnings of blockchain developers in this course in this site so if you enjoy written context as well be sure to subscribe to sign up for that so that you can be one of the first people to know when it launches and the second site is this GitHub link this is going to be your Bible for the duration of watching this video it has everything that we're going to go over it has all the code contacts text Etc that you're going to need to be successful in this video and I'm going to be referring to it pretty often as we go through the course additionally in this GitHub there's a discussions tab right here that you can click on and in here is where you can ask questions discuss with other people taking the course interact with members helping out and it's where you can discuss anything that you're having trouble with and an important note sometimes you'll see this as the chain Excel org Foundry flow course we recently renamed it to the siphon Foundry folk course so this is the correct link but if you see chain Excel org that's fine as well that being said as we go through this course we're also going to teach you some best practices on working with artificial intelligence how to best prompt these AI so that they can give you the best results just keep in mind they sometimes get things wrong and it's a good idea if you are going to use an AI to fact check it with a human or another resource so be sure to say hi to the discussions and maybe meet some like-minded peers and additionally once we do get to the coding portion of this course it's a good idea to code along with me as I'm explaining things so having the video up as well as your coding screen is a good idea so you can follow along with me as I'm explaining it now this space moves incredibly quickly so whenever I open some documentation or some code base or something I highly recommend that you open it as as well in your browser just so that you can know immediately right away that the code that I'm working with in the video is going to be the same that the code that you're working with locally now we're going to be keeping all the code in here up to date but sometimes things change and something that I do in the video might not be the most up-to-date best practice so we're going to have this file called chronological updates.md where you can go in and check to make sure that you're working on the most up-to-date Edition so if you go into that file each lesson will have a section and if there's some update that we made to the lesson you can find it in there additionally if you think you found something that is different or doesn't quite work be sure to make a discussion for it in that GitHub repo like I said it's going to be your Bible but yes if you run into an issue make sure that file is one of the first places that you check just to make sure that all the code that you're working with is the most up to date all of this is to say if you run into an issue jump to the GitHub repo and make a discussion we will also be giving you some tips very soon about how to best make a discussion yes asking questions to other human beings is the skill and we're going to try to teach you to be the most effective because asking well-formatted questions is not only the secret to being a fantastic AI prompt engineer but also becoming an incredibly successful developer we're going to learn how to ask well-formatted questions and whenever we post on discussions or forums or whatever we're going to work on formatting them as best as possible take breaks I cannot tell you how many people have tried to rush through these courses and be like Oh I'm going to finish in a single weekend your brain doesn't work like that your brain needs time to absorb the information so take breaks maybe every 25 minutes to a half hour take a five minute break or maybe you like working in longer chunks maybe take a whole hour and then take a 15-20 minute break don't try to rush through the whole video in a day you're not going to retain the information go outside go for a walk grab some ice cream get some coffee go to the gym your brain needs time to have the information settled maybe every two hours just step away maybe be done for the day work at whatever Pace makes sense for you everyone's going to have a different learning Pace there is no write speed for this course I've had people take my courses in two weeks in three months in six months it doesn't matter pick a pace that you can do and stick to it not only work at your pace make sure that I'm talking at a pace that makes sense for you there's a little gear icon in the YouTube video here where you can change the speed of how I'm talking and how fast the video is going so if I'm talking way too fast for you then you can slow me down but if I'm talking too slow then you can speed me up so make the adjustments you need to make me go the speed you want me to go now a giant video like this can be kind of hard to triage where you left off so using the GitHub repo with the timestamps in there is a good way to say ah okay I was on lesson one let's click the link there to jump right to the timestamp if you pause the video in YouTube you can actually right click and say copy at current time and maybe drop that into a notes folder somewhere so you can always just pick right back up where you left off or like I said you you can use some of the time stamps in the GitHub repo associated with this course or depending on when you watch this the web3education.dev site might also be up be sure to check that out as well and of course this course is modular so you can Bounce Around topic to topic and go to where you want to go if you don't want to do any full stack stuff then skip that section if you want to go right to the advanced stuff do that like I said go the pace and take the learnings that you want to do and after every lesson it might be a good idea to go back and reflect on each lesson to really make sure the knowledge gets ingrained repetition is the mother of skill and we're going to be repeating a lot of smart contract development now additionally at the end of every lesson you'll see a little QR code that looks something like this and there will be a link in the GitHub repo pointing to the same place that this QR code is pointing to these are optional challenges that you can do to try to make sure that you actually learned what was meant to be learned here and if you do solve them you get a very cool nft along with it don't know what an nft is don't worry we'll teach you later blockchain development and open source development world is incredibly collaborative so be sure to use tools like of course the GitHub discussions tab ethereum stack exchange the decentralized Q a forum purana issues on different githubs artificial intelligence and more and like I said we'll give you more tips on how to most effectively use these sites in the future and the reason I'm putting so much emphasis on this and that I will continue to put so much emphasis on this is being a successful smart contract developer is more than just knowing how solidity Works knowing where to go for information and how to collaborate with people is often more important than your smart contract knowledge because oftentimes you're going to run into issues you don't know how to solve so we're going to teach you to unblock yourself on this and really anything in life plus syncing with other people in the space makes it way more fun now before we can actually get to coding we need to understand how the blockchain even works what the purpose of these smart contracts even are and this is essential to becoming a successful smart contract developer because a technology G is really just a solution and a solution is only as good as the problem is so we need to make sure we understand the problem really well so we know how to attack it with this smart contract technology and the better you understand the Smart Car Technology the better you'll be able to architect your smart contracts in the future and make really intelligent really powerful systems that further this amazing industry but if you already know the basics of blockchain feel free to jump into lesson two and skip over lesson one so those are some of the best practices to be really successful with this course but with that knowledge you're now standing at the edge of the rabbit hole and if you're like me once you jump in you'll just want to keep going deeper and deeper I'm so excited for you to embark on this journey with us and I'm looking forward to seeing you on the other side it's like the thousands of other developers who have taken these courses and have merged the other side triumphant so it all starts with blockchain Basics let's get froggy now since you're here you've probably heard of Bitcoin before Bitcoin was one of the first protocols to use this revolutionary technology called blockchain the Bitcoin white paper was created by the pseudo-anonymous Satoshi Nakamoto and it outlined how Bitcoin can make peer-to-peer transactions in a decentralized network this network was powered by cryptography and decentrality and it allowed people to engage in censorship resistant Finance in a decentralized manner due to its features which we'll talk about in a little bit people took to this as a superior digital store of value a better store of value over something like gold for example and that's why you'll also hear people commonly refer to it as a digital gold similar to Gold there's a scarce amount or a set amount of Bitcoin available on the planet only so much that you can buy and sell you can read more about the original Vision in the white paper we have a link to the white paper in the GitHub repo associated with this course now this was an insane breakthrough in a little bit we're going to learn exactly how this is all possible and how this actually works under the hood some people though saw this technology and wanted to take it a little bit farther and do even more with this blockchain technology and a few years later a man named vitalik buterin released a white paper for a new protocol named ethereum which used this same blockchain infrastructure with an additional feature and in 2015 him and a number of other co-founders released the project ethereum where people could not only make decentralized transactions but decentralized agreements decentralized organizations and all these other ways to interact with each other without a centralized intermediary or centralized governing Force basically their idea was to take this thing that made Bitcoin so great and add decentralized agreements to it or smart contracts in fact technically these smart contracts weren't even really a new idea back in 1994 a man named Nick Zabo had actually originally come up with the idea smart contracts are a set of instructions executed in a decentralized autonomous way without the need for a third party or centralized body to run them and they come to life on these blockchains or these smart contract platforms like ethereum and it's these smart contracts that are going to be the core thing that we're going to be working on in this course and that we're going to be developing you can think of smart contracts in the same way you think of traditional contracts or traditional agreements they're just a set of instructions between parties except instead of written on pen and paper or typed up in Microsoft Word they are written in code and embodied on these decentralized blockchain platforms and that's also where they're executed instead of being executed by the two parties or three parties or however many parties that are involved this removes this centralized issue that we'll talk about more in a bit this is one of the main differentiators between the ethereum protocol and the Bitcoin protocol it's these smart contracts now technically Bitcoin does have Smart contracts but they're intentionally touring incomplete which means they don't have all the function functionality that a programming language would give them this was an intentional move by Bitcoin developers Bitcoin developers viewed Bitcoin as a store of value versus ethereum developers viewed ethereum as both a store of value and a utility to facilitate these decentralized agreements now these smart contracts on blockchains alone are absolutely incredible however they do come with a huge issue if we want these digital agreements to replace the agreements in our everyday lives they probably are going to need data from The Real World blockchains by themselves actually can't interact with and can't read or listen to data from The Real World this is what's known as the Oracle problem these blockchains are deterministic systems and they're deterministic on purpose and we'll learn about more about how that works in the sessions to come so everything that happens with them happens in their little world but if they're going to be these agreements they need external data and they need external computation and this is where oracles come into play oracles are any device that delivers data to these decentralized blockchain or runs external computation however if we want our applications to stay truly decentralized we can't work with a single Oracle or a single data provider or a single Source that's running these external computations so we need a decentralized Oracle Network similar to our decentralized blockchain Network your on-chain logic will be decentralized but you also need your off-chain data and computation to be decentralized combining this on-chain decentralized logic with this off-chain decentralized data and decentralized computation gives rise to something called hybrid smart contracts and most of the biggest protocols that we interact with today are some type of hybrid smart contract or interact with hybrid smart contracts to some extent this is where the protocol chain link comes into play it is a modular decentralized Oracle Network that can both bring external data and external computation into our smart contracts to make sure they're decentralized end-to-end while giving them the feature richness that we need for our agreements chain link allows for us to get data do upkeeps get random numbers or really customize our smart contracts in any meaningful way now throughout the course we're going to use the terminology smart contract however whenever we say smart contract we're often using it a little interchangeably with hybrid smart contracts but just know that when we say hybrid smart contract we're talking specifically about smart contracts that have some type of off-chain component now since ethereum's release a number of different blockchains or smart contract platforms have come to light such as Avalanche polygon Phantom Harmony and more for the majority of this course we're going to be assuming that we're going to be deploying to the ethereum network however everything that we learn here is going to be applicable to the vast majority of the blockchains out there like polygon Avalanche Phantom Harmony Etc and understanding everything from ethereum fundamentals will give you the skills that you need to switch chains very easily with literally one line of code so don't worry about learning a specific tool or with a specific chain because most of them work together seamlessly now there are a couple of smart contract platforms that don't use solidity but still learning the fundamentals here will make you much better at those as well and ethereum by far has the most value locked and is the most used blockchain and smart contract platform out there you'll also hear those two terms used a little bit interchangeably as well sometimes I'll say smart contract platform sometimes I'll say blockchain they kind of mean the same thing obviously blockchains could mean store of value and smart contract platform but you get the idea similarly chain link is the most popular and Powerful decentralized Oracle network is the one that we're going to be focusing on for this course as well chain link is also blockchain agnostic so it'll work on ethereum Avalanche polygon Solana or really any other blockchain out there now additionally over the last year a new term has come to light called an L2 or a layer 2. this solves an issue that most blockchains see where they don't scale very well or they don't grow big very well we'll be talking about l2s a little bit more in the future but the basic concept of is that blockchains can really only get so big so what they do if if this is ethereum you can actually have blockchains hook into them to essentially make them bigger if that doesn't really make too much sense don't worry about it for right now layer twos solve this scalability issues and at the moment there are two different types of true layer twos optimistic Roll-Ups and zero knowledge Roll-Ups optimistic ropes like arbitrary and optimism or zero knowledge Roll-Ups like CK sync or polygon ckevm yes there's a polycon chain but there's also a polycon zkevm L2 the two of them are very different don't worry about them for now and in fact it's this arbitrum layer 2 where our challenge contracts are going to be deployed on this roll-up but like I said once we learn how blockchains work from a basic Level under the hood then we'll explain more about how these l2s actually work now throughout this course you'll hear the term dap or decentralized protocol or smart contract protocol or decentralized application and they all kind of mean the same thing a decentralized application is usually the combination of many smart contracts and when we get into solidity you'll see what a singular smart contract really looks like and like I said learning all these core fundamentals will make you a better solidity and a better smart contract developer you'll also hear the term web3 a lot in this video and in the industry web3 is the idea that blockchains and smart contracts are the next iteration of the web web one being this permissionless open source world with static content web 2 being the permissioned web with Dynamic content but all the agreements and logic runs off of centralized servers where they control your information and then web3 comes back to the permissionless web but once again with Dynamic content and instead of centralized servers running your logic decentralized networks run the logic creating these censorship resistant agreements that these smart contracts enable it is also generally accompanied by the idea that the you users own the protocols that they work with and it's an ownership economy you'll see what I mean later in this course and we've talked a lot about the history and about the high level of these protocols and of these smart contracts and what they can do but what do these smart contracts really mean what is it when I say trust minimize agreements or unbreakable promises what is the real value add of these smart contracts before we look under the hood and take a peek at how this all works from a technical standpoint let's learn what all the value of this is what is the purpose of us building all these Technologies of you taking this course what problem does this technology solve in my mind a technology is really only as good as the problem that it solves if it doesn't solve a problem then why bother Mark contracts blockchain web 3 cryptocurrencies those are all just different words that encapsulate the idea of what we're doing in such a unique Paradigm I think the easiest way to sum up what these smart contracts do is that they create trust minimized agreements and if you might be scratching your head to that a much easier way to think about it is just they give rise to Unbreakable promises Yes you heard that right unbreakable agreements and Promises additionally they give rise to speed efficiency and transparency and a number of other things I made a video pretty recently about exactly this so let's dive in and take a listen to the purpose the undeniable value of smart contracts cryptocurrencies fundamentally re-landscape markets and agreements as we know them unfortunately you've probably only been bombarded with people screaming about nfts and money now some of the memes are fun but let's forget the and get down to the essence of the space if you're already in web 3 this is the video to send to your friends to explain why you're so excited about this space and explain why we're here and then if you're not into crypto you've come to the right place and yes thereof on memes and markets and there's some money stuff and they're all these things but outside of all that the purpose of blockchains relates to the age-old elementary school unbreakable promise the pinky swear let's get froggy nearly everything you do in life is the result of an agreement or a contract your chair was the result of an agreement to buy and sell lumber to assemble and sell the chair to a real tailor on Amazon then you made an agreement to buy the chair for forty dollars the lights in your house are powered by electricity which is an agreement from you and the electric company you agree to pay them in return they'll keep the lights on the electricity that generates agreements between them and Engineers who built turbine to generate the electricity with insurance you agreed to pay some amount of money to them every month and in return they will do nothing or I mean they'll cover your medical bills almost everything you do and everything you interact with is the result of some form of agreement or contract in some aspect now agreements and contracts can feel kind of abstract and boring to really grasp onto so to simplify we can also refer to them as promises when you get an oil change they're promising that they will Faithfully change your oil in exchange for money when you put money in the bank they promise to keep it safe in exchange for them to use your money to give out phones when you buy a lottery ticket the lottery promises to give you a fair chance at winning a ton of money in exchange for you buying the ticket whenever you make one of these agreements in a way you're asking them to pinky swear to not screw you over and to treat you fairly but this doesn't always happen let's look at a real world example of someone breaking the pinky swear back in the 80s and 90s McDonald's ran a promotion for people to win money by collecting McDonald's Monopoly game cards the idea was simple you buy McDonald's in return you get a chance to win one million dollars you can imagine McDonald's literally going hey everybody I promise if you buy or make food and McNuggets we'll give you a fair chance of winning this money but they ended up breaking This Promise instead of having a fair chance of winning your chance was in fact zero in the mid 90s between 13 and 24 million dollars went into the pockets of not people playing the game honestly but a group of corrupt insiders who had rigged the game meaning that when you played the McDonald's Monopoly game you are buying into a set of lies and promises that were 100 percent always going to be broken and the thing is it doesn't really matter if this was McDonald's fault or not they were the ones making the promises that they ultimately could not keep another way you could think about it is that that's 24 million dollars that they essentially stole from you and I now if this system was deployed on a blockchain with something called a smart contract it would have been impossible to defraud this 24 million dollars due to Smart contracts being immutable decentralized and transparent but I'll get back to that in a minute and all the agreements and contracts we make imagine making a pinky swear with a 10 year old and imagining how that agreement would hold up hey buddy could you could you please keep my money safe you can play with it if you like but just please have it when I come back immediately you might get that worrying feeling in your chest something might go wrong this 10 year old might lose your money you might be thinking how could I trust them will they break their promise and this feeling I can't breathe because of untrustworthy situations happens to us all the time can I trust this used car salesperson to give me a good car can I trust this tag that says machine launchable or will it make my shirt shrink well my insurance provider break their promise of covering my medical bills when I get hit by a bus when Patrick promises he'll go on a hike with me will he actually I I actually will the issue with our current agreements and contracts is we have to trust the people who are making them to do the right thing however often they're actually incentivized to not do the right thing insurance doesn't want to pay out money sometimes sales people just just want to get the off their shelves and with my girlfriend I promise to go on a hike but I hate hikes where else has this happened now you might be thinking okay Patrick this seems cool but like where has this actually affected me well the McDonald's Lottery that we just spoke about above during the Great Depression with the run of the banks banks Promise to keep our money safe and that when we went back to go get it they would actually have the money there and well and behold there were times that they didn't have the money there just last year Robin Hood painted this amazing picture come user application we will give you access to the markets we promise we will give you a retail investor a fair chance of interacting with the world of Finance psych but not this asset this asset this asset or this asset the 2008 financial crisis remember that shady deals behind closed doors combined with lies about financial product brought the world to its economic knees how are you hyperinflation in Zimbabwe hyperinflation in Brazil faradams history is a Relentless lesson of trustworthy entities being notorious promise Breakers we finally have a way to fix it with smart contracts now before I jump into smart contracts a lot of people might be thinking hey cool and all however we have systems in place to protect against a lot of these things which is true and which is great and that is a very helpful step forward so these systems often break ones in 2008 definitely didn't work the ones with the Robin Hood crisis definitely didn't work and even if these systems apply and you go to court to try to work them out maybe you're in court for years before you actually see a resolution and by that time what you needed the money for is long gone so what is this technology what is this tool that can fix this fundamental problem in our agreements today this tool is smart contracts and this tool is what the blockchain was built for now I'm going to give you a quick overview of what a smart contract is however I'm leaving to links in the description for more in-depth explanations but the basics of them is a smart contract is an agreement a contract or a set of instructions deployed on a decentralized blockchain and once the contractor set of instructions is deployed it cannot be altered it automatically executes and everyone can see the terms of the agreement the real basics of it is that the code is executed by a decentralized collective like a group of people but a group of people running a certain software this means that no one person or entity can actually alter any of these agreements or change the terms of the arrangement in these traditional agreements whoever owns the contract whoever owns the execution the contract can flip a switch and say we're not going to do that anymore it's smart contracts and web 3 and blockchain you no longer can do that typically these smart contracts are in a decentralized blockchain and used in combination with a decentralized Oracle Network to get the real world assets and information and if these words sound like I'm Conjuring up a magic spell well again check the links in the description if you want to learn more about the technical implications if you're not a technical person and you're not interested in getting to the nitty gritty you can kind of think of it like https I bet the vast majority of you don't even know what https stands for and yet you use it every single day whenever you log onto the internet so how does this fix the McDonald's Monopoly issue in its traditional form the lottery was executed behind closed doors somebody operated and owned the code and the contracts and the agreements that ran the lottery and they had the power to alter it and nobody other than the people internal on the lottery could audit this altering happening now if the code for this Lottery was deployed onto a blockchain every time a hacker attempted to alter it everyone would be notified not only that but you couldn't even alter it because the terms of a smart contract cannot be altered once deployed combine that smart contract with a chain link vrf Oracle to get a verifiably random number and Presto you now have a perfectly decentralized unalterable agreement that is impossible to hack commit fraud or manipulate we have just saved the public but between 13 million and 24 million dollars just by fixing the issue of trust how does this fix Robin Hood well the problem with Robin Hood is already fixed right again the problem is that there's a centralized body that can flip a switch at any time and say yeah you can't access these markets anymore we're breaking our promise of actually giving you access to the markets this is already fixed with something called decentralized exchanges and these exist today one of these exchanges is one called uniswap you can swap erc20 tokens which are kind of the equivalent of stocks but some aren't some are it's a little confusing I won't get into that here either but it doesn't have that centralized body that can flip a switch and ruin access to the markets and had these investors been on a decentralized exchange it would have saved them hundreds of millions of dollars and it would have prevented fraudulent Market manipulation how does it fix one of the banks with transparency built in and automated solvency checks you can build Bank like smart contract that has insolvency checks built in that make it impossible to get there and solvent means broke is any agreement or any history lesson where there was a trust assumption that was broken smart contracts can be applied to and should be applied to especially in a time where big money runs owns and controls everything we desperately need to move to a world where some self-interested centralized entity can't flip a switch and ruin people's access to the services that they need we can move away from a world that is brand based to a world that is math based right now if you interact with a service that you don't like or that they break their promise the only thing you can do is walk down the street to the next service that's going to make the same set of promises and you have to hope and pray that they're actually going to keep it we can move from that to a world where we can just look at the map and say oh okay one plus one equals two this is what this agreement is going to do for me every single time guaranteed because it's a decentralized autonomous agent has no incentive to be evil and everything is transparent and out in the open if I'm a big company and if it was better for me for one plus one to equal three maybe I would go behind some closed doors and fudge some numbers and come back out and be like hey one plus one equals three well with smart contracts that's impossible doing the right thing is infrastructural now given the choice between two agreements one where you have to trust a single centralized entity that they're going to do the right thing for you versus a decentralized untamperable collective which one are you gonna choose I'm picking the one that can't screw me over every single time for every agreement I can apply it to now this technology is relatively new but we have already seen it re-landscaped entire markets and continue to do so the traditional Financial world is already getting its lunch eaten by D5 or decentralized Finance there's already over 200 billion dollars of people's money in these protocols to help having more fair more accountable more transparent Financial system this D5 movement is one of the main reasons I got into the space because we desperately need to move away from where we are right now and end people's chances for wealth being sucked up by some group that's bending the rules in their favor and smart contracts are a ticket to that better World more and more Industries are also coming over to Smart contracts and blockchain because of all the Innovations and because of all the advantages that it has as we grow and as we get better we get closer to this vision of having this concept fulfilled trust minimized agreements these smart contracts are minimizing the trust that we need to give other people in order for these agreements to be executed if trust minimized agreements is too confusing for you just say unbreakable promises now I gotta be honest with you guys blockchains and smart contracts and cryptocurrencies can actually do more than just trust minimize agreements they have Security benefits uptime benefits execution speed benefits and a whole lot more but it's a lot easier to just learn about one and learn the other ones later right it's kind of like sprinkles on top so this is why we are here this is why we're building this future and this is why we are so excited about it last year 2022 there were a lot of issues with a couple different companies like for example sbfs FTX platform the thing to me that's most frustrating about that situation is that FTX platform wasn't anything that I just talked about it wasn't decentralized it wasn't trustless it wasn't transparent it was purely a traditional web to company pretending to be web3 and just using the cryptocurrency part of web 3 but not actually using the smart contracts and we're doing a much better job as a community getting rid of the Bad actors and this is something that's incredibly important for you when working with protocols and when building protocols I want you to be incredibly successful here but I want you to be incredibly successful because you're making a ton of value a lot of these platforms that we saw collapsing last year were not creating value they were stealing value they were siphoning value they were faking having value and as you learn and as you build smart contracts yourself it'll start to become innately aware of what protocols and what companies are centralized and are not not the ethos of web3 and the ones that are we are building verifiable trust minimized agreements unbreakable promises and if you can't verify those promises then it's not trust minimized it's not web3 it's not what this industry is for that's what I want you to do as you finish this course is be a force for good unfortunately because a lot of people haven't taken my course not everybody understands the difference between a legitimate project and a token that's just meant to pump somebody's bags as this space continues to grow and as people like yourself take courses like this we will get to continue to push real legitimate projects forward and wash out the products that aren't actually contributing to web3 even in just this introduction part we've learned a ton so let's do a quick summary of what we've learned so far Bitcoin was the first protocol to take this blockchain technology into the Limelight and take these cryptocurrencies into the mainstream Bitcoin is a sort of digital gold or a store of value able to make transactions between users in a decentralized manner ethereum and other smart contract platforms take this blockchain technology one step further enabling people to make smart contracts and decentralize Trust minimized agreements these smart contracts and decentralized applications can access and interact with the real world using something called decentralized Oracle networks chain link is a decentralized network that allows us to build these hybrid smart contracts which combines our on-chain logic with our off-chain decentralized data and decentralized computation giving rise to our logic being completely decentralized and our data and external computation being completely decentralized giving us all the features that traditional agreements and traditional contracts have now these digital currencies like ethereum and Bitcoin have value even without the smart contract part having a censorship resistant decentralized store of value is measurably powerful in its own right we have some links in the GitHub repository that'll teach you how this decentralized store of value flips traditional Finance on its head and it's another one of the great reasons for building smart contracts but again the easiest way to boil it down is trust minimized agreements or unbreakable promises but let's also go into some of these other features that smart contracts have over our traditional environment the first feature of course is that they are decentralized and they have no centralized intermediary the different individuals that run one of these blockchains are known as node operators and it's the combination of all these thousands of node operators running the same software running these algorithms running these smart contracts that make the network decentralized we'll dive deeper into how that works later the next feature is transparency and flexibility in these decentralized networks since all these individual node operators run this software everybody can see everything that's happening on chain meaning there's no Shady deals there's no weird things happening anything that's going to be unfair people would be able to see and just not use everybody has perfect information and has to play by the same rules now additionally this doesn't mean that there's no privacy blockchain is pseudo-anonymous meaning that you aren't necessarily tied to an identity in real life they also have the feature of speed and efficiency for those of you who have ever tried to do a bank transfer or send money across Seas you know it sometimes can take two to three weeks when in fact all these banks are really doing is basic math they're subtracting money from your balance and adding it to some other balance why does it take so long in the blockchain all of these transactions happen instantly another instance for those in the financial world today know that clearinghouses and settlement days can take a long time in the blockchain there's no need for any of that because they happen instantly this obviously is much quicker but it also makes for much more efficient interactions with each other security and immutability again immutable means that it can't be changed once a smart contract is deployed that's it whatever's in the code is going to be in the code Forever they cannot be altered or tampered with in any way this means that the security is much easier whereas in a centralized World somebody can hack into the server jump into the database and change some numbers you can't do that in the blockchain world and since it's decentralized in order to hack the blockchain you'd have to take over half of the nodes as opposed to in the centralized world where you only have to take over one in the regular world if your computer and your backup computer go down all of your data is gone in the blockchain world if your computer and your backup computer go down all your data is safe because it's being run on all these other decentralized nodes and even if a few hundred nodes or if a few thousand nodes go down it doesn't matter because as long as one node has a copy of the blockchain you're good to go hacking a blockchain is nearly impossible and Leaps and Bounds more difficult than hacking a centralized server not only that but this is safer in the asset sense as well all you need to access your credentials and your information and your assets is your private key which is basically your password for all of this and as we've discussed in the video these smart contracts remove this counterparty risk remove this centralized intermediary remove these trust gateways that we have to do in web 2. when we engage with users and individuals they don't always have our best interests at heart smart contracts remove this counterparty risk because once one of these contracts is created they can't go in and they can't alter it and they can't let greed or ego or anything else get the better of them and alter the terms of the deal and as we said this gives rise to these trust minimized agreements or these programmatic unbreakable promises we move away from brand based agreements to math-based agreements we can look at the cryptography we can look right at the code and see exactly what something is going to do and how it's going to execute versus having to rely on a human being doing the right thing with smart contracts and decentralized hybrid smart contracts doing the right thing is infrastructural all these pieces boil down to us having the freedom to interact the way we want to interact without having to be afraid that interacting like that is going to screw us over this trust minimized peace these unbreakable promises make interactions so much better in the purely web 2 world we're constantly bombarded with messages of projects and protocols pushing us to move or act in the direction that makes them more profitable versus in the smart contract space we can see everything transparently and we can even engage and interact and be partially owners of the protocols and the interactions that we decide that we want to be a part of so smart contracts have been around for a few years now and what have they generated for what industries have come about due to these smart contract platforms being around well you've probably heard of some of these and some of these we've already mentioned but let's give you a quick refresher defy D5 stands for decentralized finance and it gives users the ability to engage with finance and markets without having to go through a centralized intermediary for example like we said with Robinhood you no longer have to trust that Robin Hood would continue to give you access to the markets you instead would be able to see in the smart contract yes I have access to the markets or in the 2008 financial crisis you never have to trust that these groups and institutions are giving you the correct things on the back end you can see everything transparently right on the blockchain you can engage with things like money markets and sophisticated Financial products easy effectively and securely if you're really excited about D5 we have a ton of D5 examples showing you how to build and interact with these protocols in coming lessons Dows or decentralized autonomous organizations are another group that we've already mentioned Dows are groups that are governed completely decentralized by a set of instructions or smart contracts on chain there are some massive benefits here where engagement's much easier the rules are black and white and you can see everything directly on chain voting and governance technology is completely decentralized and the blockchain space is one of the big ones pushing how we can evolve politics and how we can involve governance to make it more efficient fair and reasonable and you better know it we have some examples of how to build dowels and how to work with Dow's incoming lessons so be sure to watch those nfts stand for non-fungible tokens and can really be kind of described as digital art or just a unique asset they can do so much more but we'll keep it high level for now projects like board apes and crypto punks have revolutionized the way that people get paid for their work show off their creativity status and so much more and yes of course we have lessons showing you how to create and interact with nfts as well so many other groups and so many other Industries are being created as result of this insane technology and maybe after finishing the journey with us here you go out and you'll be the one to Pioneer the next industry or the next billion dollar idea you've learned so much already but now that we've learned a lot of this high level information let's finally jump in and let's make your first transaction and let's get you set up to interact with this new world in this next section we're going to get you a wallet and we're going to show you exactly what a transaction looks like and feels like let's Dive In this is the ethereum website ethereum.org we are going to make a transaction on a test ethereum blockchain I'll explain what that means in a little bit this is going to be our first ever transaction that's made on the blockchain and this process of making a transaction is going to work the exact same across all evm compatible blockchains and layer twos like arbitrum ethereum ZK sync and Etc I'll explain what evm means in the future for now just follow along and have fun running your first transaction now in order for us to send a transaction on any of these evm chains the first thing that we need to do is set up a wallet so I'm going to go to metamask because it's one of the most popular wallets and one of the easiest wallets to use I'm using the brave browser but it works for Chrome or Firefox or really any other popular browsers out there and it's just going to be an extension in the top right hand of our browser it's going to make it very easy to see any thing to do with our wallets and our transactions very easily and it's going to store all of our evm based currencies and evm based transactions so I'm going to go ahead and hit add to Brave ADD extension although Brave does also come jam-packed with its own wallet so now we come to the get started page and I'm going to go ahead and select create a new wallet sure we'll agree to help out metamask now we're going to create our password make sure it's really secure for the purpose of this demo mine's going to be kind of mediocre now I'm going to preface this this wallet that you're making right now as you follow along with me this is going to be your development wallet so if you want to make the password a little bit weak just so that you can test things out very quickly go for it just know we're never ever going to put real money into this wallet it's good if you treat this as if it is a real wallet that way you'll get used to and you'll get familiar with good wallet safety you will then get a video like this which will teach you about the secret recovery phrase which we saw a little bit earlier when we were creating our wallet let's watch this video beta mask is a new way to connect to sites and applications on traditional websites a central database or bank is responsible for controlling and recovering your accounts but on metamask all of the Power belongs to the holder of a master key whoever holds the key controls the accounts your secret recovery phrase is your master key it's a series of 12 words that are generated when you first set up metamask which allow you to recover your wallet and funds if you ever lose access it's important that you secure your wallet by keeping your secret recovery phrase very safe and very secret if anyone gets access to it they will have the master key to your wallet and can freely access and take all of your funds to secure your metamask wallet you'll want to safely save your secret recovery phrase you can write it down hide it somewhere put it in a safe deposit box or use a secure password manager some users even engrave their phrase onto a metal plate nobody not even the team at metamask can help you recover your wallet if you lose your secret recovery phrase if you haven't written down your secret recovery phrase and stored it somewhere safe do it now we'll wait and remember never share your secret recovery phrase with anyone not even us if anyone ever asks you for it they're trying to scam you that's it now you know what a secret recovery phrase is and how to keep your wallet safe and secure awesome so that was a great introduction to keeping your wallet safe we'll talk a little bit more about safety with our wallets in the future let's go ahead and select secure my wallet now this is where we need to write down our secret recovery phrase and save it in a very secure place it gives us some tips here like a password manager a safety deposit box or split it up and keep it in multiple secret places for the purposes of this video I'm going to be showing you the secret recovery phrase because I'm not going to put any real money into this but you should never ever do this additionally you'll sometimes hear mnemonic as a synonym for secret recovery phrase the main takeaway from all this is you should never share any of this this is for you only if you show this secret phrase to anybody else they will have access to not just one account but every account that you make in metamask so be absolutely certain to not share this with anybody so again I know I'm belaboring the point a little bit but everything that we're going to do in this tutorial we're going to do with fake money and fake assets and never put actual money into this account that we're making here once you get familiar with using metamask and working with the tools and staying secure then you can go ahead and create a separate metamask that will have real funds in it if you want to put real money in different metamask a lot of browsers have a profile option and maybe you can make a new profile install metamask on that different profile call that profile real money profile or something and that's where you will store your money but for this video for this tutorial The Meta mask that you are using is going to be specifically for testing things out and you will never store real money to it I'm going to harp on that a lot more in this course so even if you're coming here and you have a wallet I highly recommend still making a brand new one for this tutorial just in case you don't actually code something or do something autonomous and give away your funds if this is your first wallet then great but again when you're working with real money if you lose access to the secret phrase you will lose access to all your money so be sure to write this down promise me that you won't use real money for this course great I'm going to hit copy to clipboard for now and we're going to go ahead and hit next now we need to confirm by adding our seed phrase back in we can go ahead and hit confirm and we now have created our wallet let's go ahead and collect got it awesome now we can see the interface of our metamask full screen and depending on your browser what you can normally do is hit this little puzzle piece on your browser and select this pin button so now we can pin our metamask into the top of our browser and we can click it like so and we can see it gave a little drop down like this and we could see the same information in this little drop down as there is on the full screen now even if you lose access to that page now that this is bookmarked in your browser you can select your meta mask select these three dots and hit expand view to reach this tab now additionally what we can do in here is we can actually go up to our accounts and we can actually create multiple accounts by hitting create account and if you wanted to you could give it a name here I'm just going to leave it as default for account two and now we have two separate accounts we have an account zero with an address and an account two with an address as well both of these accounts actually share that same secret phrase so anybody with access to the secret phrase can actually have access to both accounts however they have different private keys and that's what makes them different we'll talk a little bit more about that in the future if somebody gets access to a private key they'll get access to a single account if they get access to the secret phrase they'll get access to all the accounts that you make even you know if you made a third one they'd get access to this one as well now if you look up in the top right of the screen here you'll see the section that says ethereum mainnet this is our networks Tab and if you click it you can see all the different networks that our metamask has access to ethereum mainnet is the main network of ethereum and this is where real money is spent and used for this course we're not going to be working with ethereum mainnet we're instead going to be working with something called a test net for both engineers and non-engineers we often need a place to test or simulate our transactions and for the developers here throughout this course we are going to teach you another technique for testing out your transactions on a local network and a local network is actually going to be the preferred way we do our testing and our simulations however it's still really important to see end to end what a real transaction looks like and that's what a test net will do for us it simulates exactly what a mainnet or a live Money Network would look like however there's no real money at stake and we don't actually have to spend any money to see some of the test Nets that come default with metamask we can hit the show slash hide button which will bring us to the settings page of metamask we can turn on show test networks and if we scroll back up now if we hit our networks tab actually let's go ahead close out of settings now if we hit this drop down we can see gorelli test Network sympolia test Network and Linea gorilli test Network these networks are test networks that resemble ethereum or polygon or Linea or arbitrum or optimism or ZK sync or any other evm compatible chain that we want to work with and again we'll Define evm in the future and we can actually switch the network that we're working on simply by clicking another Network so let's switch to sympolio we can see our Network changed up here and now we can see we have zero sapola eth so on eth mainnet this new account has zero ethereum and on the simpleia test Network we also have zero sapolia eth which makes sense because this is a brand new wallet and we haven't put any money into this brand new account yet so of course we have zero at the time of recording sepolia is one of the most popular test networks out there so we're going to be working mainly with sepolia throughout this course however test Nets often change because again the run out of the goodness of people's hearts and sometimes people stop running them you should absolutely have either the web3dev.education site up or the GitHub repository associated with this course and an important note sometimes you'll see this as the chain Excel org found refill course we recently renamed it to the siphon Foundry folk course so this is the correct link but if you see chain Excel org that's fine as well and you should scroll down to the recommended testnets section to make sure you're on the most up-to-date test net at the time of recording like I said we're working with sepolia throughout this course we are going to show you how to work with different test Nets and different networks as well because it's incredibly important to do so the blockchain world is moving into a multi-chain world and especially with the popularity of l2s which help ethereum scale learning the differences between different chains and different l2s is incredibly important now same as ethereum what we can do is we can actually go to sympolia etherscan so we'll go to sympolia.etherscan.io and we can grab our address from metamask by clicking and copying the address here pasting it into the safolia Explorer and same as ethereum we can see our account balance we have zero eth there are no transactions no token transfers nothing because obviously it's a brand new wallet now I'm showing you this because pretty soon we're going to send our first ever blockchain transaction if you've never sent a blockchain transaction before we're going to do it on this test net to give you some confidence as what a transaction actually looks like when you do move over to a mainnet and I'm showing you this site now because you're going to see when we send a transaction a lot of this information is going to get updated now just remember like I said earlier a test net is run out of the goodness of people's hearts so please use the transactions sparingly once you send your first transaction here try not to send too many more as one is good enough for you to see what's going on anyways and in order for us to simulate one of these transactions we're going to go to a faucet for a test net test Nets have this thing called faucets which allow us to get some free sapolia eth so that we can test out sending transactions and receiving transactions if you go to the GitHub associated with this course or web3dev.education we can scroll down to this testnet faucets section and select one of the links to go to one of these testnet faucets right now the recommended faucet that we're working with is faucets.chain.link But be sure to use the GitHub repo or web3dev.education to be most up-to-date what this is going to do is we're going to ask this faucet site to send us testnet ethereum and this is why this testnet ethereum isn't worth any real money since we can get it for free anytime that we want these obviously don't exist on mainnet you can't get free mainnet ethereum via a faucet now what we can do is we can actually connect our wallet to this site and we can get some free test net so polia eth this will make it so that in our balance here we'll actually have some sepulia eth to play with so to do this what we're going to do is we're going to go ahead and hit connect wallet except the chain link terms of service I've already read them our metamask is going to pop up to connect it to this website now get familiar with this interface because this is how websites will interact with our wallet and interact with the blockchain connecting our account to the site we'll first select the specific account that we want to connect we're just going to choose account one we'll hit next and then we'll go ahead and hit connect and now we can see our wallet address in the top right and we can see that we're connected on the ethereum sepolia testnet if we go up to our wallet and we actually switch to ethereum mainnet you can see that the website has actually changed this little drop down to ethereum mainnet and if we go in here we can actually switch to ethereum sepolia and our metamask will pop up with this switch Network button which will help us switch the network for us so now we're back on sepolia test Network connecting to these websites is how we give these websites a way to interact and connect with our wallets we can go ahead and select this hit these three dots and hit disconnect this account but don't worry anytime we want to send a transaction the website has to ask us if we want to send a transaction so just by connecting to the site it won't actually send a bunch of transactions for us and if we scroll down we can see our wallet address is placed right here and we can see we can request test link and we can also request test eth for now we don't need any test link so we're going to leave that off but in the future we will come back to the site to get some test link for now we're just going to get 0.1 test ethereum and if all goes well we should hopefully see it in our sepolia Ethier in order for us to get this test ethereum we do have to log in Via Twitter if you don't have a Twitter you can use any of the other Faucets in the test Nets faucets area of the GitHub such as the Alchemy sepolio faucet or the simpleia proof of work faucet but if you are on Twitter now is a great time to give me a follow maybe give me a shout out and maybe say hey sending my first transaction thanks Patrick Alpha C or not whatever you want to do just some light chilling of my own Twitter account anyways we can log on Via Twitter we can authorize this app verify that we're human give our AI overlords The Prompt here oh make sure we don't select the link and let's go ahead and send the request now what's going to happen is it's going to give us this transaction hash on sepolio and after a delay we'll see it go from initiating to waiting for a confirmation to token transferred and we'll see a transaction hash and if we click the transaction hash we'll see a transaction that was sent to our address so this will be the first transaction that we get to see and there's a ton of information here but the most important piece is if we open up our meta mask now we can see we now have 0.1 so polia eth in our account and if we copy the address again we paste it into here we can see now we have a 0.1 eth balance you might have to wait several minutes for the transaction to finish going through and if you accidentally refresh your browser again we can go ahead and just select our meta mask copy our address and paste it into etherscan or just view it right in our metamask here and if you missed that piece about the transaction data if we go back to etherscan with our address remember we're on sepolia etherscan and we scroll down we can see this most recent transaction hash that just occurred and we can click the link here and we can see that detail about the transaction again here now importantly remember though this is on sepolia if we switch back to mainnet ethereum you'll see we have zero eth on mainnet ethereum if we switch to go early test Network you'll see we have zero girlies on that network if we switch to Linea gorelli eth or any other network other than sepolia you'll see that sepolia is the only one that has the 0.1 sapolia eth if you want to practice where working with a different test net feel free to scroll up back to the faucet select a different test net and try to get tested in one of these different test Nets just be sure to take a look at what test Nets your metamask comes with since some of the networks this faucet is compatible with don't come built into our metamask but again like I said in the future I'll teach you how to add these different networks to our metamask in the future but huge congratulations you received your first transaction because again this faucet is US asking them to send us money it's not us sending money it's them sending money to us and if this is the first transaction that you've ever sent you should be proud of yourself already give yourself a big pat on the back and here's a picture of me holding a cat with that cat's face all over my pajamas as a congratulations now once more let's grab our address paste it into etherscan here and scroll down and we're going to learn a little bit more about what actually went down what actually happened in this transaction you can see on etherscan it gives us some basic details it says from and to from is going to be another address a different address an address controlled by the faucet and two is obviously going to be our address and if we select this transaction hash we can see even more details in here understanding all these different fields is essential to becoming a smart contract developer and even just a web 3 or ethereum or blockchain user so let's learn a bit of the basics of what's actually going down in this transaction the first field on this page is the transaction hash you can even see a little question mark here which tells you a little bit more about it it's a unique identifier for this specific transaction on this network so this specific transaction hash we can even copy and paste this into the address bar and we'll get the exact same transaction back this is the only transaction in the entire blockchain that will have this transaction hash it's the unique identifier it identifies the transaction of sending 0.1 eth from the faucet address to our address we can see the status of this was successful we can see the block number and the number of block confirmations which we will explain in the future we can see the time step which of course is when this transaction occurred we could see the from and to who initialized the transaction and who it was sent to if we select this from and open this in a new tab we can see some details about who actually sent us this test eth and if we go back to the transaction detail and keep going we can see the value here which again if we roll over it's the value of ether or testnet ether and then in parentheses the Fiat value or the dollar value which of course since this is a test net it's always going to be zero the value of this transaction was 0.1 eth now what's underneath this value thing this transaction fee and this gas price thing what are these if we zoom in a lot more to these pieces here and we roll over transaction fee we can see it says it's the amount paid to the block producer for processing the transaction and then gas price is going to be the cost per unit of gas specified for the transaction in ether or gray the higher the gas price the higher the chance of getting included in a block I'm going to explain that in a little bit but if we scroll down even more let's Zoom back out and we click click to show more we can see even more details about this transaction for now we're just going to click to show less and just focus on the details that are here so let's talk about just the concept of transaction fees and gas for a second because they are important concepts for you to understand remember how I said that these blockchains are actually run by a group of different nodes well the question is what's their economic incentive to keep running these blockchains are they running them out of the goodness of their heart well on a real Network these nodes actually get paid a little bit of ether for processing transactions whenever you send a transaction there is a node sometimes referred to as a minor or a validator depending on the network you're on who gets paid a little bit of the Native currency of the blockchain to process that transaction for ethereum they obviously get paid in ethereum or for tests that through him they get paid in test ethereum which again the test ethereum is worth nothing which is why I said they're running them out of the goodness of their heart if you're sending a transaction on the polygon Network they're going to get paid in Matic the native token of polygon if you send a transaction on an L2 like arbitrum or optimism you're going to get paid in eth which is the native token of those l2s this payment is obviously to incentivize people to continue to run nodes and they get paid more the more gas you use so what is gas gas is a unit of computational measurement the more complex your transaction is the more gas you have to pay for example if we hit more details just really quickly and I zoom in a little bit more we can see this section here gas limit and usage by transaction this means that when we sent this transaction we limited it to a maximum of 60 000 gas but in total we only used 21 000 gas this 21 000 gas represents how complex this transaction was it was 21 000 gas units worth of complexity now for simple things like sending ether the units of gas are usually pretty small for example 21 000 units of gas is actually a really small amount of gas being sent but maybe for more complex transactions like minting in nft depositing some funds into a D5 protocol or deploying a smart contract those are typically going to be more expensive transactions because they're more complicated they have to do more stuff in the future we'll introduce you to this concept of evm codes or op codes and if you break down a transaction to the lowest level this assembly op code stuff you can actually see exactly how much e opcode costs in terms of gas don't worry about this at all right now just know that these transactions are broken down into many many many many very very small instructions and each instruction has a specific amount of gas more instructions usually means more gas like I said we'll explain this much later in the course don't worry about this too much here but just know that we use 21 000 gas now if you take this gas used and multiply it by the gas price in eth instead of gray so we'll take twenty one thousand and multiply it by this gas price in eth Dot and gray and hit enter we'll see the total transaction fee of the transaction and you can see that this number does indeed match the transaction fee for you to understand how much eth you're going to pay for your transaction you multiply the gas price times the gas used transaction fee equals gas price times gas used so this means that whoever sent us this 0.1 eth also paid 0.0000525 blah blah blah eth to a blockchain node to a validator on the sepolia ethereum test net now each blockchain has their own unique way of calculating how much transaction fee someone's actually going to pay for most evm chains this is the simple algorithm it's going to be gas used times gas price after we understand how the blockchain works more in depth I'll explain to you what the rest of these values stand for for now just know that anytime you make a transaction on chain you have to pay the validators or the blockchain nodes a little bit of gas or a little bit of the Native token of the blockchain which in our case is eth so you have to pay a little bit of eth to the blockchain nodes providing or sending the transaction sometimes I'll refer to this just as transaction gas let's look at an example of this ourselves if we pull up our meta mask we go ahead and hit expand view as we know we have two different accounts in here we have account one and account two account one has 0.1 simplelia eth count two has zero sapolia eighth if I send 0.05 from account 1 to account two how much do you think I'll have left in account one let's go ahead and do this and this is going to be the first transaction that you send on the blockchain which is incredibly exciting as well let's go ahead and hit this send button in our metamask we'll hit send we'll hit transfer between my accounts we'll select account two and we'll say 0.05 sapolia eth so we started with 0.1 Supply eth and we're going to send 0.05 to account 2. we'll scroll down we'll hit next we can see some information here about what's actually going on we can see some gas information which metamask automatically prompted for us and it even gives us the total amount that we're going to be paying in eth it's adding this 0.05 eth to the estimated amount of gas that we actually have to spend so that at the bottom it says the amount plus the gas fee is the two of those combined the value that we're sending plus the gas fee and additionally in metamask if you select this here you can get some more information about editing our gas fees the amount of gas that you choose to spend can be different depending on how many people are making transactions with blockchain the more people are sending transactions at the same time the more expensive gas costs are going to be so if a lot of other people are also sending transactions right now the gas price is going to be higher if a lot of people are sending transactions that means there's not going to be enough space for everyone's transaction to get through so in order to throttle that they increase the gas price that's a bit of an oversimplification of what's happening but if you take that understanding that'll pretty much work if you want to specify exactly how much gas you want to spend you can click the advanced tab if you select zero gas there's a high likelihood that your transaction will never go through so we're just going to go with the default which is usually a good idea so let's go ahead and confirm we now see a send transaction in our queue in the activity tab of our metamask which shows us that we have a transaction currently sending and if we click on it and click view on block Explorer it'll actually open us up on etherscan and we'll see well mine was a little bit quick but normally we'll see a little indexing Tab and we won't see this having gone through we'll see it as like indexing or sending or something like that but after a little bit it'll actually finish sending you might have to wait a minute or so for this to actually finish going through but it looks like mine was really quick and same as our last transaction this has a lot of the same information and if we scroll down we'll see that of course we send a different amount of eth 0.05 and we have a different transaction fee now if we pull up our minimum ask what do you think that we're going to see I'm going to go ahead and click expand view again and we see account one says 0.05 and account 2 also says 0.05 hmm that's kind of odd I thought we spent some gas well if we click on the big accounts button we can see exactly how much eth is in each account we can see we have 0.0499 in account one and 0.05 in account two and we can see in our activity history our account 1 recently sent 0.05 eth and account 2 recently received 0.05 sepolia eth now here's the best part of all this even if you don't want to become a developer you just learned the basics of sending a transaction and interacting with sites using your meta mask congratulations now here's something that's incredibly exciting with just this little bit of information you now know how to interact with blockchains and interact with the ethereum protocol so if you don't want to learn how to code anything you can go and you can start interacting with ethereum and interact with protocols with just this much info information however I know most of you guys are here to learn how to code so let's look under the hood of ethereum and what is actually going on with these transactions and what these gas and what these blockchains and what's really going on let's learn all the fundamentals of a blockchain now if you want to just go ahead and jump into the coding go ahead and grab a timestamp from the description however learning exactly how the blockchain works is going to make you an incredibly powerful developer so let's take a look at that first so we're going to be going through this blockchain demo on this site right here now the creator of the site has a fantastic video and a fantastic walk through blockchain 101 it is right on their site so if you're looking for another explanation definitely check out his video it is absolutely fantastic but the first thing that we really need to do in order to understand blockchain in order to sound really anything and everything that's going on here we first really need to understand this shot 256 hash or hashing just kind of in general let's first understand what a hash is a hash is a unique fixed length string meant to identify any piece of data they are created by putting some piece of data into a hash function in this example the hashing algorithm used is Shaw 256 now ethereum actually uses uh this uh this right here for its hashing algorithm which isn't quite um sha 256 but is in kind of this Shaw family but it's it's really just another way to Hash things and the specific hash algorithm doesn't matter so much so this example uses 256 but you can imagine it's the same as the ethereum hash they're just gonna you know result in a different hash so what's going to happen in this application here is whatever data or whatever information we put into this data section here as you can see below this hash changes so what's happening is this data is running through this Shaw 256 hash algorithm and it's outputting this unique hash so this hash is a unique fixed length string that's going to identify like a blank data piece here right so if I put in you know my name like you know Patrick Collins this is the hash that's going to represent Patrick Collins right and you can see even when I put you know tons and tons of data in here the length of the string doesn't change right so it's always going to be the same amount we can put almost any amount of data in here there is an upper limit on the max size of the data but for all intents and purposes we can pretty much put any length in here and you'll see too that you know every time I type in Patrick Collins this hash is always going to be this 7e 5B right I'm going to delete it I'm going to do Patrick Collins again your seven e5b it's always this this unique hash is always going to be unique right it's always going to be this fixed length string here so now we can take this idea right of putting this data in here we can move on to uh this concept of a block so with this block concept we're going to take the exact same thing with this hash this this data section right but instead of having everything just being in this this singular data area right here we're going to split this data up into block nuns and data so all so what we're going to do is we're actually going to Hash all three of these to get to get this hatch right we're going to put all three of these we're going to say all three of these are combined uh together we're going to put every all three of them into this hashing algorithm uh to figure it out so if I type a bunch of stuff here we can see that block one with nunts you know this nunce and this data we're going to get this hash and as you can see actually the screen turns red this block turned red now what happens when I hit this mine button when I hit this mind button it's actually going to take some time it's going to think for a little bit and we can see that the nuns here actually change right the nunce is different from what it was before and this hash now starts with four zeros okay and then it the back turned green when we're talking about mining we're talking about miners solving some type of very difficult problem that takes a lot of time to do now in this example here a problem that the miners had to solve was they had to find a nunce or or a value in this none section that when hashed with at block number one with this data it would start with four zeros so the problem here the miners had to solve was to start with four zeros and the only way for them to really do that is kind of this Brute Force you know trying stuff so they tried one okay one didn't work okay two nope two didn't work three no four or five six okay five well let's start with one zero but that's not four and they have to keep trying all these numbers until they uh get to this one where you know let's hit mine again where it has four zeros at the top at the start now this specific problem changes blockchain to blockchain right ethereum has a different problem for miners to solve um Bitcoin has different problems around itself but this concept is going to be the same and since ethereum is proof of stake now nodes actually take turns solving these problems again we're not going to go too deep into that right now though so they have to take um one block is going to be this this uh this concept is going to be all this data it's going to be the block number and it's going to be this nuts right and so this nunce is the solution um is is going to be the the number that they use to get like the solution to the problem right so if I go to one here you know and I do this again I'm gonna hit mine and the nonsense changed right it went from 1 to 33 128 because this is the nuns that allowed this hash to start with four zeros and so that's what's happening when uh blockchain miners are mining they're going through this process this very computationally intensive process of trying to find unknowns that fulfills whatever the problem is so that's really it actually so that's a block and and that's really what's happening when miners are mining they're just looking there's trial and error Brute Force trying to find this nunce so so now that we know what a block is let's go to the next step and figure out okay well what's a Block Chain so here we have an example of what a blockchain is going to look like right we have a combination you know we have back here in the block section we have one what one block looks like now here we have multiple different blocks right each one of these represents a different block but we have an additional column here or we have additional variable here so like before you know we have block nuns and data right we have block data but we also have this thing called previous right and so this is actually going to be pointing to the previous hash of the last block so for example if we go to the last block in this blockchain it says previously zero zero ae8 and if we look at the hash of block number four it's zero zero zero zero ae8 and then we look at its previous it's four zeros B9 we have four zeros B9 and so on all the way back to our first block which has previous of just all zeros right and so the block with the previous of all zeros is going to be known as The Genesis block so you've probably heard that before the Genesis Block it's the first block in the blockchain where the previous hash points to a hash that doesn't actually exist now as you can imagine kind of the same as how this block worked how the block nuts and data all go through the hashing algorithm in the blockchain the block nunce data and previous hash all go through this hashing algorithm to figure out you know what the hash is okay so if we go to over here here you know for example if I type in you know Patrick obviously this is now no longer valid right because this nuns uh combined with the block the data in the previous hash aren't going to solve you know our problem of having four zeros at the start right so I'm going to go and fix that and and that's that's kind of an easy way to see it being broken but but let's take a look if I break this block right here what happens if I if I break the data in here if I do like Patrick in here you can see that both of these are now red both of these are now invalid right because the block hash with the nunts hash with the new data which is my name Patrick has hashed with the previous block is now a brand new hash right and this block is still pointing to this previous hash right here right it's pointing to this previous block and now it is wrong and it is messed up and now um and now it's Nuns with this previous hash is also wrong right and this is where when we talk about blockchains being immutable this is exactly how it's immutable right because if I go back and I change anything you know if I just typed a right here the entire blockchain is now invalidated because none of these are going to have nunses that solve this equation anymore so this is why we blockchains are immutable is because anytime you change one thing you ruin the rest of the blockchain okay so however though you know if if an a was here originally we can go ahead and mine these we can mine all these but as you can see you know this is going to start getting very computationally expensive because I have to go redo basically the entire blockchain and the farther and farther down the line you get the harder and harder it becomes to you know rehash and redo all these different blockchains here now this makes a lot of sense right so we have this blockchain it's really hard to change something in the past but if we do we can just go ahead and remind it now if I'm the one who controls the blockchain right if I'm the one who controls this you know and I want to change something in the past well okay great all I got to do is change this data here and then you know mine each one of these you know obviously it's going to be very computationally expensive but it's something that I can do right if I'm the one who owns the blockchain now here's where the decentralized nature or the distributed nature really uh makes it incredibly powerful so we're going to go to the distributed tab here which I also refer to as the decentralized tab here and it's going to show us what a blockchain looks like uh in a decentralized manner so we have this exact same initial setup here we have distributed blockchain we have you know our first blockchain which is kind of exactly as the one from here but we also have more than once we have peer a pure B and pure C and when people are talking about peer-to-peer peer-to-peer transactions they're really talking uh this is kind of that concept that they're talking about right so we have a number of different peers who are running this blockchain technology they're all weighted equally right each one of these tiers or each one of these nodes each one of these entities running a blockchain has the exact same power as anybody else right so the way that we can tell very easily which blockchain is correct or which ones are correct are by looking at this end hash here right or by looking at where we are in the blockchain because again remember because again remember this this hash that this this in this last block here is going to Encompass all of the blocks from before right because this last hash is going to have the previous hash here which includes the previous hash here which this hash includes the previous hash here in which so this last hash is encompasses everything in here right and we can look we can look at the hash of pure C which is four zeros and then e4b we can look at the latest hash of peer B which is four zeros e4b and then pure a which is four zeros e4b so all of these peers all of these nodes all of these decentralized you know these independent um all these independent users running this blockchain saw offer they're all matched up it's very easy for their nodes to look at each other and say hey great we are all matched up now what let's say that a decides that you know something happened on the blockchain that they didn't like and they wanted to go back and change something right so let's say they change here you know obviously uh the rest of their blockchain is invalidated and they have to spend a lot of computational power to catch up to speed so let's go ahead and humor it let's say that they they did they ended up catching up uh they ended up catching up you know they ended up mining everything and now they have a valid blockchain right it solves the equation awesome however in block number three there's something new right this is here and it shouldn't have been here this is something that peer a put in by themselves all that happens now is we look at all the blockchains that are running the software and we're looking at all the hashes and hash at block number five so peer a has this new hash now zero zero nine BC but peer B has a different hash zero zero zero e4b right so who's right is it is it pure a with their new stuff or is it peer B well that's where the decentralized number comes in because then we can look at peer C and peer C also has e4b so pure B and PRC both say hey pure a you're wrong get out right and Pier a will stop being able to participate in the mining rewards because they have essentially forked uh the blockchain and started their own little blockchain right with their own history because they're the only ones with this this piece of data in block three whereas peer B and PRC have nothing in there so that really shows why in these blockchain worlds in this decentralized world there really is no centralized entity you know pure a you know might have been maliciously motivated to change you know this this block number three however democracy rules right the majority rules in the blockchain if you're B and prpc people say Hey you know that's cute and All Pure a but you're wrong right that's not right now it might be a little abstract it should just look at data and you know us typing kind of random stuff in here and think okay yeah that's that's data right that makes sense you know it just kind of random strings in here it doesn't really do anything for us so if we actually go over to the Token section here this is where everything really starts to make a lot of sense so we have the exact same setup here uh with peer a pure B pure C except the difference is instead of having kind of this this data section we have this a TX this transaction section right and this represents all the transactions that are happening in this block right so we're sending 25 from Darcy to Bingle or to Bingley uh force uh 4.27 cents here uh 1922 right and it's the exact same thing so this all these transactions are going to get hashed in the exact same way uh that the data is going to get hashed and and this is why it's so powerful because again you know if I want to be malicious right if if I want to say hey I really wanted to give Jane a lot more money from Elizabeth so I'm puree and I go back and I change it to 100 well now you know not only do I does my whole blockchain uh get invalidated because that was so far so long ago but I'm not going to match any of these other chains right and so my blockchain is going to be excluded from the overall blockchain so and let's let's go ahead and fix this and it's the same thing if down here if I become malicious and I want to send you know I want uh Miss Audrey to have less money maybe I want to send a dollar and I go ahead and mind it the same thing here this hash now this 2a1 is not going to match your bees if your B's hash of BBA and it's not going to match piercy's hash of BBA as well so the two of them are going to say hey this your blockchain is invalid it's not matching the majority you know you're out right so that's really how these blockchains work at a low level and it all goes back to this this understanding this hash idea and using it in this very sophisticated manner uh to kind of cryptographically prove um you know where where stuff lies now the way the blockchain works is yeah instead of random stuff put in this data section it's actually going to be a solidity code in here and finding ways to interact with different blocks and different protocols that are on chain or as we've said before different smart contracts now the next question that you might be asking is okay well how do I know how can I be sure that I'm the one uh you know let's say this is let's say I'm Darcy right how can I be sure that I was that Darcy was the one to actually send this money here how do we know that Darcy sent 25 to uh Bingley well this is where we get into uh private keys and public keys and that's what we're going to go into now let's just do a quick recap of what we've learned in this section so far right we've learned that ethereum actually runs on this kit check 256 but you know we used shot to vid6 for this demo it doesn't really matter we're just talking about a hashing algorithms so again a hash is a unique fixed length string meant to identify any piece of data a hash algorithm or a hash function is a function or algorithm that computes any type of data into a unique hash mining is going to be the process of finding the solution to the blockchain problem in our example the problem was finding a hash that starts with four zeros nodes get paid for mining different blocks and the problem is going to be different blockchain to blockchain a block and a blockchain is basically a combination of a block none's transaction and previous hash to create this unique hash for this block and again depending on the blockchain implementation this might have a couple other fields or might have different fields but this is essentially what's going on blockchains are decentralized and distributed because many independent users are going to run this blockchain software and it will check and they will compare against each other to see which blockchains are acting honestly and which ones are acting maliciously in the blockchain world majority rules the nunts here is the answer used or the number used to get this hashing now nuns is kind of an overloaded term it's actually used for a number of different reasons in this case we're using it to solve this problem of getting you know four or five zeros at the stop Urban hash however in ethereum it'll also be often used as the number of transactions from a given address so now we're going to talk a little bit about signing these transactions and private keys and some other cryptography pieces right because in this blockchain demo here we can see we hover these these fantastic transactions right all these things went through but how do we know that it was Darcy who is the one to send 25 uh to Bingley right how do we know that actually happened and this is where all those pieces that we just learned about uh in our our test net in our metamask account are really going to start to to come to life here a little bit here so here we have an example of public and private Keys okay at the top we have this private key right that was that was randomly generated a private key is is you know as it kind of states is a key that you really want to keep a secret because you're going to be using this uh as kind of your your secret password for all your transactions right I can really pick you know any any any private key anything that I want and with it uh this algorithm they're going to use an algorithm you know for ethereum and Bitcoin they both use this elliptic curve digital signature uh algorithm it's it's a variant of just a digital signature algorithm and it's going to create this this public key right I'm really not going to go at all into kind of this digital signature algorithm but just know it does use some of these uh some of the hash uh knowledge that we just learned combined with some other pieces uh to kind of get this this public key here so I'm not going to go too deep into it but we have this private key that we create and we get this public key now this public key we want everybody to have access to right this is yeah whole world can see this this private key we really want it to be uh private we don't want people to see this we're going to use this private key as like a password to quote unquote digitally sign transactions and then people can verify them with this public key so let's let's see what this actually looks like let's pick a random key a more secure key right because the longer it is the more secure it's going to be and if we go to signatures now right um let's say we have this uh this message that we want right would say hi world right we want this to be the message what's going to happen is this private key that we've created we can use to sign this data right remember how in the blockchain demo you know we were kind of we were hashing stuff right we were using this Shea 256 hash to get this hash well we're doing something similar but instead of hashing we're we're using this digital signature algorithm to create this message signature now what's really powerful about how this uh this algorithm works is that you can create this message signature with your private key but somebody else can't derive your private key from the message signature and that's what makes this really really powerful however if we go to verify using this public key right and so this is the this is that 0403 this is that same public key using this using this public key anybody can verify let's go ahead and sign it again anybody can verify that this signature is yours right so you have a public a private key just for you so you can sign things and a public key that anybody can verify something right so anybody can verify this and let's say somebody tries to fake a transaction from you they say hey you know this is this is this is their transaction um all they have to do is verify that this signature against your public key and very easily this whole thing turns red because it isn't verified right the the algorithm says hey uh that's wrong so we can go ahead and take that into transactions in this exact same way so if I want to send money you know if I want to send 400 from you know my address to another address using my private key I can sign that transaction and anybody else in the world can then verify this transaction right and this is why what people say hide your keys you know protect your keys this is what we're talking about in our accounts here right if we go to uh settings and again the only reason that I'm showing you guys my mnemonic and my private key is because this is a this is a dumpster account I'm going to throw this away at the end of this video or I'm just not going to put any real money in it um but when we look at our our meta mask here we have this mnemonic phrase which allows us to easily get these different private keys right so uh mnemonic phrase combined uh with you know whatever account number we'll get us a private key so mnemonic phrase combined with one we're gonna get this private key and this is when we look at Account Details export private key password confirm this is going to be the private key that we're going to use to sign our transactions right this if anybody else gets access to this private key they then can sign transactions for us and they can send transactions for us and that's why we want to keep these private so uh it works the exact same way right so this is why it's so important to hide your private keys and hide your mnemonics now your ethereum address is actually a piece is actually a piece of your public key now to get our address in ethereum all we have to do is take this public key that we've created with our private key hash it using that same ethereum hashing algorithm and then take the last 20 bytes and that's how we'll actually derive to our um to our address here now knowing the exact methodology of how to get the address doesn't really matter because it could change blockchain to blockchain and could even change in E2 but just know that that is essentially how kind of these addresses are derived right there's some derivative of the public key right because the public key is public and you know using the public key in kind of any public way is is totally fine um but not the private game so that is how we sign our transactions note though this isn't how we send the transaction so so this is just going to assign it create a transaction for us to send we'll learn later on how to send these transactions oh so that was a lot of information there too let's do a quick recap your public key is derived by using a digital signature algorithm on your private key right and you want to keep your private key private at all times because you're going to use your private key to sign transactions signing transactions with your private key you are the only one who can actually do this because you can't get the private key from a message signature however using your public key you can anybody can very easily verify that a signature that's signed by you is in fact signed by you in our metamask our private keys are located in this Account Details section you just hit show Private keys and type in your password and you'll get your your private key here and the address of your account is derived from this private key and it's derived from this public key so if you think about it your private key creates your public key which then can create your address and there's a little barrier or a big barrier here because your private key you want to keep private and your public key and your address can all be public information now remember how in our metamask we were able to actually create new accounts mine says account six because I've created actually a few but how was it actually creating those accounts well now that we know all this if we go back to our blockchain demo here what our metamask is doing is essentially taking our mnemonic or or that multi-word secret phrase and then just hashing it with some number so secret phrase plus zero gets this and it'll set this as your private key and for our account one that'll be the private key or maybe it's plus one the exact algorithm that it's using doesn't matter but if you want to create a new private key where you just hit this create account button the way it actually picks this account is by taking this secret phrase and then just changing this number so if I go if I'm in my metamask I do create account this right now I'm on account six because like I said I made a whole bunch if I make account six right it's as if we just did the secret phrase plus six and created this new hash or this new private key and created this new hash and it uses this to make a private key and this is why in your meta mask if you share that secret phrase if you share that mnemonic device they will have access to all the accounts that you ever created however if you share your private key it will just give them access to that single account secret phrase has access to all the accounts created in your metamask or your wallet your private key is accessed to that single account and the public key or address anybody can have access to and it's cool for anybody to have access to so when I'm thinking about the security of my metamask or my wallet this is kind of the order that I think of it in the seed phrase or mnemonic or secret phrase is incredibly important protect this at all costs because if somebody else gets access to this they will have access to all of your accounts the second most important is the private key because if somebody gets access to that they will get access to a single account and then you public key your address which whatever it's public now that we know a little bit more about what's going on underneath the hood of these blockchains let's go back at our transactions and look at this gas thing again and we'll look to see what's actually happening here gas in particular can be a little bit tricky to wrap your head around so if you don't get it right away don't worry as we go through examples it'll start to make more sense so before I was saying let's just look at this transaction fee bit which is the cost associated with running this transaction if I scroll over this on etherscan I can see this thing that says Block Base fee for gas plus Max priority fee per guess times the gas use which might be a little bit confusing here let's actually break down what's going on on ethereum with eip1559 in place and again this is going to be specific to ethereum as every blockchain might do it a little bit differently but if we click to see more we can see a number of useful values here we can see gas limit is 21 000 and usage is 21 000. so this transaction used 21 000 gas and we sent 21 000 gas along with it sometimes when sending a transaction depending on when it's sent and depending on what these Specific Instructions are it might actually use way more gas than what you wanted to use so with your transactions you can actually set a limit hey I don't want to use more than x amount of gas I don't want to do more than x computational units and in fact if we go to our metamask and we click Send to transfer between accounts again and we pick you know 0.01 eighth or something next you can actually hit this little button here go to Advanced and we can actually edit some specifics of this transaction one of them is going to be the gas limit we can change this gas limit to maybe 2200 2300 or more or even less since sending ethereum takes exactly 21 000 gas metamask just defaults to setting it to that but we also see these other interesting things we see a priority fee and a Max Base fee let's reject this transaction and let's look back at etherscan to talk about these So currently in ethereum according to e eip1559 every transaction on ethereum comes with something called the base fee this is the minimum gas price you need to set to include your transaction and you'll notice that these are priced in something called gray so what is Agway if we come to the site eatconverter.com and again there's a link to this in the GitHub repository we scroll down we can see way and ether if I put one ether in here I can see how much one ether is in terms of gray and in terms of whey one ether is equal to one two three four five six seven eight nine nine zeros so that's that's one billion way is going to be one ether and then one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seven and eighteen and then 18 zeros is away these are just easier ways of referring to really really small amounts of ethereum so if we look at our gas fees we see that the base fee is 0.00004 gray and this obviously would be an even smaller number if this was in units of way so if we take this number and we put it into our calculator we can see that this is equal to 40 whey or 0.000 a whole bunch of zeros for or ether the max fee here refers to the maximum gas fee that we're willing to pay for this transaction and you can actually see that our Max fee is a little bit higher than what we actually ended up paying our Maxi was 2.2132 something something and the gas price we actually paid was up here now your transaction might of course be a little bit different then additionally we have a Max priority fee this is going to be the max gas fee that we're willing to pay plus the max tip that we're willing to give to miners now currently in ethereum this base fee ends up getting burnt and we can see on etherscan exactly how much is getting burnt here and if we pull up our calculator again we can grab this gas fee multiply it by the amount of gaps we used and we can see that this is indeed how much ethereum we actually ended up burning we go back to ethereum converter paste it in we can see that these two numbers are indeed equal this means whenever you send a transaction a little bit of ethereum is removed from circulation forever or it's considered burnt So currently in ethereum part of your ethereum part of your transaction fee actually gets burnt and then the other part goes directly to minors so to figure out exactly how much went to minors we could do this number minus the burnt amount and this is how much ethereum was paid to an ethereum minor for this transaction you'll see down here transaction type 2 eip1559 this is the eip1559 version of these transactions like I said every blockchain is going to have a different fee burning and fee and gas process and they're all going to be a little bit different but the sum of it is blockchains have limited block space for transactions the gas price that costs for your transaction to be included in one of these blocks changes based off how much demand there is the base gas fee for ethereum will go up and down depending on how many people are sending transactions and how many people want to be included in a block if a ton of people want to be included in a block that means a ton of gas is obviously going to get burnt we've left a link to a video in the GitHub repository with this section from this YouTuber who does an amazing job breaking down this EIP 1559 and more about how the this gas model actually works I highly recommend you pause this video and watch that video to understand more the base fee gets programmatically algorithmically adjusted to try to Target for all the blocks to be 50 full if they're more than 50 full this base fee automatically goes up if they're less than 50 full this base fee goes down now this is a lot of the basics of how this transaction works and it can be a little confusing so let's do a quick refresher of everything in here there's a unique transaction hash that uniquely identifies this transaction on this blockchain we can see the status we can see the block number that it's confirmed on one other thing we want to look at if we scroll up we see block number and block confirmations this is how many blocks have been mined since this block was included like we saw with our blockchain demo the longer the blockchain gets the harder it is to tamper with and the more secure it is typically you'll see some processes say that they'll only do something after 20 block confirmations 30 Block confirmations or or Etc the reason that they wait for these block confirmations is because they want to make sure that that transaction is actually included and we can actually see the block that our transaction was included in and all the other transactions with it different details about how much gas was used the gas limit Etc timestamp is when the transaction happened we can see from and two we can see the value and then we can see the transaction fee which we see right here is Block Base fee for gas plus the max priority fee per gas times the gas used and we see all the details of the gas down here gas price is the cost of one unit of gas gas limit is the max amount of units of gas that we're willing to pay in this transaction the usage is how many actually got used the base fee is going to be the base Network fee per gas so 40 way per one gas used the max gas is the max gas price we're willing to pay and Max priority is going to be the max gas price plus the tip that we give to Miners and then we can see how much is burnt and then we see transaction savings which which is the difference between how much was actually used or paid for and then returned so for example in this transaction the gas price we ended up picking was a little less than our Max gas price here so the gas price we ended up using was a little less than our Max priority fee here so we had some savings compared to that we can also see that this was an EIP 1559 transaction we can see our nunts here which was nunce Zero because the transaction that I'm showing is our first nuns and then of course we can see the input data for transactions that are just sending ethereum the input data is going to be blank but you'll see that when we get to Smart contracts the input data is not going to be blank and it's going to be one of the most important features of these transactions you'll also notice that there's a state tab this is an Advanced Tab and it shows the different states that are changed based off of this transaction we're going to ignore this one for now now that we know how the blockchain itself Works under the hood let's talk about some blockchain fundamentals and we actually covered all these topics in a previous free code Camp video so let's go to that if the first time you listen to this some of these Concepts seem a little bit hard to grasp don't worry about it as we continue and as we move on with this course they'll start to make more sense when you see them used in real examples I definitely would recommend going back and re-watching and re-listening to the parts that you don't quite get and asking questions in the discussions tab of the GitHub repository awesome so now that we know all the cryptography pieces and all the little nitty-gritties of how the blockchain actually works and how our signatures work and how everything sticks together let's talk a little bit about how this works in actuality and what's really going on now for a lot of this each different blockchain has slightly different algorithms and slightly different metrics and criteria for doing a lot of this stuff so when we're talking about these specific implementations keep in mind the exact algorithm might be a little bit different but the concepts are also going to be exactly the same hashing and hash function is going to be the same no matter where you look a decentralized blockchain is going to be the same no matter where you look how it's actually implemented is going to be a little bit different now traditionally when you run an application you know be it a website or something that connects to some server you are interacting with a centralized entity and unlike how we saw with the blockchain with multiple different peers it's going to be run by a single centralized group now it still could be run on many different servers but all those servers are still going to be controlled by the same centralized group blockchains as we saw run on a network of different independent nodes when we saw peer a peer B pure c those were different examples of different independent users running the blockchain technology on their own node now when I use the term node I'm usually referring to a single instance of a decentralized system so when I say a single node when I'm talking about a blockchain I'm talking about one of those peer A's peer B's piercings running that blockchain software I'm talking about one server running this technology and again it's this network it's this combination of these nodes interacting with each other that creates this entire blockchain what makes these so potent too is that anybody can join the network and that's why there's decentralized the barrier to entry is a little bit of Hardware requirements you're getting the correct materials to run the software and then you running the software anybody can join these networks and participate and that's what makes it truly decentralized in fact you can go to GitHub right now and run your own ethereum node in a few seconds now in the traditional World applications are run by centralized entities and if that entity goes down or is maliciously bribed or decides that they want to shut off they just can't because they're the ones that control everything blockchains by contrast don't have this problem if one node or one entity that runs several nodes goes down since there are so many other independent nodes running that it doesn't matter the blockchain and the system will persist so long as there is at least one node always running and luckily for us most of the most popular chains like Bitcoin and ethereum have thousands of thousands of nodes and as we showed in our demo if one node acts maliciously all the other nodes will ignore that note and kick that out or even punish it in some systems because they can easily check everybody else's note and see okay this one is out of sync with the majority and yes majority rules when it comes to the blockchain each blockchain keeps a full list of every transaction and interaction that's happened on that blockchain and we saw if a node tries to act maliciously then all their hashes are going to be way out of whack and they're not going to match everybody else this gives blockchains this incredibly potent immutability trait where nothing can be changed or corrupted so in essence we can think of a blockchain as a decentralized database and with ethereum it has an extra additional feature where it also can do computation in a decentralized manner now let's talk consensus proof of work and proof of stake because you've probably heard these before and they're really important to how these blockchains actually work when we went through that blockchain example and we did that mining feature this is what's known as proof of work proof of work and proof of stake fall under this umbrella of consensus and consensus is a really important topic when it comes to blockchains consensus is defined as the mechanism used to reach an agreement on the state or a single value on the blockchain especially in a decentralized system I briefly alluded to this consensus mechanism in our blockchain example when I said if one changes something and the other two don't then majority Will Rule and kick that one out this is part of that consensus mechanism now very roughly a consensus protocol in a blockchain or decentralized system can be broken down into two pieces a chain selection algorithm and a civil resistance mechanism that mining piece that we were doing or or the proof of work algorithm is what's known as a civil resistance mechanism and this is what ethereum and Bitcoin currently use please note that depending on when you're watching this if eth2 is out then it's no longer proof of work now proof of work is known as a civil resistance mechanism because it defines a way to figure out who is the block author which node is going to be the node who did the work to find that mind and be the author of that block so all the other nodes can verify that it's accurate civil resistance it's a blockchain's ability to defend against users creating a large number of pseudo-anonymous identities to gain a disproportionately advantageous influence over said system and in layman's turns it's basically a way for a blockchain to defend against somebody making a bunch of fake blockchains so that they can get more and more rewards now there are two types of the Civil resistance mechanisms that we're going to talk about here namely proof of work and proof of stake let's talk about proof of work a little bit more in depth first in proof of work this is silver resistant because a single node has to go through a very computationally expensive process called mining which we demonstrated earlier to figure out the answer to the blockchain's riddle of finding that correct nuns or or whatever the blockchain system has in place in proof of work this works because no matter how many pseudo-anonymous accounts you make each one still has to undergo this very computationally expensive activity of finding the answer to the proof of work problem or the proof of work riddle which again in our demonstration it was finding a nunce with that first four zeros but again each blockchain might change the riddle word or change the problem to be a little bit different in fact some of these blockchains make this riddle intentionally hard or intentionally easy to change What's called the block time the block time is how long it takes between blocks being published and it's proportional to how hard these algorithms are so these problems actually can change depending on how long they want the blockchain to be if the system wants to block time to be very very long they just make the problem very very hard if they want to be very short to make the problem a lot easier we'll talk about civil attacks in a little bit and how they can affect the system but with proof of work it's a verifiable way to figure out who the block author is and be civil resistant now you need to combine this with a chain selection rule create this consensus now there are some consensus protocols that have more features but very very roughly these are the two pieces that we're going to look at the second piece is going to be a chain selection rule how do we know which blockchain is actually the real blockchain in the true blockchain now on bitcoin and ethereum they both use a form of consensus called Nakamoto consensus and this is a combination of proof of work and longest chain rule the decentralized network decides that whichever blockchain has the longest chain or the most number of blocks on it is going to be the chain that they use this makes a lot of sense because every additional block that a chain is behind it's going to take more and more computation for it to come up that's why when we saw in our transaction we actually saw confirmations the number of confirmations is the number of additional blocks added on after our transaction went through in a block so if we see confirmations as two it means that the block that our transaction was in has two blocks ahead of it in the longest chain now I do want to point out that a lot of people use proof of work as a consensus protocol and I do want to say that this is a little bit inaccurate but sometimes people use it interchangeably proof of work is a piece of the overall consensus protocol which in Bitcoin and ethereum one's current case is Nakamoto consensus Nakamoto consensus is a combination of proof of work and its longest chain rule both equally and very very important now proof of work also tells us where these transaction fees and these block rewards go to remember how when we made this transaction we had to talk about gas and a transaction fee so who's getting paid who is getting this transaction and this transaction fee is going to the miners or the validators in a proof of work Network they're called Miners And in the proof of stake Network they're called validators there are a little bit different and we'll get into that when we talk about proof of stake in this proof of work system all these nodes are competing against each other to find the answer to the blockchain riddle remember in our example it was to find a hash that has four zeros at the start and again depending on the blockchain implementation that riddle is going to be a little bit different but all the nodes are trying as many as possible to try to get this answer first why because the first node to figure out the answer to the blockchain rule is going to get that transaction fee they're going to get paid from that now when a node gets paid they actually get paid in two different ways one is going to be with a transaction fee and another piece is going to be the block reward remember how we talked about alternating the gas price or the gray on our transaction well that's the transaction fee that we're going to pay to these blockchain nodes for including our transaction the block reward is given to these nodes from the protocol from the blockchain itself you've probably heard of the Bitcoin having before the having is referring to this block reward getting cut in half and it's supposed to be cut in half roughly every four years this block reward increases the circulating amount of whatever cryptocurrency that is being rewarded for example on ethereum the Block reward is giving out ethereum and on bitcoin the block reward is giving out Bitcoin so these nodes are competing against each other to be the first one to find this transaction to be the first one to find the answer to this problem so that they can be the ones to win both this block reward and your transaction fee some blockchains like Bitcoin for example have a set time when they are no longer going to give out block rewards and the miners or the nodes are only going to get paid from transaction fees now this gas fee again is paid by whoever initialized the transaction when we got our funds from the faucet there was some server and somebody else was paying the transaction fee for us however when we sent ether from One account to another our first account actually paid some transaction fee to send that ether in proof of stake there's also a gas fee but it's paid out to validators instead of Miners and we'll talk about that in a little bit now let's talk about two types of attacks that can happen in these blockchain worlds let's talk about the first one being the Sybil attack the Civil attack is when a user creates a whole bunch of pseudo-anonymous accounts to try to influence a network now obviously on bitcoin and ethereum this is really really difficult because the user needs to do all this work in proof of work or have a ton of collateral in proof of stake which again we'll talk about in a bit the other more prevalent attack is what's known as a 51 percent attack now as we saw as part of our consensus protocol these blockchains are going to agree that the longest chain is the one that they're going to go with so long as it matches up with 51 percent of the rest of the network this means that if you have the longest chain and you have more than 51 percent of the rest of the network you can do what's called a fork in the network and bring the network onto your now longest chain now civil attacks obviously are when a single node or a single entity tries to affect the decentrality of the network by pretending to be multiple different people although they're just the same person or entity and like I said it's really difficult to do improve of work and proof of stake so you can see now that blockchains are very Democratic whichever blockchain has the most buy-in and is the longest is the blockchain that the whole system is going to corroborate when nodes produce a new block and add to the longest chain the other nodes will follow this longest chain that the rest of the network is agreeing with ADD those blocks to their chain and follow up so very small reorganizations are actually pretty common when a blockchain picks a block from a different longest chain puts it on and then has to swap it out for another block and continue with a different blockchain however if a group of nodes had enough nodes or enough power they could essentially be 51 percent of the network and influence the network in whatever direction that they wanted this is what's known as a 51 attack and it's happened on blockchains like ethereum classic which is not ethereum this is why the bigger a blockchain is the more decentralized and the more secure it becomes so after you watch this video and you become a blockchain engineering expert I definitely recommend you run a note as well because you are going to increase the security of the network as a whole by running a node so approval work is fantastic because it allows us to very easily protect against these civil attacks and keep our blockchains decentralized and secure however it has some drawbacks as well proof of work costs a lot of electricity because every single node is running as fast as they can to win this race to get the rewards this leads to obviously an environmental impact now since proof of work in Nakamoto consensus a lot of other protocols have taken this idea and gone in a different direction with a different civil resistance protocol a lot of them with the intention to be a lot more environmentally friendly and the most popular one right now is proof of stake there are some chains that are already using this proof of stake protocol and that are live and thriving some of them are like Avalanche Solana polygon polka dot so let's talk about proof of stake now again this is a different civil resistance mechanism instead of solving this difficult problem proof of stake nodes put up some collateral that they're going to behave honestly AKA they stake in the example of ethereum 2 nodes put up some ethereum as a stake that they're going to behave honestly in the network if they misbehave to the network they are going to be slashed or removed some of their stake obviously this is a very good civil resistance mechanism because if you try to create a whole bunch of anonymous accounts then each one of those accounts you have to put up some stake and if you misbehave you're going to run the risk of losing all the money that you put up as collateral in this system miners are actually called validators because they're no longer binding anything they're actually just validating other nodes now unlike proof of work which every node is racing to be the first one to find the block and proof of stake nodes are actually randomly chosen to propose the new block and then the rest of the validators will validate if that node has proposed the block honestly as we saw with our cryptography lesson it's usually very easy for other nodes to verify if a proposal or a transaction is honest now proof of stake obviously has some pros and cons as well Pros are that again it is a great civil resistance mechanism and a great way to figure out who the author of a block should be the other Pros are that it's way less computationally expensive to figure out the new block because instead of every single note on the network trying to do this only OneNote needs to do this and then the rest of the nodes just need to validate it the cons are that it's usually considered a slightly less decentralized Network due to The Upfront staking costs it costs to participate now this gets into a little bit of a philosophical battle on how decentralized is decentralized enough and I think that's up to the community to decide and as we progress I think we'll learn more and more about how decentralized is decentralized enough the general consensus amongst blockchain Engineers though is that proof of stake is very very decentralized and very secure now there's another term that might be the first time you heard it a layer one we're going to talk about layer ones and layer twos in terms of scalability really quickly as well a layer 1 refers to any base layer blockchain implementation bitcoin's a layer one ethereum is a layer one Avalanche is a layer one these are the base layer blockchain Solutions a layer 2 is any application that is added on top of a layer one added on top of a blockchain some examples of layer twos are going to be chain link arbitrom or optimism arbitrum and optimism are very interesting because they are layer twos that also look to solve this scalability issue arbitrum and optimism are what's known as Roll-Ups and they roll up their transactions into a layer one like ethereum we're not going to go too deep into Roll-Ups and how they actually work but all you really need to know is that they solve some of the scalability issues by being another blockchain that people can make transactions on still on kind of this base ethereum layer now they're different from side chains because side chains derive their security from their own protocols Roll-Ups derive their security from the base layers so arbitrum and optimism for example is going to be just about as secure as ethereum there's some fantastic guys in there that go a little bit deeper into Roll-Ups and I've left a link in the description for you all right so we just talked about a lot of stuff so let's do a quick recap before moving on civil attacks are prevented due to protocols like proof of work and proof of stake 51 attacks grow increasingly harder with the size of blockchain so you should run a node consensus is the mechanism that allows a blockchain to agree upon what the state of the blockchain is sharding and Roll-Ups are solutions to scalability issues on layer ones a layer 1 is any base blockchain implementation like Bitcoin or ethereum a blockchain scalability problem is that there's not always enough block space for the amount of transactions that want to get in them this leads to very high gas prices and again gas prices are how much it costs to interact with a blockchain so that's it for the blockchain basics and the blockchain explainers with just this information you now can go off into the world and start working with blockchains and interacting with blockchains with at least some level of knowledge as to what's going on you should be incredibly proud of yourself for just making it this far definitely be sure to give yourself a pat on the back and a round of applause now that we've gotten a lot of the basics and the fundamentals out of the way let's start jumping into the coding aspect this is where you're going to learn how to actually build these smart contracts how to build these trust minimized agreements in these blockchains and in these smart contract platforms this next section this solidity Basics the solidity fundamentals section will give you all the skills to start actually coding solidity and understanding how these smart contracts work underneath the hood so at this point absolutely give yourself a high five maybe say hi in the GitHub discussions maybe say hi in the community on Twitter on Reddit Etc and be proud of just making it this far the journey has really only just begun but you've already learned so much let's begin the next section and let's jump into the code now that we're getting to the coding part I need to stress to absolutely use the GitHub repository or web3dev.education associated with this course if you're on the GitHub repo right now and you scroll down to lesson two and this is going to look a little bit different when you come to it you can click on the GitHub repo associated with this lesson this will have all the code that we're actually going to be working with for this section as well as a readme section which is going to have a lot of notes on how to actually work with the code and instead of making issues and discussions on this repository here if you have an issue please use the discussions tab of The Foundry full course here or use any of the areas that we've laid out in the questions section we're going to teach you how to ask questions so that they have the highest probability of being answered by either somebody else in the community by an AI or by a forum additionally please be sure to check out web3dev.education for more information as well I highly recommend that you pause the video right now and make accounts for first of all GitHub and then at least stack exchange ethereum additionally chat gbt is a great resource to make an account for just remember that it will often get things wrong and isn't quite up to date find you don't need to make an account for but it often gets things wrong sometimes as well typically for each coding section I'll give you a brief rundown of what we're actually going to be building and in this lesson we're going to be building this exact smart contract and we're going to be building your first smart contract ever and we're going to deploy it to a blockchain at the end of this section you are going to have deployed your first smart contract ever so be sure to get to the end so you can deploy your first smart contract we're going to be using something called an IDE called remix to deploy and interact and work with this smart contract which is going to be very exciting it it's highly recommended to get the best experience out of this is for you to follow along and you too code with me you can change my speed on the YouTube video if I'm coding too fast or I'm coding too slow are you taking the time to write out the code as I code along with you is going to ingrain the knowledge into your brain repetition is the mother's skill and I want to make sure you come out the other side with skill to actually code this we're going to be using a tool called remix you can either Google search it or you can just come to the GitHub repo or web3dev.education and click this link to remix which will pop open the remix web IDE so let's go ahead let's jump in and let's learn to deploy our first smart contract at the end of this lesson you will have deployed your first smart contract you'll have written your first bit of solidity and we are very excited to get through this part welcome to the remix IDE or the integrated development environment this is where we're going to learn to write a lot of our code in the beginning if you want you can go ahead and accept to help out remix here and if you've never been to the remix website before it'll give you a tutorial walkthrough of some of the features that remix has to offer for example it has a solidity compiler solidity is the programming language that we're going to be using in this course to code our smart contracts where and we need to compile them when we've written the solidity we'll learn about that in a little bit we have a tab here where we can actually deploy our contracts to a blockchain and we have all these different folders and scripts since we can actually write JavaScript and typescript in remix as well but don't worry about those too much for now because I'm going to be explaining everything that we're going to do remix is an incredibly powerful tool because it has a lot of features that allow us to really see and visualize what our smart contracts do eventually we're going to move off of remix to a local development environment however remix as a tool still used by some of the top Auditors and smart contract developers in the space when they want to quickly check something out and additionally it's fantastic for learning the fundamentals of solidity the left hand side is where we're actually going to start interacting with remix if we bring our Mouse up to the top this little file explorer is where we're going to have all of our files and where we're going to write our solidity or our smart contract code if you want you can leave all these folders in here but I'm actually going to go ahead and delete everything so that there's less for me to work with or deal with so I'm just going to go ahead and right click and delete everything in here just so I can start completely from scratch again if you want to leave all of these in here feel free to do so doesn't matter I just think it's cluttering up my mental space a little bit now we have a blank remix project and the first thing that we're going to want to do is create our first file to start writing and deploying our solidity smart contract we're going to go ahead and click the create new file right here and type in simple storage.soul dot Sol tells our compiler that this is going to be a salinity contract a solidity file and we're going to be writing solidity inside of this file which again solidity is the most popular smart contract programming language and you'll see we actually get popped up a simplestorage.soul on the right hand side which we can type in and actually write our solidity code now right below the file explorer button is a little search icon which allows us to search for different code in all of our contracts so for example if I type in hello in here and I copy that paste that into the search bar hit enter we can see that it found this line hello in our simple storage.soul let's go ahead and delete that right below that search icon is this solidity compiler and you'll see a bunch of different stuff pop up which tells us about our compiler configuration and we can see even more advanced configuration if we hit the drop down we're not going to hit that for now let's go ahead and double click this solid compiler over here so we can just see the simplestorage.soul I'm also going to click this hide terminal button so that we just see our simplestorage.soul now the first thing that we want to do in all of our solidity in smart contracts is write the solidity version that we're going to be working with solidity is a constantly changing language and we want to be very specific about what version we're going to be using to write our smart contract as each version does different things so write your version you're going to do pragma solidity and then type your version for most of this course we're going to be using 0.8.19 as that's the most current edition of solidity how are we getting used to working with different versions of solidity is really good for you as you're going to be working with different versions of solidity no matter where you go certain versions of solidity are considered more stable than other versions right now there's a popular tool called Slither which recommends using 0.8.18 so if you want to default to 0.8.18 for this course feel free to do so we're going to be using a couple different versions as we code so this line says we're stating our version now these two slashes here stand for what's called a comment in solidity and this allows you to write anything after the two slashes and when we compile or run our code it will just ignore what's in here so we could type blah blah blah whatever we want cats are cool and it doesn't matter you can write anything in here I highly recommend as we're going along you should write comments in your own code as well for you to refer to later on and additionally feel free to copy all the code that you write and paste it locally so that just in case your browser cache refreshes or something you won't lose all the work you've done so so before you lock off for the day copy paste this into a text file so that you can have it for later but a good comment for here might be this is the version now writing our version like this in solidity tells the solidity compiler that we're only allowed to use 0.8.18 when compiling this however maybe a new version comes out and we're okay to use anything newer than this version to tell the compiler that we add this little hat this little carrot which says this contract only works with 0.8.18 or anything greater than that this means 0.8.19 would work when 0.8.20 comes out that one would work however 0.8.17 would not work if we were working with 0 0.8.18 or above if we don't have the carrot this tells the compiler that only 0.8.18 will work with this code if we want to use slotted versions within a range we could do something like this we could say we want our version to be greater than or equal to 0.8.18 but less than 0.9.0 this would tell the compiler that any version between these two is a valid version for example 0.9.1 would not work neither would 0.9.0 because these are not strictly less than 0.9.0 great so now we know how to do compiler versions now the next thing every smart contract needs to start with is something called the spdx license identifier now this actually isn't required by the compiler it'll actually throw a warning if we compile and it won't error it's fine if you don't have this however it's highly recommended this is a way to make licensing and sharing code and IP of your contracts a lot easier from a legal perspective I have a link to more about how licenses work in the GitHub repo associated with this section of the course MIT is known as one of the most permissive licenses basically means anybody can use this code and pretty much do whatever they want with it I wouldn't worry too much about the licenses right now but let's actually go back to 0.8.19 and on the left hand side let's scroll down to this compiler button and open this back up even right now now that we don't even have any code we can actually go ahead and compile this contract now you might see a red squiggly and you might see a warning here but don't worry about that for now to choose our compiler version We scroll up to this section and we can choose the compiler version that we want to work with most of the time though if you just hit compile simple storage.soul or you hit this big compile button it'll automatically choose the version for you for example if I scroll down but I hit compile it'll automatically flip up to 0.8.19 and we were able to go ahead we were able to successfully compile this code now it says no contract compiled yet because we haven't put a contract in here yet we just put the version of solidity that we're working with compiling our code means taking our human readable code and transforming it into computer readable code which is essentially a bunch of zeros and ones or it's byte code computer code is very specific instructions for the computer to use or in our case the blockchain to use for our contract we'll learn later about Machine level code and op codes and evm codes in a much later section of this course Additionally you can hit command s or control s which will also save and compile you'll see I kind of have a trigger finger and I will out of habit hit command s all the time because as somebody who codes a lot I need to make sure I save all the time otherwise things might not work as intended as you saw if we use a different version of solidity and we hit the compile button it'll automatically flip back but for example let's say I I wanted to use 0.8.7 anything greater than that and we're on compiler 0.8.19 and we hit compile it won't change however if I use something less than 0.8.7 and we hit compile it'll change because it wants to automatically select a solidity version that is appropriate for the version that you chose again I want to use 0.8.18 and I'm going to hit compile and we're good to go now we're going to go ahead and start writing our contract and to get the full screen view again we just go ahead and click the solidity compiler so that we can just see our code here to start writing our contract we're going to use a keyword in solidity called contract this tells solidity that the next piece of code is going to be the name for our contract that we're going to create you can think of a contract very similar to a class if you're familiar with JavaScript or python or Java or really any object oriented programming and we're going to go ahead and give our contract a name here we're going to call ours simple storage and then we add this little open and closed curly braces or curly brackets everything inside of these curly brackets is going to be considered part of this contract simple storage now if we hit enter we go back to the compiler and hit compile we can see once again this little green check mark pop up this means our compilation has been successful if we were to remove for example this curly brace and hit compile we would see we would get this error compilation failed with one error and if we scroll to the bottom it'll tell us where the error actually is and we'll get a little red pop-up saying what line the error is actually on we'll learn about debugging these errors in a little bit but let's add the curly brace back go ahead back to the compiler hit compile and we're good to go hypothetically we can deploy this smart contract right now this is a valid contract although it doesn't do anything but congratulations technically with just this little piece of code you've written your first smart contract I spelled version so we're going to correct that slitty has many different types of things that you can build in these smart contracts many different data types or just types if you go to the slitty documentation at docs.solutedylang.org again link to this in the GitHub we can select the types section on the left hand side to learn more about solidity types if you want to get a holistic view of all the different types you can go ahead and read this documentation some of the basic types are going to be Boolean Boolean uint and an address and bytes bytes is a lower level type which we'll talk about in a little bit a Boolean is some type of true false value a uint is going to be an unsigned integer AKA a positive whole number meaning no decimals no fractions a integer is going to be a signed whole number meaning it could be positive or negative but again it's a whole number and then we have an address which is going to be well an address it's very similar to if we open up our metamask and we click this account here it's going to be something like this there are some other types as well and ways to create your own custom types but we'll learn more about that later on we can use these different types to Define different variables variables are essentially holders for different values and these values can have one of these types for example we could create a variable called has favorite number which would represent if somebody has a favorite number this has favored number it could be true or false either they do have a favorite number or they don't to tell solidity that this has favorite number is a true false or a Boolean we would add this Bull keyword before has favorite number so this has favor number is going to be either true or false and to set its value we're going to give it this little sign and say true so now has favorite number is a variable that represents true we could also say has favorite number is false meaning that somebody doesn't have a favorite number for a unit which again is an unsigned integer we could say uint favorite number equals 88 this means that this variable favorite number is going to be 88. a uint and int are actually special in that we can actually specify how many bits or bytes that we want to use for example we could say U and 256 U and 256 specifies this variable favorite number has 256 bits we're not going to go over bits and bytes in depth right now but if you want to get a quick refresher we've left a link in the GitHub repo associated with this course to give you an overview of bits versus bytes and how they work an easier way to think about this is really just how big can it get the bigger the number over here the bigger this favorite number can be the maximum size is a uint 256 and if you don't specify the unit 256 it defaults to being Au and 256. so this and this are the same thing this this same thing you could also have 8 Bits 16 bits 64 bits Etc oftentimes it's better when we're writing our code for a readability standpoint to be as explicit as possible so you'll see me pretty much always writing u in 256 because I want to be very explicit with how many bits I'm using for you into 56 even though they mean the same thing instead of a u into 56 we could also have this be an INT 256 and actually let's add that Boolean back up here now an INT can actually be positive or negative so we could have our favorite number be negative 88 if we wanted to we can also have strings or text variables which I didn't name up here but I'll say why in just a minute we could say string favorite num in text equals 88. let's actually make this positive 88 even though an inch could be positive or negative I'll put the this little semicolon here you'll notice that at the end of every one of these lines I'm adding this semicolon the semicolon is how you can tell solidity that a statement has completed so this semicolon is saying the end of this line is right here if we wanted to we could put all of our code on the same line like this and this would compile fine it just looks really ugly so we always want to put our code on a new line after the semicolon a string in solidity is basically text that represents well words so I could say 88 instead of having 88 in here to tell solidity that something is a string you have to put it in between quotes I could put really any combination of characters in here even like hello or follow Patrick on Twitter and let's actually do you want 256 here favorite number and we'll do it into 56 favorite hint equals negative 88. this way we'll just have an example of all these different types on screen we can also do an address so we can say address my address equals and we can go into our metamask copy the address and paste it right into remix and add that semicolon and now we have our address type in remix and then finally down here we're going to say a bytes 32 object a volt bytes 32 equals cat and we're going to put it in quotes just like we did the string up here and what's interesting about the string object is that strings are actually secretly just bytes objects specifically for text so a string can actually get converted to a bytes object really easily because under the hood they're essentially the same thing bytes typically look like something like Xerox and then a whole bunch of random numbers and letters that represent the hex of whatever the bytes is and can often be represented as strings like cat we'll talk about bytes more in the future similar to uint 256 and into 56 you can have different size bytes like bytes too two lights whites four bytes eight Etc all the way up to 32. you can also have just straight up bytes and not have a number after but that's a slightly different type and we'll go over that later as well you went like this and the U and 256 are the same thing but he bites 32 and abites with nothing are actually different so keep that in mind for now the largest bytes like I was saying is actually 32. so for example we can't do a bytes 64 and if we type that in here this remix actually goes hey there's an issue here and if we try to compile this we scroll down we'll again see this little error code here and this little arrow pop up it even gives us an output declaration error identifier not found or not unique it gives us the line and we can say ah whoopsa Daisy this should be a bytes 32 and we can go back and compile this for our simple storage contract let's say that we only want to store a favorite number this contract is going to be a contract that allows us to store our favorite number and some different people's favorite numbers as well so we're going to go ahead and delete everything except for the unit 256 favorite number so we're going to go ahead and delete everything and boom and we'll pick a smaller favorite number just to make it a little mentally easier now these variables actually have default values so for example if I don't set my favorite number to anything and I have a line that looks like this you'll see that this actually compiles fine favorite number will actually get defaulted to zero and all of these types have a different default value um 256 is zero booleans is false Etc so saying u256 favorite number and not having an equal sign after here is the same as doing U and 256 favorite number equals zero so for now let's not initialize it to anything so that favor number starts off as zero and remember as you're coding along here and typing along with me if you get confused make sure to write your own comments for example we can say favorite number gets initial sized to zero if no value is given now let's go ahead and learn to make our first function basic solidity functions section functions or methods functions or methods are a subsection of code that when called will execute a very specific small piece of our entire code base if you're familiar with JavaScript or python or any other programming language functions in solidity are exactly the same functions are identified by the keyword function let's create a function and name it store and we're going to have this function be responsible for actually updating our favorite number we're going to store a new favorite number so you first write the function keyword the name of the function and then you add these two parentheses whatever is in between these two parentheses represents what we're going to pass or send to our function or the parameters that we're going to send to our function for example we need to tell our store function what value it should use to update favorite number so we're going to tell our store function it should take a unit 256 and this variable that we're going to pass to it we're going to call underscore give Orit number it's important that we give it a different name than favor number up here and we'll talk about that in a little bit then we're going to say this is going to be a public function and we'll explain that soon too we want to put these little curly brackets in here as well and we're just going to say favorite number equals underscore favorite number and without going too deep into what this is doing we're saying I'm not going to explain public yet but we will in a minute but what we're saying is whenever you call this store function you're going to set our favorite number variable to whatever variable that we passed I'll explain why we do this underscore here as well in a little bit and with just this we can actually start to simulate what this smart contract will do and if our store function will actually work correctly so what we can do with just this code right here is come over back to the compile Tab and hit compile make sure that we get this green check mark and that everything looks good and then we can go down to this deploy and run transactions tab our deploy and run transactions tab has a ton of different parameters in here on how to actually deploy and run with our transactions we're going to deploy this contract to a simulated virtual environment so we're going to deploy it basically to a fake environment we're not going to be deploying it to a test that we're going to deploy it basically in kind of an imaginary world in order for us to do this first make sure we're on this remix VM and for us we're going to just use the default which is the merge doesn't really matter which one you're on just so long as it's the remix VM this remix VM is a fake local blockchain where we don't have to wait for transactions to complete and we don't have to deal with any of the oddities on deploying our code to a real test net or a real mainnet and don't worry about the rest of these for now we also get an account here when we run on our fake remix VM we get automatically given an account with a different amount of ethereum for each account you can think of each one of these accounts similar to our metamask accounts in metamask except for these are fake imaginary accounts that remix just gives to us for our transactions including deploying contracts we're given a gas limit values that we can send and we'd also choose our contract depending on which one we've compiled since we only have one contract in here we only have one to choose from so on the left hand side to deploy our contract to this fake remix VM environment we're going to go ahead and click the deploy button if we scroll all the way down to the bottom now under this deployed contracts we can see we actually deployed a contract here simple storage we can see the balance of zero and we see this big orange button that says store and then you went to six underscore favorite number on our local blockchain this at blah blah here this is going to be the address of our contract similar to our wallets how they have different addresses every single contract has a unique address as well and if we hit this little copy button and we close this and we put as a comment here and we paste it we can see this looks exactly similar to an address such as what's in our metamask and then let's go ahead and open the deploy back up and we see that deployed contract is still there additionally if you hit this little show terminal button and you pull this up we can actually see we have this little comment here creation of simple storage pending and we have this green check mark here this is notating that we actually sent a transaction to deploy this contract similar to sending eth back and forth in order for us to deploy a contract we actually have to send a transaction since we're doing this on the remix M this is a simulated transaction a pretend transaction inside of our remix environment you can even hit the little drop down and see even more information about this transaction you'll see a lot of familiar keywords like status transaction hash from to gas Etc deploying a contract uses the exact same process as sending a transaction for just eth the main difference is we populate this data or input field with a ton of that bytecode and if you copy this input field or this data field and go ahead and make a comment in here you'll see it's a massive line and this massive line notates all the data associated with this smart contract all the machine readable code remember anytime we do anything that modifies any value on the blockchain we actually do that by sending a transaction deploying a contract is modifying the blockchain so we do it in a transaction which means yes we spend gas now this big orange button over here actually resembles our function store in our smart contract and if we add some numbers in here and we call it again if we pull the terminal up we can see transact to simple storage pending and we see we sent a transaction which called this store if we do this again with a different number we call it we can see our terminals say oh you sent another transaction to update the state of the blockchain and if we scroll all the way up to our account you'll see that we have a little less ether in our account because we had to spend the gas associated with well a deploying this contract and then B calling these functions and then for example if I add this if I add 5 in here and hit store we'll send a transaction to store 5 on the blockchain now you might be thinking okay Patrick that's pretty cool but what is the value of favor number you're telling me that this function store is updating favorite number but I can't really see it how do I know that favor number has actually been updated to five well the reason we can't see it is that the visibility of our favorite number is actually defaulted to internal so us not having anything here or right internal or actually meaning the same thing and we'll talk about visibility and default visibilities in a minute but in order for us to actually see the value of our favorite number we'll go ahead and add the public keyword to this this changes the visibility of favorite number to public and like I said we'll talk about visibility in a minute but let's go ahead and compile this let's go ahead and delete this contract by hitting this x here and let's redeploy this contract with this new public keyword so let's go ahead and hit deploy and now if we scroll down and we open up our simple storage we actually now see a blue button labeled favorite number and if we click it now we can see it returns zero which makes sense because we know that U and 256 is default to zero now if I go ahead and add 5 into here and hit the store button if I pull up terminal we'll see that we went ahead and executed that store function call that transaction that's going to take input this 5 as favorite number and set it to our favorite number now if I hit favorite number you can see it does indeed return 5 showing that we actually updated our favorite number with this function call and remember though I'm going to go ahead and do this again and remember when I hit X here this is just removing it from this window here if you actually deploy a smart contract to the blockchain hitting X from this window doesn't do anything because once you deploy your contract it's immutable it's out there and you can't just delete it by clicking X and remix functions and variables can have one of four different visibility specifiers in solidity public private external and internal if you don't give one of these keywords to your variables it'll get defaulted to internal public functions mean that they're visible externally and internally and you'll see here it says it creates a getter function for storage slash state variables this means that other people can call this function or call this variable when we didn't have a visibility for favorite number it defaulted to internal which is why we didn't see this blue number pop up because internal it means that other contracts and people aren't allowed to call on this favorite number we have a little bit more here it says it actually creates a getter function for storage State variables when we add this public keyword here it's actually equivalent to us making a getter for this favorite number variable a getter function and I'll show you exactly what the function will look like in a little bit now keep in mind though everything on chain is technically public so setting a function or variable to private isn't a good way to hide what the value actually is there and we'll talk a little bit more about storage and visibility and and that much later just remember everything on these evm chains is actually public data this public variable just means any other contract can call this favorite number and see the value what's in favor number and private means only the current contract can external functions mean they're only visible externally and this is only for functions not for variables and it means another function inside this contract couldn't call an external function and internal means only the current contract and its child contracts can call the function we'll talk about child contracts and inheritance in a later section so let's just keep it public for now the reason that we have this underscore here in this parameter is because we need to tell users that this variable in here is different than favor number and there's a couple different conventions on naming local variables versus these what's known as state variables or variables outside of functions and we'll go over those later in the course now here's something that's really interesting as well remember how I told you earlier that sending ether is a relatively simple transaction right well let's see what happens when we call this store function and we update favor number to five let's actually call it one more time and we hit the little drop down here let's go to gas and we'll see gas actually cost 27 000 gas which is a lot more than the 21 000 gas it costs to just send ether between accounts remember every time you update the state of the blockchain it's going to cost gas now what do you think will happen if we do more inside of this store function for example we say favorite number equals itself plus one let's go ahead and compile this let's delete our old simple storage let's deploy this new one remember the last one costs 27 gas let's pull up the terminal and remix actually gives us a little tool tip and saying an infinite gas which we know is actually wrong but let's go ahead and add 1 to 3 in here and we'll hit store we'll see this transaction we'll scroll down we'll see gas is actually a lot more it's way more gas it's 50 000 gas with just adding this line here now technically I'm not telling the full story here because there are some other gas costs associated with the first time you run a function but it's still more right and that's what's important here so so let's go ahead and delete that line and go back to our old function here now let's talk about something called scope for a second so if I create a variable in here called uint256 test VAR equals five and I create a new function called something we'll make it public could I access the test bar and then maybe change it to six or seven what about the favorite number of R what about the favorite number variable could I access that to seven well let's go ahead and see what happens if we try to compile this we try to compile we actually go ahead and get an error in our complication Undeclared identifier whenever you create a variable it can only be viewed in the scope of where it is if that's confusing just look for the curly brackets the reason that are something function can read the test VAR is because this test bar isn't inside of the curly brackets of something the reason it can't read the test VAR is because tesfar was created way up here inside of these curly brackets outside of something but favorite number wasn't created inside of these curly brackets so how come it knows what favorite number is well something is inside of these curly brackets and favorite number was created inside of all of these curly brackets favorite number was created inside of here it wouldn't be able to access favorite number because again favorite number is inside of this scope and not this scope if you create a variable like testvar inside of store you can only access this test bar inside of this store function and not anywhere else the easy way to know what the scope of a variable is is just look for the curly brackets so let's go ahead and delete this something variable and let's delete this test file and let's recompile now like we were saying earlier when we add this public keyword to favorite number it's the exact same as if we created a getter function to return this favorite number so let's actually write a function similar to what this public keyword is creating so we're going to say function retrieve we'll make this a public view function and we'll talk about that in just a second and we'll say it returns a uint 256 and we'll add the curly braces here and we'll say return labelwrit number and oftentimes on these Auto suggestions come up like this you can just hit enter and they will automatically do it so if we do favorite and then I just hit enter boom automatically like that now I'm going to hit command s which is equivalent to me going to the compile Tab and hitting compile now if I go to the deploy Tab and let's deploy this contract now and we scroll down we now see we still have that store function we have our favorite number function and we have a new blue button called retrieve right now they both start off as zero and then obviously if we update this to five by calling store yep I called store these are now both return five since favorite number is the actual variable and retrieve is just returning whatever favorite number is now as you can see here these two functions are blue but this one is Orange what's the difference why are the colors different well the key is actually with this view keyword here solidity has a special keyword which notates functions that don't actually have to run or you don't actually have to send a transaction for you to call them and those two keywords are going to be View and pure a function marked view means we're just going to read state from the blockchain for example in our retrieve function we're just going to read what the favorite number variable is our store function isn't reading it's updating something so and it's changing the state of the blockchain so we have to send a transaction since our retrieve function doesn't have anything inside here that updates anything it just returns a favorite number we don't need to send a transaction so if you add this view function in here it disallows any modification of State for example I couldn't add favorites number equals favorites number plus one if we go ahead and try to compile this we'll get an error function cannot be declared as view because this expression potentially modify state so we'd have to remove this line or we'd have to remove the view keyword so view functions disallow updating state your functions disallow updating State and they disallow even reading from state or storage this favorite number here is what's known as a storage variable because it's stored in a place called storage we'll talk about that in a later section but if this was labeled pure we'd see we get a little red underscore here because favorite number is reading from State instead of returning favorite number we would return something like seven so this would be an example of a pure function this would be an example of a view function because we're reading from State again we'll explain the difference a little bit later and like I was saying before if we call a view or a pure function we actually don't need to spend gas since we're not modifying the state that's why these buttons over here are blue they're representing view or pure functions functions that we can call without having to send a transaction for example if I pull up the terminal here and I pull this up and I call retrieve we do get another function but it's just a call and it looks different than if I hit the store which has this little check mark the difference because the store is obviously sending a transaction and the retrieve is actually just making a call and not sending a transaction however something weird is going on here if I hit retrieve and I go into the details of this call I can see oh what's what's this why is there an execution cost it says cost only applies when called by a contract what's going on there the reason for that is because if another function that does update state that does require a transaction calls retrieve that transaction does need to pay the gas of reading and calling this retrieve function so calling a view or pure function actually does cost gas only when a gas cost transaction is calling it so we can go ahead and call these as much as we want it costs nothing but if another function that does cost gas calls it it's going to cost something for example if our functions store here then went ahead and called retrieve like this since store costs gas you're telling this function hey also call this retrieve function which is more work for it to do and since it's more work it's going to cost more gas so for example if we delete this contract over here let's go ahead and compile this let's go ahead and deploy this with this retrieve in here so let's go ahead and look at these These are now zero we'll store five in here we'll select the drop down we can see how much gas we actually sent 50 000 gas let's go ahead and drop this now close this out let's remove the retrieve line compile we'll hit deploy simple storage these are both zero we'll add five hit store pull up the terminal hit the drop down look at gas it's still 50 000 but it's actually a little bit less than before although I'm pointing at gas we really should be looking at transaction cost because gas is really just actually how much we're sending whereas transaction cost is how much gas the transaction actually cost but in any case it's a little bit less without the retrieve function now I've kind of been glossing over this a little bit but this returns keyword specifies what this function is going to give us when we call it so when we have this returns keyword in our retrieve function here we're saying whenever we call this retrieve function we want to get returned or we want to be given this favorite number of Type U and 256. we want to return a u into 56 from this function now our contract as is is pretty good it does one thing pretty well it's it allows us to store our favorite number update that favorite number and then view that favorite number and in fact let's go ahead and make this an internal variable and we'll have the retrieve function be the way to get this we can have this public but for now we're going to set it up like this and I'll tell you why we're going to set it up like that in the future but what if we wanted to be able to store not just our favorite number but other people's favorite numbers as well well what we could do is we could create something called an array or a list of favorite numbers what we could do is we could say instead of just one unit 256 we could have a list of view and 256 called list of favorite numbers this bracket syntax here identifies that we have a list of U and 256 or a list of numbers or an array of numbers an array of numbers is going to look something like this it's going to have maybe the first element is going to be 0 maybe the second favorite number is going to be 78. the third favorite number is going to be 90. now arrays are very common in computer science and programming and an array in solidity is exactly the same as an array in any other programming language if you're unfamiliar with arrays arrays or lists are actually zero indexed so the zero here is actually at index 0. so we refer to this object here as the zero width object right this could be 77 and this would be the zeroth object the 78 is going to be the first element the 90 is going to be the second element and so on and so forth it's very common in computer science to actually start counting from the number zero and arrays start counting from the number zero we'll learn to play around with arrays more in just a minute so this list of favorite numbers is great but how do we know whose favorite number each section is this is our list of favorite numbers how do we know who zero is whose 78 is who 90 is ETC well maybe what we would do instead of just having a raw list like this let's go ahead and comment this line out maybe we could create a new type called a person in solidity you can actually create your own types using the struct keyword so we're going to say struct person and do little curly brackets like this inside of these curly brackets we can Define what this struct person custom type is comprised of and we're going to say for every person they're going to have a u and 256 favorite number and a string name now something important to note is oh whoops we have two favorite numbers here remember what we learned about scope since this favorite number is inside of these curly brackets these would Clash a little bit so what we're going to do instead is we're going to rename favorite number up here to my favorite number and we're going to copy paste that down here as well so we're we're renaming this state variable this storage variable to my favorite number and just keeping it down here that way we can have favorite number inside of this struct in any case we created this new type of type person which is a combination of each person has a favorite number and each person also has a name now similar to how we can have a unit 256 a Boolean a string and n256 Etc we now have a type of person and this is similar to each one of these oh and we're also going to have to update the retrieve down here with my favorite number instead of favorite number now since we have our own new type we could actually create a variable of type person the exact same way we created a variable of type my favorite number so we could say person visibility will be public my friend equals and we'll put person here and put some parentheses here because when you're working with custom types you have to Define both on the left side and on the right side what type it is and in here we would assign a favorite number and a name so we could say seven and Patch like that so now Pat is going to be a person with a favorite number of 7 and a name of Pat see the first parameter goes to the first item in the person struct and the second parameter goes to the second item I like being a little bit more explicit when working with structs and actually what you can do is you can put little brackets here instead and you could say exactly what value you're going to assign to what section so I can say favorite number is going to be 7 and name is going to be at and we hit command s or just go straight to compile to see if it worked correctly get that little green check mark Now by doing this we've created our own type person and we've created a variable named Pat with a favorite number of seven and a name of Pat now if we were to go ahead let's delete this old simple storage and let's deploy our new simple storage and we scroll down we now have a new blue button since this is a public variable called Pat and if we click the button if we call this variable we'll see favorite number of 7 and string name Pat you can also see this 0 and this one which shows the index of each one of these variables or parameters 0 is for favorite number one is for name if we added another one maybe Bool is cool full is cool would be at index two whenever we create a custom type like this solidity will automatically index them similar to the way that we index our list or our arrays favorite number zero name one whatever's next would be two Etc now this is great for one friend but what if you have a lot of friends which I know a lot of you do because you're taking this course which automatically means you're cool maybe what if you have your friend Mariah that you would like to add to our smart contract like this and her favorite number is 16 or maybe your friend John you'd have to copy paste the line add John in here his favorite number is going to be 12. so on and so forth it might get very tedious to have to write variables for all of these people for all these friends this obviously isn't a great way for us to create lists of people or lists of our friends so instead of this we can actually use this array syntax that we just learned and create an array of person or a list of persons so I'm going to comment all these out for now and a quick tip here if you're on a Mac and you highlight a couple if you're on a Mac and you hit command backslash or command question mark it'll automatically comment or uncomment those lines if you're on a Windows I believe it is control slash but you might be able to Google what the actual keyboard shortcut is this is a keyboard shortcut I use all the time so what we're going to do now is we're going to create a list or an array of persons so exact same as we did it up here we'll say our type first is going to be type person array so we're up type person array then we'll State our visibility which is going to be public then we'll get our variable name which is going to be list of people like this so we've created a person array with visibility public and the name list of people and we'll just leave it blank for now so it'll get defaulted to being an empty list which would look like this now if I were to go ahead and deploy this let's delete the last one let's compile deploy scroll down we select this we now see we have our retrieve blue button and we also have this blue button for list of people when you create arrays with a public keyword instead of being able to see the whole array with this list of people button you actually have to put in the index of the element you want to work with and you get to see that exact element it wants to take a u and 256 as an input parameter however obviously our array is blank so if we say what is the person at the zeroth index it'll say well nothing because you have a blank array well what about the first index well nothing what about the second one well nothing no matter what you put in the box right now it's going to return nothing we'll show you how to add to this array in just a second this kind of array is known as a dynamic array because the size of the array can actually grow and shrink in solidity a dynamic array is signified by what's inside of these little brackets here if we added a 3 in here this would be a static array we're saying this list of people can only have a maximum size of three so we can only put three persons in this array Dynamic array static array can have any size can only go up to three any size up to three any size up to four hopefully you get the picture we're going to work with a dynamic array because we're going to want to add a arbitrary number of people to this person array so let's create a function that will allow us to actually add people and update this array and let's delete this comment so below our retrieve function we'll create a function add person and this is going to take two variables as input it's going to take the name of the person that we're going to add it's going to take the favorite number of the person that we're going to add as well as the name so we'll say string memory name and I'll explain this memory keyword in a little bit and we'll do U into 256 underscore favorite number and let's do and let's do underscore name and we'll make this a public function and what we're going to do inside of this add person function is we're going to take this list of people object and call the push function on it arrays come built in with a function called push which allows us to add elements or add person to our list of people array so what we're going to do is we're going to say list of people.push and we'll add these little parentheses here and we're going to push a new person onto this array now what we could do now let's comment this out for now now what we could do is we could create a new person new person equals person name favorite number like we did above oops excuse me these are backwards person memory new person which we're going to ignore that for now and then just do list of people.push new person we could do this this is valid syntax and I'll explain this memory keyword in a little bit this is going to create a new person and we push the list or we could just add this person right into this push piece here so we could delete this line instead of creating a new person on its own line we could say list of people.push person then we'll add in here favorite number name since we're calling this person favorite number name inside of this push object solidity is smart enough to execute this line of code first create a new person and then execute this line to push our person into this list of people object so this function should allow us to push new people into our list of people all right so what we can do now is let's compile this let's deploy this let's delete the old one we'll hit deploy now we see if we call our list of people at zero we'll get nothing back because it starts off as a blank array but now we have this new add person function where we can you can kind of see very faintly it takes a string name and a u and 256 a favorite number so we can add a trick seven we'll hit add person which if you have your terminal you'll see we made a transaction and now if we hit list of people at zero we see we have indeed added a person to the zero with index Patrick has a favorite number of seven and his name is Patrick obviously if we hit one we'll get nothing back and this will just stay up but if we add another person maybe John 16 add person now at list of people index one we now see John 16. so zero is going to be Patrick seven one John 16 2 is nothing so nothing happens now we've talked about this a little bit already but if we go ahead for example and maybe delete this semicolon and we go to try to compile and we scroll down you'll see we get this error partial error expected semicolon but got bracket instead and it gives us this little red exclamation mark and the line that it's having an issue with all these red errors mean that your code isn't compiling and you can't actually deploy this to the blockchain because solidity doesn't know how to turn this human readable code into a machine readable code so we need to add this semicolon here recompile so we get no errors now interestingly though if we go to the top and let's say we delete this SPX license identifier and now we compile we scroll down we get a yellow box and it says warning instead of error so it's warning spdx license identifier not provided source file blah blah blah interestingly though if we compile this we actually let's delete our last simple storage we can deploy this so if something important to note is warnings are just that they're just warnings they won't prevent you from deploying or compiling your code errors will prevent you from deploying or compiling your code now even with that being said though it is good to try to remove all of the warnings because the warnings are generally there for a reason they're warning you that you might be doing something bad and sometimes if you have a bug in your code simply just listening to the warnings would have solved it so it's best to listen to the warnings here so to summarize if it's red it's broken if it's yellow you might want to check it out additionally when it comes to these errors and These Warnings this is where using our Ai and Google searching skills can really come in handy let's say for example I ran our code I get this error I read the error and I don't really understand what's going on here what we can do is we can maybe copy this error and use any of these search features that we talked about resources for this course we can use chat gbt or find GitHub discussions stack exchange ethereum and puranum and I'll explain what each one of these is good for later in the course but for example let's go and try out find find is an AI search engine for developers what it does is it first does a Google Search and then it reads all those links and based off the links it reads it tries to give you an answer so what we could do is we could say I am getting this compiler error in solidity how do I fix it we hit this little drop down put any code or context here we'll paste our error this is the error like this and we'll go ahead and hit search we get a pretty verbose response on what's going on with our code we could actually take this a step far there and we could copy our entire code base and we could paste it under here we say code I usually put three back texts before and after any code that I use and I'll teach you why in the future well let's go ahead and hit enter and research it actually is able to read our code and say one way to fix the error is to Simply add a semicolon at the end of the line where you push the new person to the dynamic array list of people and we could see if we do indeed get a way to just copy our ad person function and we can scroll down and just paste it on top with it being fixed and we could also say concise because it's being a little too verbose for us we'll hit enter again and it wasn't that concise but a lot of these AI tools like I said are still in beta but this was a good example of how using an AI tool like this can actually help you detect bugs like I said oftentimes they will still get things wrong which is why it's important for you to know about GitHub discussions stack exchange piranha Etc later in the course I'll explain more about how to ask good questions how to do good AI prompting how to format your questions and how to search and learn more one of the key pieces of being a really good software engineer or a good prompt engineer is less about actually knowing the information and more about knowing where to find the information so throughout this course I want you to practice using these resources because they're going to help you be a much stronger developer much stronger prompt engineer and just be better at everything that we're going to go over in this course if find or chat should be T gives you a poor answer be sure to use the GitHub discussions if you have a question specific to this course be sure to use the GitHub discussions or if you have a more general question about solidity about Foundry or anything like that you can use one of these resources again I'll go over this more later but great job you've done your first bit of prompt engineering congratulations you don't have to understand this section fully now one thing that we didn't really go over and we kind of glossed over was this memory keyword and you'll notice if we actually delete this keyword and you try to compile we'll get an error data location must be memory or call data for parameter in function but none was given now there are actually six places you can store data in solidity you have the stack memory storage call data code and logs we're not going to go over all of these areas right now but we are going to go over some of the big ones which are call data memory and storage and this is going to be a little bit Advanced here so if you don't understand this section the first time don't worry about it just keep pushing through it'll make more sense as you go later on in the course all data and memory both mean that this variable is only going to exist temporarily it's only going to exist for the duration of the function call any car anytime we call add person with a different name we can only access this name variable that one time that we call this function if I call add name Patrick seven and now I try to list of people at zero obviously we see Patrick and favorite number seven we can actually never access that Patrick variable ever again because it existed in memory it existed for a very short period of time just for that single call we could also have call data here and we'll go ahead remove this deploy the drop down and do the same thing we'll add Patrick and actually you don't even need the quotes Patrick will do 88 add person we'll see if it's in there sure is all data and memory both mean temporary variables inside of functions most variables automatically default to memory variables strings are a special type in solidity so you have to specify memory or call data and it has to do with the way arrays work in memory but we'll talk about that much later in the course now the question obviously then follows okay well if call data and memory are both temporary variables why have two what's the difference between these two well let's try something let's have this be a memory variable and in here we'll say name equals cat so we're going to reassign whatever people put in here to Cat Let's compile this looks like it compiles fine now let's do call data and try to compile ah we get an error type error type literal string cat is not implicitly convertible to expected type string call data the difference between memory and call data is that a memory variable can be changed it can be manipulated if we pass a memory variable to a function we can go ahead memory and I hit and I hit command s to compile this is valid solidity this is not if you pass a call data variable you cannot modify it call data is temporary variables that cannot be modified memory is temporary variables that can be modified and storage is permanent variables that can be modified my favorite number was actually implicitly converted to a storage variable since it's added in this state context outside of a function if you create a variable that's outside of any function inside of a contract it'll automatically be a storage variable and let's leave this line let's compile let's deploy again we'll delete this deploy we know it's a permanent variable because we can hit retrieve and we can always access what is in favorite number so if we store one two three we hit store we can hit retrieve and we can access one two three so this variable one two three exists outside of function calls now even though I said there are more places like stack code log return Etc we can only make these variables call data memory or storage and like I said we'll explain that later in the course so let's go ahead let's add this back to memory because that's normally what you'll see now the next question that logically follows is oh okay Patrick well why do we need to put memory here but we don't need to put memory over here in fact if we try to put memory there we got an error data location can only be specified for array struct or mapping types but memory was given like I was saying earlier arrays structs or mapping are considered special types in solidity and the way that memory management works under the hood makes it so that we have to put this memory keyword un256 is known as a primitive type and solidity is smart enough to know where to put this favorite number always under the hood like we were saying earlier a string is actually an array of bytes and so so as we just saw with the error we need to put the memory keyword for arrays so then next question is okay well what about the storage variable can I put that here no you can't put that here either since this is a function solidity is smart enough to at least know that ah okay this is a temporary variable that you're working with it's got to be memory or call data it's not going to be storage since this name is only going to exist for a short duration so you got to pick one of these other two so the summary of this section is that structs mappings and arrays need to be given this memory keyword string is an array of bytes so it needs this memory or call data keyword so this code is starting to shape up it has a lot of functionality here we can store variables we can add people but it has a bit of an issue if we have this contract and we want to say oh what was Kelly's favorite number let's say we have four people on the array let's have Pat seven John eight Mariah 10 and Chelsea 22 or 232. and we asked the question ah what was Chelsea's favorite number well the way we would do it is we'd have to actually Loop through this list of people to find Chelsea so we'd say okay what's it zero ah okay that's Pat that's not Chelsea what's that two Ah that's John what's at three Ah that's Mariah excuse me what's that three Ah that's Chelsea favorite number 232 okay perfect I found Chelsea but obviously if we had a thousand people in this array that would be a very tedious process and that would take a long time for us to find the person that we wanted so the question then is is there a better data structure than a list or an array to use that makes it much easier to access and find the information about the people that we want and the answer to this is using a mapping you can think of a mapping as a dictionary it's a set of keys with each key returning a special set of information about that key so it's similar to a dictionary if you look up the word the the word the will have a whole bunch of texts Associated only with the word the so let's create a mapping type and you'll see how it works in practice so we're going to create a mapping like this with this mapping keyword and we'll say the key is going to be a string and It'll point to a uint 256 so this is going to be our type obviously what comes after the type our visibility so let's just go ahead and do public for this as well and I like to be very explicit with my naming so I'm going to say name to number signifying that this map maps someone's name to their favorite number and now with this we have essentially a dictionary where every single name or every single string is going to map to one number so for example if we looked up Chelsea we'd automatically get returned the 232 that we're looking for instead of having to iterate through this list so let's add some capabilities to our ad person function here so that we can update our mapping so we have this list of people.push which adds someone to the array let's also update this so it will also add somebody to our mapping to do that we'll say name to favorite number and we put these little brackets in here to specify what the key is and we'll say underscore name and we'll assign that to underscore favorite number what this line is doing is now it's saying all right in our mapping up here in our name to favor number mapping anytime you look for the person's name you'll automatically get their favorite number back and now you have a much quicker way to access people's favorite numbers just by knowing their name so let's go ahead let's compile this let's deploy this let's delete our old one we'll deploy this now we have this new name to favorite number blue button and so let's go through the same problem so let's say we have Pat seven John 16. Mariah 32 Chelsea 232. now same thing list of people zero returns Pat list of people one John so on and so forth or we could just go down here and let's say let's look up Chelsea and we automatically get 232 we get Chelsea's favorite number back automatically same thing if we look up Pat we get seven if we look up John we get Mariah and if we look up cheesecake we get nothing back in a mapping the default value for all the keys is zero so if you look up a key or a word that we haven't added in the mapping yet it defaults to the default value of whatever that type is since ours is a string to you at 256 you would 256 default type is zero if we look for a key that we haven't added we get zero back so now that we've added all this functionality we're looking pretty good we really like the way that our contract is set up we have our my favorite number which is a internal variable but we have a way to read it with retrieve we have our new typing person we have a public list of people array we've got a public name to favorite number got a way to update the favorite number retrieve the favorite number and add people to both our list and our mapping now in the future you'll hear me say that you should never do this before you write any tests before you get it audited but for now this is just a dummy contract that we're going to deploy on a testnet so we don't really care but let's go ahead and learn how to actually deploy this to a real test net this is going to simulate what deploying to a real network with real money is going to look like are you ready you should be this is going to be incredibly exciting after you do this successfully you should 100 tweet about it on Twitter on LinkedIn on lens protocol on whatever social media you want it's important to celebrate your small wins surprisingly it'll help motivate you moving forward so first off let's make sure this actually compiles okay cool we've got a green check mark there's no warnings there's no errors fantastic now let's go back to the deploy Tab and we'll delete this down here and we'll scroll up and we're going to change the environment we're in this remix VM and we're actually going to move to injected provider metamask remember this remix VM is kind of this fake world that remix gives to us injected provider metamask means that we're going to literally inject our meta mask into this remix we're going to inject our meta mask into this website we're going to allow this website to interact with our metamask we'll first get prompted by metamask to pick the account we want to use I'm going to use account one and hit next and we're going to go ahead and hit connect similar to the way we connect it to the faucet if we scroll up to our metamask we now see oh it says your account is not connected that's because I'm currently on account two let's flip to account one and we do indeed see that account one is connected and now before where we saw kind of this fake account with fake ether we see our actual account with the actual amount of suppolia eat that we have make sure that again be sure to use whatever recommended testnet we have in the GitHub repo for us we're using sepolia don't worry about the rest of these for now so make sure you're on the correct test net to deploy to attest that you're going to need some sepulia eth so if you haven't been to the faucet be sure to head over to the faucet to get get some Supply eth remember you can find those in the GitHub or web3dev.education now in remix what we're going to do we're going to do the exact same process we use to deploy to the virtual remix environment we're going to do that to deploy to the test set environment so we're going to go ahead and hit the deploy button and metamask is actually going to go ahead and pop up this is similar to what we saw with the blockchain example with signing transactions we're actually going to sign and send a transaction on the test set it's similar again to us sending ether to ourselves the difference here is though that our data section has a ton of information here all this data is associated with sending this transaction but this one has all this contract information encoded in machine readable code or our compiled code in details we can see all the pavement information associated with this transaction we can see exactly how much gas it's going to cost to deploy this contract on chain but again we're on the supply test Network so this is fake money anyways to actually deploy this we're going to go ahead and hit the confirm button and now we're going to have sent our function if you have the terminal up you can see we have this call created and it says creation of simple storage pending with this view on etherscan button if you click the view on etherscan button you'll get brought to this etherscam page with this transaction going through on sepolia you'll see it's currently being indexed by etherscan but there's a good chance it already went through and back in remix it actually goes ahead and gives us this green check mark saying that we did indeed deploy this contract you might have to wait a few minutes for this to complete because again we're sending a transaction to a testnet blockchain and the blockchain needs to actually reduce the block with our transaction in it but if we wait a few minutes on etherscan we'll eventually see a success status with block confirmations on this block section here and exactly the same as what we saw with sending each to ourselves we see all this information about the transaction transaction hash status block time from two blah blah Etc but if we scroll down this input data field is much bigger than anything we've seen before because again this is all the data associated with creating this contract and of course we see more gas fee information because again deploying a smart contract to the chain is modifying the blockchain so we have to spend gas now if we come back to our remix and scroll down we're able to see our simple storage contract and we're able to copy the address that it's at so if we copy this address we go back to etherscan we can even paste this into the bar here and we can see this contract that we went ahead and deployed etherscan is smart enough to know that this transaction created a new contract remember this has to be on the sepolia etherscan not the mainnet etherscan because we sent this on the sepolia test net so now that we have this contract created we have all the exact same functions that we had in our virtual environment but these functions are actually on a s net with a contract that we actually deployed now we can do all the exact same things we were doing on our fake remix environment on this test environment for example we can call retrieve which doesn't send a transaction it just reads off the blockchain and we get zero same as what we got before if we look up a name like Pat in named a favorite number we get nothing back because we haven't updated anything if we add 0 in here for a list of people we get nothing back as well metamask didn't pop up here because these blue buttons are view functions View and pure functions like we said don't send transactions now let's go ahead and actually send a transaction let's update the blockchain let's update our contract by storing a new favorite number so let's do 7878 and we'll hit store and we'll press this orange button you'll see you'll get prompted with metamask actually popping up saying okay let's update the blockchain let's send this transaction and if we go ahead and hit confirm the exact same thing happens we'll get this transact to simple Storage storage transact to simplestorage.store pending view an etherscan this little check mark if we view it we can see the transaction indexing on etherscan and after you wait for a little bit the transaction will go through and now if we hit the retrieve button we can see we have now stored 7878 on chain if we copy the contract address again we paste it into sepolia etherscan we scroll down after a few minutes we'll actually see a second transaction come through we see two transactions associated with this contract the first transaction obviously is the contract creation transaction and the second transaction is us actually calling the store method etherscan is smart enough to know that this is the store method it's not always smart enough to know that but for this one it's smart enough to know and we see that we actually updated our contract and remember in the future please use these test Nets sparingly we're just starting out and we're just learning so it's okay for us to send these transactions here though but let's go ahead and let's keep going because name to favorite number of Pat still returns nothing list of people zero still returns nothing so let's go to add person we'll do Pat 16 we'll hit add person metamask pops up obviously because we're updating the state of our contract we'll hit confirm we see transact to simple storage that add person is pending it looks like it has succeeded so now if we do name to favorite number of Pat we see 16 get returned and if we do list of people at zero we see we get Pat whose favorite number is 16. and guess what at this point you've successfully deployed a smart contract to a real test net congratulations you should be incredibly excited for yourself be sure to give yourself a pat on the back maybe go for a walk maybe have an extra cup of coffee or an ice cream because additionally you've also interacted with that contract with these buttons and remix that allow us to send transactions to update the state of our contracts congratulations you're a solidity developer but we've got a lot more to go and like I said make sure to celebrate these little wins celebrating little wins will motivate you and excite you to continue to move forward so be sure to take the time to Pat yourself on the back congratulations if you've got this far there's a ton more for us to learn but just you getting here is a fantastic achievement in itself now here if we wanted to deploy to a different test net all we would have to do in our metamask is switch to a different test net like Linea gorilli since we don't have any Linea gorilli we actually can't deploy this to a test net but if we used a faucet to get more Linea Corelli eth that's how we would deploy it additionally we could do the same methodology for deploying to ethereum mainnet or any other mainnet that you want to work with throughout this course the difference here is obviously you just need to buy some ethereum to actually deploy this smart contract remix will automatically update to whatever Network you're working with for example right here it says Ah you're working on the main Network but if we were to switch to gorelli it would say ah you're working on gorelli but if we were to switch again it would say ah you're working on Linea in the future we'll learn to add different networks so you can learn how to deploy to any other evm compatible network that you want to now I've mentioned this a couple of times but whenever we compile this code it compiles it down to something called the evm or the ethereum virtual machine don't worry too much about exactly what this means but essentially the evm is a standard for how to compile and how to deploy smart contracts to blockchain any blockchain that is evm compatible you should be able to deploy solidity code to some examples of evm compatible blockchains and layer twos which again we're going to go over working with layer twos more in the future are going to be ethereum polygon arbitrum optimism ZK sync and more just note that it's important to double check the blockchain before you launch to it for example ZK sync is evm compatible but a couple of keywords don't actually work with ZK sync now let's do a quick recap of everything we learned in this lesson and then after we do this be absolutely be certain to take a break maybe go get some ice cream go get that extra coffee or whatever you like to do the first thing you want to do in any smart contract or solidity code that you write be sure to write the version that you want to work with and above the version be sure to add the spdx since identifier if you're not sure what version to use for now just default to MIT then you have to create your contract object and name your contract a contract is similar to a class in other programming languages anything inside of the curly brackets for the contract is part of that contract there are many different types in solidity like you and 256 string Boolean int Etc if we want to create our own type in solidity we can use what's called a struct you can create arrays or lists in solidity you can create mappings or dictionaries or hash tables in solidity where if you give it a key it'll spit out the variable associated with that specific key we can create functions in solidity that modify the state of the blockchain we can also create functions in solidity that don't modify the state of the blockchain view and peer functions don't modify the state of the blockchain we can also specify different data locations in our parameters of our functions but we can only do that for special types like strings structs and arrays call data and memory mean that that variable is only temporary and will only exist for the duration of the function call Storage variables are permanent and stay in the contract forever function parameters can't be storage variables since they're only going to exist for the duration of the function call whenever we hit compile in our smart contracts it actually compiles our solidity code down to evm compatible bytecode or machine readable code we'll learn more about those specifications later and last but not least congratulations on your first contract here all right let's get started now with our lesson three remember everything is in the GitHub repository or the web3dev.education we scroll down once again we can scroll to lesson three and again a lot of this is undone but it'll be done for the actual video scroll down to lesson three and we have lesson three remix storage Factory all the code that we're going to be working with is in this remix storage Factory f23 GitHub repository all of the GitHub repos associated with this course end with f23 which stands for Foundry 2023. I'm going to first do a brief walkthrough of what we're going to be coding for this lesson so for now just sit back and relax and enjoy for this lesson we're going to be working with three new contracts our original simplestorage.sol which we're going to do a slight modification to a new five storage dot sole or add5 storage.soul and a storage factory.sol our storage factory.soul is actually going to be responsible for deploying new simple storage contracts yes other contracts can deploy contracts not only is this going to be able to deploy other contracts but it's going to be able to interact with other tricks as well what we could do is we could deploy this to a remix VM hit deploy we'll compile all of our code go to a remix VM scroll down to select the contract we're going to select storage Factory not simple storage deploy this see that contract that we just deployed down at the bottom and you'll see our top function is this function called create simple storage contract where if we pull up our terminal and we click create simple storage contract you'll see we get a new transaction at the bottom and this transaction is the transaction that we deployed a simple storage contract from our storage Factory contract now we can actually go ahead and interact with our simple storage contract remember in simple storage we have a function called store which takes a favor number we can actually call this store function on our simple storage contract from our storage Factory contract using this fstore function so we'll add the index of our civil storage contract which since we only deployed one so far it'll be at into zero and we'll say our new favorite number is one two three and we'll hit fstore and we'll click SF store at zero one two three SF store stands for storage Factory Store so we're going to store the number one two three on index zero and again don't worry about this making too much sense yet we're going to explain this all in a minute now if we hit sfget of zero we'll go ahead and get back one two three we're saying let's get the value of the simple storage contract stored at index zero and we do indeed get one two three additionally we have this list of simple storage contracts array or list and it's only size one right now but if we type in zero here we get back the address of that original simple storage contract that we deployed additionally in this lesson we're going to learn about a ton of incredibly important solidity features such as Imports and inheritance without further Ado let's get froggy and one more time of course remember all the code is available in The Foundry full course f23 of the chain Excel org or on the web3dev.education site once it's up so here we are back in remix with our simplestorage.soul if you skipped over the last section and want to get that contract just come to the full repository go down to lesson two go over to the code in the GitHub repo associated with this course the remix simple storage f23 and just copy and paste everything into remix yourself to make sure you've done it correctly be sure to hit compile we have our simple storage contract that we created in our last lesson which is great it allows us to store our favorite number and it allows us to store a list of people who have different favorite numbers also on mapping and some other different functionality with interacting with people's favorite number but we want to go even further with this we want another contract to actually deploy this simple storage contract for us and interact with it contracts interacting with each other seamlessly and permissionlessly is a feature of smart contracts and blockchain development that's absolutely yes essential and crucial and one of the reasons why blockchain development is so powerful the ability for contracts to interact with each other seamlessly is something known as composability smart contracts are composable because they can easily interact with each other this becomes even more important when we get to topics such as defy where we can have incredibly complicated Financial products and instruments interact with each other seamlessly because they're all using the same smart contract interface so we're going to keep our simplestorage.soul the exact same way it was from the last lesson and we'll update it in a little bit but let's go ahead and create a new contract called storagefactory.soul so let's go ahead and get this contract set up now we're going to be doing this a lot and when we work with AI pair programmer now we're going to be doing this a lot and when we work with AI pair programming this is going to be a lot easier for us to do but for now repetition is the mother skill so let's keep going first thing we need to do is what if you want to pause the video and add the first two things you should put at the top of every slitty smart contract right now go ahead but for those of you who didn't pause let's go ahead and do spdx license identifier MIT and then let's do pragma solidity 0.8.18 or 19 or whatever you want to do you know what let's do 19. what do we do in simple storage we did 18 let's do 18. and then we'll do contracts so this will be the third thing actually contract storage Factory like this and I hit command s but you can also go and compile like so and I'm also just going to add the carrot here meaning we're going to use 0.8.18 but any version greater than that also works as well awesome now this storage Factory contract is going to be deploying a simple storage contract so let's create a function that can actually deploy or create a simple storage contract so we'll say function create simple storage contract and we'll make this a public function and we're going to have this create simple storage contract function deploy a contract and then save it to a state variable or a storage variable but the question is okay well how does the storage Factory know what the simple storage contract even looks like how does this contract know about this contract how does this contract know that this contract even exists the first way that we could do this is we can actually go to our simplestorage.soul contract and start highlighting from the contract word and scroll all the way down to the end of the contract copy it command C or right click copy go back over to storage Factory and Below pragma solidity but above contract storage Factory paste it in here if we go ahead and command s or compile this you'll see that this actually goes ahead and compiles successfully so this is to show you that yes right now in our storage factory.soul we have contract simple storage which ends here and we also have contract storage Factory down here you're allowed to have multiple contracts in the same file now this isn't a best practice because we really don't want to be having multiple contracts in the same file when we can separate them out into their own files as your projects get bigger and bigger if you just add all of your contracts into the same file it can get really really confusing really difficult to jump around the code and find the places where you want to add stuff so normally it's best practice to keep them separated like we did above but we'll learn a little bit more about how to keep them separate in just a minute if you go down to the deploy Tab and you say on the remix VM and scroll down you actually have this section to choose your contract we can choose either one of these contracts right now and if on the right side you have storage factor.soul in this contract section you can actually choose either one simple storage or storage Factory and you can see they're both in storage factory.soul if on the right hand side we go to simple storage and we go back to this contract section we can only choose simple storage because the simple storage contract only has one contract in it the storage Factory has both simple storage and storage Factory so that can get a little confusing as well if you have multiple contracts in the same file but let's stick with this methodology for now in our storage Factory and let's even close out simplestorage.sol at the top just so we don't get confused in our storage factory.sol let's scroll back down to storage Factory because now that we have our simple storage in this file we can actually deploy the simple storage contract so this function is going to deploy a simple storage contract but we're going to save it to a storage or state variable and we're going to do it the exact same way we've been saving any variable first thing remember like remember how we did U and 256 public favorite number this was in the format type visibility name we're going to do the exact same thing the type of a simple storage contract is going to be simple storage and the reason that solidity is going to be able to identify this keyword is because it's the same name as contract in the same sense that our struct keyword allows us to create a person type the contract keyword allows you to create a new type of well a type of simple storage contract so simple storage for now we'll just give it a visibility of public and we'll give it a variable name simple storage now this is going to be a syntax you're going to see a lot and it might be a little bit confusing the first couple times you read it the difference between these two is very subtle the difference between simple storage on the left and simple storage on the right is very subtle it's simply that the the S is lowercased over here and the S is capitalized over here solidity is case sensitive so these are actually different word simple storage here is referring to the contract simple storage here is referring to the variable you'll often see people use the syntax when working with contracts where they name the variable the exact same as the contract itself if this is confusing to you you can do my simple storage instead of simple storage with lowercase so either one of these works it's good to get used to this as such but if that's confusing you can do my simple storage now in our create simple storage contract function we're going to say simple storage equals new simple storage like this this new keyword is how solidity knows to deploy a contract so adjust this code alone if we go to the compile tab we compile this this does indeed compile we can go to deploy we need to make sure we're on the storage factory.soul on the right hand side we'll scroll down to the contract we can actually deploy our storage Factory like so hitting the deploy button and remember you can see the transaction in the terminal here and we can scroll down to the contract right now there's two buttons we have our blue view function simple storage because again the public keyword automatically gives the variable name a getter function or a view function and of course we have our create simple storage contract orange button because it is actually a transaction right now simple storage returns nothing the zero the default value for an address which is the zero address and if we call create simple storage contract we get see a green check mark meaning that transaction went through now if we call the simple storage blue view function we see we indeed get an address here we have deployed our simple storage contract from another contract oh my goodness so congratulations now you know how a contract can deploy another contract awesome job but the thing is like I was saying if we just add all of our contracts into the same file and we have these massive contracts all interweave between each other and get very cluttered and very confusing so is there a better way we can actually arrange and organize our code other than this and this is actually even a little bit redundant since we already have our simplestorage.soul if I change something in here then I would also have to go and change it in here and that's too much work for me as an engineer I will work incredibly hard to be incredibly lazy so instead of doing this we can use what's called an import if we go ahead and delete our contract simple storage in our storage Factory here so that now we just have the storage Factory contract we can go ahead and use the import keyword to import simplestorage.soul so we can do import dot slash simplestorish.sol and a little semicolon here this import dot slash simplestorage.soul is the exact same as if we had this giant simple storage in here so this import simplestorage.soul is a shorthand version of copy pasting that simple storage Hudson into this contract and now we're able to have simple storage.soul in its own file and storage Factory just import it from simple storage making our lives much easier it takes our path package or GitHub which we'll explain in a little bit and imp and copy paste whatever in that file at the top of our file literally solidity for us is copy pasting everything in here and sticking it up here so we can go ahead run this again let's compile leader old contract run remix VM let's be sure we're on storage Factory we'll go to storage Factory we'll deploy it scroll down click here simple storage starts up as nothing create simple storage oh my God this look we deployed a contract huzzah great work so now that we're starting to work with different files there's a number of things we want to consider the first one is actually the solidity version so right now we're using 0.8.8 with no carrot and in storage Factor we're using 0.8.8 with a carrot if I were to for example move the solidity version of this down to 0.8.16 and go to compile this with a different version remix is actually gonna remix is actually gonna automatically bump this up to 0.8.19 or actually remix is actually going to automatically bump this up to 0.8.18 if I'm on the simple storage because 0.8.18 is the version that works for simple storage and it still is compatible with storage Factory however if I were to take storage Factory and move it to 0.7.6 and try to compile it's going to try to compile this with 0.7.6 and our simple storage with 0.7.6 and it's not going to be able to do it for both and so we're going to get a compilation error so when working with multiple files it's important to keep the version of solidity in mind because you want to make sure that all of your contracts can actually compile together so this is great and all but right from the get-go I want to teach you the more advanced import that you should always use so this is good but we actually never want to default to this we want to default to something called named Imports let's say our simplestorage.soul contract had a ton of other contracts like contract simple storage 2 simple storage three simple storage four and these were all massive massive contracts as we have this right now import simplestorage.soul would import everything from here simple storage simple storage 2 simple storage 3 simple storage four and if these files were incredibly big when we deploy our storage Factory it would have to calculate all this extra computation making the deployment of our storage Factory more expensive if that's confusing to you don't worry about it right now additionally in the future these can import from weird places that aren't compatible with storage Factory again that's not going to make sense quite yet and that's okay but in any case there's a way for us to not import this whole file but only a very specific contract or a specific section of our simplestorage.soul so instead what we can do is in our import statement we can specify the exact contract that we want to import from this file so in our simplestorage.sol let's say we do have these other contracts in here we could say we only want to import simple storage not simple storage two not not simple storage 3 not simple storage 4 by saying import these little brackets here simple storage from simplestorage.soul and this goes ahead and compiles correctly we could also import multiple contracts from our simple storage for example we could do import simple storage simple storage 2 from simplestorage.soul this way we only import the exact specific contracts that we want from these other files and I promise you in the future always referring to named Imports instead of this type of imports will save you a lot of headache in the future so always default to this never default to this just by learning this you are already better than 80 of the current salinity developers so congratulations but all right fantastic so we've learned about Imports we're able to import our simple storage from simplestorage.soul We're importing it in the more advanced way congratulations now already here you might actually start running into some questions right and we're going to get more and more advanced with this course and you're going to have questions which is a good thing if you don't understand stuff that means you're thinking critically and you're approaching the subject matter the right way so this is where we're going to jump into again doing a little bit of an AI chat example so for example on this line let's say you're a little bit confused and you go what's the difference between simple storage here in simple storage here I don't understand so let's learn how to work with chat gbt or any AI buddy to ask them to help clarify so we're going to go ahead I'm going to hit command a or you can just highlight everything command C to copy or right click copy we'll go over to chat2bt and in here we're going to ask the question hi I'm having a hard time and let's zoom in understanding the difference between the simple storage is on this line and here's where we want to be very specific when we're talking with AIS so I'm going to hit shift enter so that it doesn't actually send the question to chat toptvt but I'm going to put three back ticks shift enter again and actually I said we're going to copy the whole thing but let's just copy this this single line and paste it in here shift enter again three back ticks again adding this delimiter tells chat to be T that this is a block of code and it makes it easier for chat ubt to be able to understand that this is a block of code then I'll hit shift enter twice and if you have a lot of code you're not going to be able to copy your whole contract because a lot of these AIS can only understand so much in a question but this is small enough that we can actually just go ahead and copy the whole thing bring it back over to chat you T and say here is my full code and then we'll do again shift enter three back ticks shift enter paste shift enter read back ticks so now we have a little AI prompt here that we can ask in chat should be team and and I don't have this in here yet but in the GitHub repo associated with this lesson I will add this AI prompt in here so let's go to the bottom and I was saying you need to use shift enter but I guess you could just use enter that's fine let's go ahead and click the send button and I'll send it the question so now it'll start outputting here and let's see what it says and this is where we can already start to see the power of these AI buddies as learning buddies we see in the given code simple storage is a variable of type simple storage which is a contract defined in simplestorage.s Soul tells us what the line is doing it clarifies the differences a little bit more and a lot of this beginner basic stuff AIS are really good at once we get more and more advanced AIS are going to start breaking apart but at least for the beginning of this course AIS are going to be incredibly helpful and Incredibly good at explaining a lot of these what we could do if we wanted to is we could also go ahead and copy this prompt we can go over to something like bard paste it in here and ask bar the same thing and here's already a good example of where an AI can get things wrong if we scroll down it's telling me you can use simple storage variable to interact with the new simple storage contract for example you could call the set function to set the value on stored data variable or you could call the get function to get the value of the stored date variable there is no stored data variable so I don't know where it's getting that from so just remember keep in mind that AIS can get things wrong and then when they do there are other forums that to use as well like I said we're going to be learning about them as we go on like stack exchange ethereum piranha or like I said of course the discussions Forum of this course so if Bard or chbt or whatever AI buddy you're working with gives you something confusing be sure to go to the GitHub discussions or ask in one of these forms now as you can see though right now every single time we call create simple storage contract we're going to deploy a new simple storage contract but we're going to override it in this simple storage right so if we go ahead and deploy this right now scroll down here simple storage at the zero address create okay now it's at a new address create again okay now it's at a new address we're not keeping track of all the different addresses that this simple storage contract is being deployed to so let's actually create a running list of all the different simple storage contracts that we're deploying so instead of having this variable be just a single simple storage contract let's have it be an array or list of simple storage contracts and we'll change the name to list of simple storage contracts so now when we deploy it instead of saving it like this we're going to do what we did before in our last section we'll say simple storage new simple storage contract equals new simple storage and then we'll push it onto our Dynamic array so we'll say list of simple storage contracts push new simple storage contract so let's go ahead and compile this okay looks good let's go ahead and deploy this we'll delete our old one we're on the remix VM great storage Factory and look at this you can even see make sure we're on storage Factory okay great we'll go ahead and deploy that awesome we get list of simple storage contracts which now has this un256 input which allows us to choose the index of the variable we'll go ahead and create simple storage now we go check the zeroidth index we have an address if we check the first index nothing happens if we call create again which sorry if I have the terminal up I'll call create again again now there is one at the first index and since I called it twice there's also one on the second there's nothing at the third I'll hit create again there's no one at the fourth oh at the third excuse me awesome so now we actually have a running list of all of our simple storage contracts now let's learn how to actually interact with other contracts from a contract for now we can think of our storage Factory as a sort of manager for all these other contracts so let's learn how our storage Factory contract can actually call the store function of the simple storage that it deploys so let's create a function called SF store which is going to stand for storage Factory Store and it's going to take two variables a u into 256 underscore simple storage index and a u and 256 underscore new simple storage number we'll make this public like this now in order to interact with a contract you're always going to need two things and we're going to refer to this a lot you need an address and you're going to need the ABI now this is technically a lie you really just need the function selector but we're going to learn that way way later in the course for now just think okay I always need the address and I always need the ABI the ABI stands for application binary interface the API will tell our code exactly how it can interact with another contract we'll go deeper into the API later on in this course but for now if you go to the compile tab you hit compile and you scroll down there's this little button at the bottom that says copy ABI to clipboard or you can also go to compilation details you can see a ton of information about the complication details such as the byte code with the op codes some metadata the name but also the API which tells us the ways we can interact with this contract if we hit the drop down for the zero we see there's an input create simple storage contract which is one of our functions and you see state mutability which we'll talk about later but if we had another drop down we see list of simple storage contracts and the other drop down we'll see SF store these as you know are the buttons that we can press when we deploy this contract right so if I redeploy this we see those exact three buttons these are the three buttons that were inside of that ABI this is how remix knows to put three buttons here because it looks at the API and sees that there's three buttons so in our code here our compiler knows what the API is so in our code here the compiler automatically knows what the API is because the compiler is the one that generates the API and we know where the address is because we have a list of all of our addresses that we're keeping track of up here so the reason we have the ABI is because we're importing our simple storage contract and actually let's delete this simple storage too we don't really need the simple storage too so when we compile simple storage we automatically get the ABI for solidity in the future we'll learn other ways to get the API so down here let's get a simple storage contract to interact with from our list and to do that we'll say simple storage my simple storage equals list of simple storage contracts at index simple storage index like this since this is an array of simple storage contracts we can just automatically get the contract itself like this however let's say that instead of this being an array of simple storage contracts this was an array an array of addresses a list of simple storage addresses like this you don't have to code along with me for this section just go ahead and follow along and watch if we had a list of addresses and this would be to be a little bit different but we had a list of addresses instead we could say simple storage my simple storage equals list of simple storage addresses at the index and then do something called type casting and we'd wrap this in parentheses like so let me zoom out a little bit so this is something we'll learn about a little bit later so basically what we're doing is this list of simple storage addresses simple storage Index this line returns an address and we're wrapping that address in simple storage like so if this is a little confusing for you now don't worry too much about it we will learn about it more later now that we have our simple storage contract we can actually call the store function directly on this contract so now we can say my simplestorage DOT store and we'll add the new simple storage number and this is great if we were to deploy this contract right now though and call this SF store function though we wouldn't be able to read the new variable that we just updated our simple storage contract with so let's create a function that allows us to read from our simple storage contracts as well so we'll create a function called sfget which will take a un256 underscore simple storage index is an input parameter we'll make this a public view function that will return a uint256 uint 256 and we'll say simple storage my simple storage equals and we'll use this exact same syntax that we used above to get the simple storage index equals list of simple storage contracts at the simple storage index and now we're going to do return my simple storage and again if you see these Auto completes that come up you can just hit tab but dot retrieve so perfect now let's go ahead and compile we'll go ahead and delete the old deploy we'll make sure we're on storage factor.soul we'll hit deploy and we see storage Factory down here now let's go ahead run through that exact same exercise so we'll pull up the terminal just to see our transactions go through we'll hit create simple storage let's see that it's actually there at the zeroth index okay cool we see an address there so now let's store a new variable at index 0 so at this address so we'll say at index 0 we'll store the number one two three and actually before I hit this button if we go down here we hit zero we get nothing back right but now if I hit s of store with index 0 favorite number one two three looks like the transaction did go through now if I hit sfget we go ahead and get one two three so our storage Factory contract was able to create its own simple storage contract store a variable in that contract from the storage Factory and we were able to read back the number one two three all from within our storage Factory contract feel free to pause right now and play around with adding different values creating different simple storage contracts so that you really understand what's going on you can also feel free to hit the little drop downs and read more information about these transactions just as a recap in our storage Factory contract we have a function called create simple storage contract which creates new simple storage contracts from the storage Factory contract the reason it's able to do this is because we're importing from our simplestorage.soul file using something called named Imports we're only importing simple storage we're not importing anything in these other contracts then we use SF store to store a new number on one of those simple storage contracts using the index in our array it can do this because we have the address and the API the list of simple storage contracts automatically compact with the address and the API and then finally we can read back those simple storage values that we stored now we could make this sfget function even more condensed since this list of of simple storage contracts simple storage index returns an object of type simple storage we can actually delete this whole line copy this paste it here and delete this line and this will work exactly the same as what we had before go ahead and save or compile you'll go ahead and get that green check mark there this dot retrieve is saying we're going to call the retrieve function on whatever this is and this whatever this is is of type simple storage contract you can actually do the same thing up here by deleting this part copying this line except for the semicolon and pasting it over the my simple storage and hitting save or compile awesome great job so far awesome now let's say you really like this simple storage contract you love all the functionality except for one thing you wish that the store function didn't just store the favorite number you wished it added five so for some reason you want a contract that does everything this contract does but just adds five whenever you call store for some reason you want everyone's favorite number to be five larger than what they think it is well one thing we could do is we could just copy paste this into a new file but again that's kind of too much work for me I'm a lazy engineer but let's go ahead and see how we can approach this problem so let's create a new file and we'll call it add five storage that's all and same thing since this is a new contract we're going to follow the exact same tips we're gonna do spdx license identifier MIT we're gonna do pragma solidity 0.8.18 let's even do the little carrot here and we'll do contract add five storage like so click compile great looking good oh I'm getting a warning spdx license it's about license wrong so let's spell that right okay cool looks good so like I said the first thing that we could do is we could copy paste everything in here and then just change the pieces that we don't like in our ad5 storage this is a little bit redundant a little bit too much work and we are Engineers we want to work as hard as possible to be as lazy as possible so how can we do that well this is where we can do something called inheritance we can have our add 5 storage contract be something called a child contract of our simple storage contract and we can have our ad5 storage inherit all of the functionality all of the functionality of our simple storage contract so first of course in order for our ad5 storage to know about our simple storage contract we're going to go ahead and have to import it so we're going to do import and we're going to do once again the named Imports because we're Advanced solidity Engineers so we're going to say import simple storage just the simple storage contract from dot slash simplestorage.soul now if this dot slash is confusing to you don't worry we'll learn about directory structures later on in the course then we'll say our contract add five storage is simple storage now our ad5 storage is going to do what's called inherit everything from civil storage and our ad5 storage is going to have all the same functionality as simple storage we can actually see this directly if we go to compile let's go ahead and delete our previously deployed contracts we're on the remix VM let's make sure we're we've selected add five storage ad5storage.soul let's go ahead and deploy it and if we scroll down we can actually see oh my goodness it's got all the same buttons as simple storage even though the contract itself doesn't have anything to find that's because we inherited all the buttons We inherited all the functionality of simple storage into ad5 storage if you want a contract to inherit the functionality of another contract you just import it in and then say your contract is that other contract now we can keep going though and add our own custom functionality into ad5 storage that's not in simple storage so for example we could say function say hello it's going to be a public and it returns a string memory and again you need the memory keyword because strings are special in solidity we just say return hello like so this will be a public pure it's not a view because we're not reading from storage and again if that assertion is a little confusing to you don't worry too much about it now but if we go to deploy it let's delete our old one we'll deploy this one we see we have all the functionality of simple storage plus this say hello function great well let's delete that for now let's say instead of wanting to add additional customization you actually love every function in here except for one remember the reason we wanted this add5 storage.soul is because we actually want to change the store function to have it add an additional five to people's favorite numbers maybe you're mischievous and you want people's favorite numbers to be five greater than they are well to add this add 5 customization to that store function we could do something called overrides to do overrides there are two keywords that we need to be aware of those are virtual and override if I were to try to create a store function for our ad5 storage right now what do you think will happen let's try it out so let's say function store un256 underscore new number public if we try to compile this right now we'll actually get an error even if there's nothing in this store function we roll over we say from solidity type error overriding function is missing override specifier and remember if you get lost or confused an error like this is something perfect for you to ask chat topt or maybe even find we could say I am trying to compile my solidity code but I'm getting this error we can copy this whole error here paste it in here and then in additional context we'll just add the code like this we'll hit search see what it gives us we'll say and it looks like find was able to find the answer the error message indicates the functions store in the ad5 storage contract is missing the override specifier which is required because it overrides a virtual function from the simple storage contract thanks I'll explain what find is giving us in just a minute it's right we need to tell solidity that it needs to override the store function in simple storage we want to be very explicit and say hey do this store function and not what's in civil storage.sol so let's go ahead and add the keyword override now though if we just had that keyword we go ahead and try to compile we still get an error trying to override a non-virtual function did you forget to add virtual in order for a function to be override a bowl you need to add this virtual keyword in the base class or the parent class so in simple storage we need to add virtual to store this virtual keyword means that this function is overrideable any function that doesn't have this keyword you can't override now our store function is override a bowl and we've specified that we are indeed going to override the store function now if we go ahead and compile we'll see everything compiles successfully all right great so now let's just add the functionality to store remember since ad5 storage inherits everything from simple storage this means that we even have access to my favorite number so what we can do is we can say my favorite number equals underscore new number plus five we'll compile this and now let's try it out we're on remix VM we want to make sure we're with ad5 storage we'll delete the other ones we'll deploy scroll down hit the drop down retrieve currently return zero now if we store two we'll pull up the terminal to make sure we're actually sending transactions we'll hit store and now if we hit retrieve we see we indeed get seven back because two plus five is seven we add five we hit store retrieve now returns ten So This Is How We Do inheritance and override functions and that's it for this section you've learned a ton of incredibly powerful features in solidity so let's do a quick recap of what we learned this section we learned that with the new keyword we can actually deploy contracts from other contracts we learned that we can actually import other contracts which is essentially the same as copy pasting the code into this file we also learned this thing called named Imports which is going to make you look even better than most of the solidity devs out there we learned that we can interact with other contracts so long as we have the address and the API the simple storage type automatically comes with the address and the API so we can just access it like this we didn't learn too much about the API but we'll learn more about it later we learned that if we want to make a child contract and inherit the functionality of some other contract we can just import that contract and then use the is keyword in the contract declaration to override a function we need the override keyword and we need the base class or the parent class to have the virtual keyword on the function you want to override and that is the end of this lesson so be sure to give yourself a huge pat on the back take a break breaks are good for your brain go for a walk grab a coffee get some ice cream go tell your friends go post on Twitter you're getting more and more advanced with solidity very quickly so be sure to celebrate the little wins to keep being excited and keep that Curiosity congratulations you've completed this lesson all right everybody welcome back we are now headed into Lesson Four this is going to be our remix fund me and once again you can find all the code associated with this lesson in the GitHub repository associated with this course and also web3dev.education and let's do a quick walkthrough of these contracts before we actually start coding anything to see what we're going to be doing we're going to be creating one contract fundme.soul we're also going to have another file called priceconverter.soul and we'll talk about that in a little bit the fund me contract is going to be our main contract this is going to be an example of a crowdsourcing application or a way to raise money you can think of it as a web 3 decentralized Kickstarter we'll allow users to send ethereum polygon Avalanche Etc or really any native blockchain cryptocurrency into this contract and allow the owner of the contract to actually withdraw all the funds for them to go spend on their new project and we are going to actually deploy this contract to a test net and remember use the test net transaction sparingly but if we deploy this to a test name we scroll down we actually see that we have a couple of buttons and a new color button we'll actually get a new red button for our fun function a red button indicates that a function is payable and we can send native ethereum or polygon or Avalanche or whatever the native cryptocurrency of the blockchain we're working with is We additionally will indicate a minimum USD amount to send to the contract so funders have to spend at least five dollars worth of ethereum in order to call this fund contract so if we go up to the value section we can actually send some value with this transaction and again don't worry about this making sense yet but if I want to send 0.01 ether I'll grab that amount in way paste it into the value section here I'll scroll down I'll hit the fun button minims will pop up I'll confirm we can see at the top the current bounds of the contract is zero and we'll wait a little bit for the transaction to finish going through and after the transaction finishes going through we can see in etherscan we have a balance of 0.01 eth and we can also see that after remix after a slight delay then we can allow the owner of the contract to withdraw those funds right now the owner of the contract is also us and after this transaction goes through we'll see that bounce removed from the contract and it'll go back into our wallet and as you just saw there if we held our metamask up for long enough eventually it would pop back into our metamask are you excited we should be because after you complete this section you'll actually know most of the fundamentals of working with solidity we're going to be going over a lot of advanced features in this section and I'll let you know the specific parts that you don't need to fully understand quite yet there's going to be a couple parts where if it doesn't totally make sense just keep going with the course and as we get later into the course you'll figure out why they make sense but it might be a good idea to write down the questions that you have to ask either an AI on the GitHub discussions or web3education.dev make sure of course to use the discussions Tab In The Foundry full course f23 to ask questions and interact with other developers who are taking the same course or go to web3dev.education to learn more alright let's get froggy so the first thing that we want to do is let's once again delete everything in our remix so we can start from scratch so I have the contracts that we're actually going to be building in here you might have the simple storage the ad5 extra the storage Factory Etc let's go ahead right click and just delete everything we're going to start completely from blank here so let's go ahead and delete everything in here all right great so let's go ahead and start creating our contract we're going to call it fun to me that's all one thing that's really good when you actually start building any code at all is to First write down what you want it to do so what do we want ours to do we want to get funds from users into this contract withdraw funds to the owner of the contract or whoever has created this fund me contract and then we also want to set a minimum funding value in USD we don't want people to be able to donate just a penny so let's go ahead and set this up spdx license identifier identifier MIT do pragma solidity carrots 0.8.18 contract fund me let's go ahead and delete these comments so before we embark on writing all of our functionality out let's just write down the functions that we want to build so we're probably going to want a function fund which is going to be the function they call to send money to our contract we're going to want a function withdraw which is going to be the function that the owner of the contract is going to use to withdraw the money that the funders send us and those are going to be the two main functions that our contract is going to need we're going to be implementing more functions than just this but these are going to be the main functions to interact with our protocol or interact with our fund me contract let's comment out withdraw for now and just start focusing on fund we want anyone to be able to call this fund function so we're going to make this public and we want this function to do what well we wanted to allow users to send money and we want to have a minimum dollar amount that they have to send so the first question we need to answer is how do we send eth to this contract how do we have it when a user calls the fund function eth automatically gets sent into our contract whenever we send a transaction on the blockchain there's actually always a value field that gets populated and most of the time it gets sent with zero even before when we call the send function between our accounts when we added an amount in our metamask this amount of value populated the value field of our transaction this value field is the amount of native blockchain cryptocurrency that gets sent with every transaction the first thing that we need to do to allow a function in solidity to accept this native blockchain currency in the first place is to make the function payable payable keyword that makes the function look red in the remix UI just like how wallets can hold funds contracts can actually hold funds as well so whenever you deploy a contract similar to a wallet address it actually acts almost the same as wallet address you can send money to it you can interact with it Etc and like we did in the demo you'll see this contract actually gain a balance just like a wallet you can access this value amount of a transaction using one of the globals in solidity called message.value slitty has a number of these globally available keywords and functions and you can find these in the solid documentation one of them is message.value which is the number of way sent with the message if we wanted users to be required to spend at least one whole ether with this fund function we could use something called required to do so in order to do that we would add this line require message.value is greater than 1 e 18. and there's a couple of things to unpack here one E18 is equal to one ether which is equal to one one two three four five six seven eight nine ten one two three four five six seven eight or put another way it's equal to one times ten raised to the 18th and solidity a double abstract or double multiply sign is how you do a power or an exponent this value here is the value in way of one ethereum in your smart contracts and at the lowest level this is how they process numbers in this giant wave format so if we wanted people to be forced to send at least one whole eth with this fun function we would just say require message.value is greater than one E18 you use something like eatconverter.com to C to convert one ether between ether way and gray is actually another value in between ether and way and we saw way actually when we saw gas costs normally gas costs are shown in forms of gray this required keyword is a checker it's basically saying hey is message.value greater than 18 if not then revert this transaction and if we want we could add a little revert message we could say like didn't send enough eth we can actually deploy this we can actually compile and deploy this on a remix VM boy scroll down and if we hit fund and if we pull up our terminal we hit fund we actually see we get this little X here meaning our transaction didn't go through and if we hit the drop down well again same thing same thing we know that this error is because we have this require statement in here and our transaction is reverting or not going through so we know that with this transaction we need to send at least one eth or or one E18 way worth of eth in the value section of our transaction so if we scroll up we can actually just change the unit to Ether put one in here scroll down now if we hit fund hope it doesn't go through because we have strictly greater than so excuse me Let's do let's do two now I'll scroll down we'll hit fund we see we get a green check mark and we see the fund me balance actually has improved to two if we update the value to 2 again and we scroll down we hit fund again we see our transaction went through and we have four if we try to do less like let's change this to way and we'll do you know a thousand way scroll down we hit fund up it fails because 100 way is less than one E18 way right because 1 8 e 18 way is this much way so obviously a thousand or however much I put in is much less so this requires says if this first section is false then go ahead and revert with whatever this second section is reverts can be a little bit confusing and a little bit tricky so what is a revert a revert undoes any actions that have been done previously and sends the remaining gas associated with that transaction back so what does that actually mean well let's say for example in our fund me contract we have a u in 256 public my value and let's have my value initialized to one now in our function let's say my value equals my Value Plus 2. so every time this fund function successfully goes through we add 2 to my value however if we get to a revert statement even though we added 2 to my value previously since our contract reverts this would actually revert this action or reset it back to its initial state so if this transaction reverts my value would go back to 1 or whatever it was previously if we compile fund me we delete our previous deploys we're on the remix VM we'll deploy fund me we'll scroll down we have my value which defaults to one if we call fund right now without any value if we pull up our terminal we could see the transaction failed my value is still one even though this line technically executed this line executed but then this line hit and it reverted what was done here so if we scroll back up though we go to Ether we'll put one in for now scroll back down now we'll hit fund oh needs to be more than once excuse me we'll add 2 here scroll back down now we'll hit fund that transaction did go through which means my value will now be equal to three and again if I I set value to zero we call fund it reverts so my value is still three so then the question might be oh well did we spend gas to do this if my transaction didn't even go through well unfortunately the answer here is yes if you send a failed transaction you will spend gas because computers executed this line and then they executed this line and just failed so users can actually specify how much gas they send with every function let's say there was a ton of computation after this require line we would need to send a ton of gas to operate and run our fund function however once it gets to this require line and it reverts however much gas that we sent to execute the rest of the computation would just get refunded to whoever initiated the transaction like I said sometimes the refunds and some of that can be a little bit confusing so again for now just know that if a transaction reverts it undoes anything it does previously and you can consider the transaction failed however if you send a reverted transaction you will still spend gas okay let's delete this value for now completed from the global scope and delete some of these like that in fact every single transaction that we send will have these fields it'll have a nuns or the transaction count the account the gas price the gas limit that we've seen on etherscan a two aka the address that the transaction is sent to a value which is going to be this amount that we're talking about they'll also have data which is going to be what we send if we make a function call or deploy a contract and then we'll have this vrs components we're not really going to go over these VR and S because this is that cryptographic magic that's happening when a transaction is signed but just know that that's in there for sending value we can populate some of these fields the gas limit for example is populated to 21 000 data is going to be empty and then that 2 is going to be the address of the transaction we want to send to for a function call we can also still populate the way that we want to send so we can call a function and send a value at the same time in remix it has a little drop down here Finney and ether we're going to ignore Finney for now but of course we have our way in ether again where one ether is worth this much gray and this much way so right now our contract is pretty minimal right we're requiring the message.value is greater than one whole ether but we want to actually require that it's less than some value like let's say we want to have users spend a minimum of five dollars as opposed to one whole ethereum so let's first specify that five dollars we could do that at the top of our contract we'll say U into 256 minimum USD equals five and we'll make this public instead of internal we'll update this minimum use D in the future to make this more gas efficient so what we want to do is we want to require that our fund function requires that the message.value is greater than let's say greater than or equal to minimum USD however minimum USD is in terms of USD or dollars and message.value is in terms of eth or way in terms of ethereum so how do we convert the amount of ethereum to its price in dollars this is where oracles and chain link comes into play the dollar price of an asset like ethereum is something that we've assigned to ethereum outside of the blockchain in the real world so in order to get this abstract concept of the price of the Native cryptocurrency of the blockchain working with so we need to use a decentralized Oracle Network or something called an oracle to get this price so before we keep going let's learn a little bit more about decentralized oracle's chain link and how they work so that we can understand how to get the price of ethereum into our smart contracts as we've talked about blockchains are deterministic systems which means that they themselves can't actually interact with real world data and events they don't know what the value of an ethereum is they don't know what random numbers are they don't know if it's sunny outside they don't know the temperature they don't know who's President they don't know any of this information these blockchains also can't do any external computation maybe you have some amazing artificial intelligence model that you want to integrate with a smart contract smart contracts by themselves can't do anything with that as we've mentioned this is is because blockchains are deterministic by Design This is so that all the nodes can reach consensus if you start adding variable data or random data or values that return from an API call different nodes could get different results and they would never be able to reach a consensus this is known as the smart contract connectivity problem or the Oracle problem and this is bad news because we want our smart contracts to be able to replace traditional agreements and traditional agreements need data and they need to interact with the real world so this is where chain link and blockchain oracles come into place a blockchain Oracle is going to be any device that interacts with the off chain world to provide external data or computation to Smart contracts however the whole story doesn't even end there if we use a centralized Oracle we are reintroducing a point of failure we've done all this work to make our logic layer decentralized but if we get our data through a centralized node or through a centralized API or we decide we want to make the API call ourselves we are reintroducing these trust assumptions that we've worked so hard to get rid of we're essentially ruining the entire purpose of building a smart contract so we don't want to get our data or do external computation through centralized nodes those are bad news chain link is the solution here chain link is a decentralized Oracle Network for bringing data and external computation into our smart contracts as we mentioned before this gives rise to these hybrid smart contracts which combine on-chain and off chain to make incredibly feature-rich powerful applications chain link is a modular decentralized Oracle Network that can be customized to deliver any data or do any external computation that you like so for example a lot of people say oh I can just make an https call to some API and we'll be good to go the blockchain nodes can't make these https calls because they wouldn't be able to reach consensus if they called the node at different times or they did something else all the consensus would be broken so instead we need a decentralized network of chain link oracles to do this and then in the transaction this network of nodes will return the data to our smart contracts for us now chain link networks can be completely customized to bring any data or any external computation that you want however doing the customization can be a little bit extra work there are a ton of chain link features that come out of the box completely decentralized ready to Plug and Play into your smart contract applications what are those features the first one is going to be chain link data feeds and that's the one we're actually going to be using for application here chain link data feeds currently at the time of recording are powering over 50 billion dollars in the D5 world the way they work is a network of chain link nodes gets data from different exchanges and data providers and brings that data through a network of decentralized chain link nodes the chain link nodes use a median to figure out what the actual price of the asset is and then deliver that in a single transaction to what's called a reference contract a price feed contract or a data contract on chain that other smart contracts can use and then those smart contracts use that that pricing information to power their D5 application we can see an example we can see an example at data.chain.link and you can change networks you can change price feeds you can change a whole bunch of different information to see some of the most popular price feeds let's look at ethusd for example on ethusd we can see this whole network of independent chain link node operators that are each getting different answers for the price of that USD they're getting aggregated by the network and then delivered on chain we can see how often they're updated these ones are updated for a 0.5 deviation threshold or a few hour heartbeat whichever one hits first we can see when the last update was you can see the number of Oracle responses Etc we can see the contract address directly on chain we can even look at the contract on etherscan we can see some of the history we can see all the responses of the different Oracles and then at the bottom we can see the different users and sponsors keeping this network up similar to transaction gas whenever a node operator delivers data to a Smart contract the chain link node operators are paid a little bit of Oracle gas in the chain link token right now these users of the protocol are sponsoring keeping these feeds up and are paying the Oracle gas associated with delivering this data on chain here's an illustration of what the current model of these data feeds look like a network of these chain link nodes each reaches out and gets the information about an asset and then signs the data with their own private key in a single transaction then one node will deliver all the data with all the different signatures to a reference contract if that node doesn't deliver the data another node will send it instead reputation is incredibly important when you're a chain link node operator if you miss data updates if you forget to send transactions you'll probably be quickly kicked off these networks and have no chance of making any more money in the future these data feeds are used by some of the largest protocols in the space such as synthetics Sushi swap compound and Ave with several billion dollars each we can take take a look at an example over at docs.chain.link work with evm contracts we're going to hit evm chains scroll down to data feeds we'll scroll down to the solidity section and we can see an example of an entire contract that uses and reads from one of these channeling price feeds we can even open this up in remix and work with it in remix it looks like this example is reading from a price feed on coven the reason we're actually going to use a test net to see this work is that there's a set of chain link nodes monitoring the test Network to show you exactly how this works out once we get deeper into the course we'll show you how to actually run tests and work with chain link nodes without actually being on a test net which will make your development much faster but I highly recommend walking through this section along with me so that you can see firsthand how this actually works so let's go ahead faucets.chain.link coven we're going to switch to the coven Network and we're going to get some coven eth but remember look at the network flag and use whatever network is in the documentation so to get some coven we're going to come to the faucet we're going to turn off test link we'll just stay with eth I'm not a robot and then send request once our coven ethereum has reached our wallet we can go ahead and close and we can take a look in our wallet and see that we do indeed have 0.1 each on coven now let's go back to our remix we'll compile this contract we'll go and deploy this on injected web3 and again the reason we're going to use injected web 3 instead of JavaScript VM is that there's no network of chain link nodes watching our little fake JavaScript VM there are a network of chain link nodes watching the test app so we'll scroll down we'll switch contract to the price consumer V3 and we'll hit deploy then a mass will pop up and after a brief delay we can see our price feed consumer down here and we can hit get the latest price which shows us the latest price of ethereum in terms of USD you may be wondering why the number looks so weird that seems like a really large number for the price of ethereum in terms of USD and this is because decimals don't actually work so well in solidity and we'll get to that in a little bit there's a decimal's flag associated with this price feed address that tells us how many decimals to include with this price it's also in the documentation however I know that this one has eight decimals so this is saying the value of ethereum right now is 3262 dollars it may of course be different when you go ahead and try this now there's a number of things that happen in this contract that I'll explain in our fund me example but if you want to take a look now and see if you can figure out what's going on I recommend you do so price feeds are one of the most powerful out of the box decentralized features you can use in your smart contract to level them up especially for a decentralized Finance if you're looking for different addresses of different price feeds you can check the contract addresses section of the documentation choose the network that you want and then scroll down and then look some of the different addresses of the different price feeds for example this address will give you the price of one inch token in terms of ethereum this address will give you the price of the Apple stock in terms of USD and so on and so forth the next decentralized application right out of the box is going to be chain link vrf or chain link verifiable Randomness function once we do our Lottery example a little bit later we'll talk about how Randomness can be manipulated in blockchain blockchains are deterministic systems which by definition means that they can't have Randomness if you can determine what a random number is it's not really random anymore is it so we need a way to get a provably random number by looking outside of the blockchain and oracles are perfectly positioned to do exactly that chain link verifiable Randomness function is a way to get provably a random number into our smart contract to guarantee fairness and guarantee randomness of applications many protocols like pull together axi Infinity ether cards avogis and more use chain link vrf for lotteries for randomizing nfts for gaming and for more we're going to do an example of chain link vrf in a later section one once we get to the lottery section if you want to see if you can play with the randomness yourself right now I recommend you go into docs.chain.link evm chains and scroll down to get a random number and this will teach you how to get a provably random number into your applications the next decentralized out of the box feature of chain link is chain link Keepers which is decentralized event driven execution as you've seen in order to kick off some type of transaction somebody needs to spend the gas and somebody needs to sit down and hit the go button or hit the transact button or hit the send button this is obviously a centralized Vector if you have a decentralized application that needs to run at specific times or after specific events are triggered chain link keepers are the solution to this chain link keepers are chain link nodes that listen to a registration contract for different events that you specify to fire maybe you say every 10 minutes you want to do something or once a week do something or if the price of some asset hits some number or maybe a liquidity pool is at a certain level whatever event that you want to to code you absolutely can the chain link nodes constantly listen for these triggers to happen and check the different contracts for these triggers once a trigger returns true the chain link nodes will then perform whatever action that you tell the chain link nodes to do we're also not going to go over the chain link Keepers examples right now because we're going to get to them in a later module however if you want to try them out go to docs.chain.link ethereum going and go to making compatible contracts and feel free to read the documentation and try it out yourself the last out of the box feature of chain link is the most customizable but also the hardest to get correct end-to-end reliability is the ultimate promise of our smart contracts and we want and need them to be able to do anything we want to be able to take any input and get any output chain link functions is the last decentralized out of the box tool and it allows you to make any API call in a decentralized context through a network of chain link nodes we're not going to be going over that at all in this video but be sure to check out the document annotation if that's something that you're interested in for me chain link functions is going to be the future of D5 and smart contracts and if you're looking to make something novel and if you're looking to make something that's never been done before I 100 recommend you check out chain link functions later on after this course or whatever you want to do as a filming it came out about a month or two ago and people are just beginning to build amazing things with channeling functions so be sure to check this out after or during the course we're going to be using the chain link Automation in a later section in this course again if you want to try these out in remix on a real test note you can go to the documentation and play with them here now I know we haven't actually written that much code but we've gone over a ton so I want to do a quick review in order for a function to receive native blockchain token like ethereum you need to mark that function as payable if you want to force a transaction to do something and you want it to fail if that wasn't done you can use a require statement a transaction that reverts means it undoes any work that it did previously and returns any gas to the user to get the values sent with a transaction you can use the solidity global message.value chain link is a technology for getting external data and computation into our smart contracts and most importantly getting that data in a decentralized context in this example we're going to be using a chain link data feed or a chain link price feed which is a decentralized way to get pricing information from Real World assets into our smart contracts now in order for us to figure out if the amount of ethereum sent with a transaction is greater than or equal to our minimum USD of five dollars we need to convert the amount of ethereum into its value of dollars so how we're going to do that well the first thing that we're going to need to do is we're going to need to get the price of ethereum or Avalanche or polygon or whatever native blockchain token that we're working with so let's create a function to do that we'll create a function get price and this function is just going to get the price of ethereum in terms of USD and then we're also going to create a function called get conversion rate rate which is going to convert a value to its converted value based off of the price for now we're going to make them both public functions so we can play with them test them and do whatever we want with them to get the price of ethereum we're going to use the chain link data feed and we go through the documentation to get that information so in the documentation I'm going to scroll down using data feeds I've got an example here right in solidity and if you wanted to like I said you could easily open this up in remix now you can see this example in the documentation what's actually going on when working with a chain link price feed there's a contract out there at an address and we're going to call this latest round data function on that contract gives us a whole bunch of data but we really only care about the price so we're going to want to do the same thing we want to reach out to that contract that's currently storing and having the price updated so since we want to reach out to and work with the contract we're going to need two things right what are those two things when we need the address and we need the ABI the address of the contract is going to be really easy we can get the address by going to the chain link documentation and let's go up to this price feed addresses section we'll scroll down we want to be on ethereum okay great let's look for a sepolia looks like it's way down here and all right awesome e2sd great there's an e2sd price feed so now that we have the address how do we get the ABI well before with simple storage we imported the entire contract from the top and we compiled and we got the API like that we could do that here but that's kind of a lot of code and we don't actually care about what the whole contract looks like we only really want to know what the functions are so we can call that latest round data function remember if we're on remix and we go down to the compilation details the ABI is really just this list of functions that we can call on a contract the ABI itself doesn't actually need to include any of the logic it just needs to say hey these are the functions you can interact with and here they're inputs and here's whether or not they're payable and here's whether or not their view functions Etc like I said though this kind of is a white lie you can also use a functional selector or some other ways but we're just going to ignore that for now how can we get the ABI there's a concept in solidity known as the interface if we go to the chain link GitHub we go to smart contract kit chain link we can see a lot of different contracts in the chain link repository we go to contracts SRC this might look a little bit different based off of when you're looking at it V 0.8 interfaces and we go to aggregator V3 interface if we scroll down we can actually see a whole bunch of function declarations but none of them are actually implemented it's just function the name of the function some stuff external viewable but then just the semicolon and nothing inside of them this is what's known as an interface if you compile this this will actually give us that ABI because it defines all the different functions that you can call on a contract it just doesn't have any of the logic again we don't really even need to know what the functions do we just need to know how to interact with the contract and if a contract is deployed it'll have that logic in its deployment so what we can do is we can copy this whole thing scroll all the way to the bottom hit the copy button and paste it in on our remix now hold on though if you're following along you don't have to copy paste it in here with me because I'm going to teach you something in just a minute that makes this a little bit easier this pasted code alert comes up we're running solidity code so this is going to be okay but since we're only working on testnets here we're going to be okay that we don't have to worry about pastic code alert if you want to take a second to read it please do but we're going to paste this code in here just like we did before with simple storage for now you don't have to follow along I'm about to show you an easier way just follow along and watch now that we have this interface aggregator V3 interface we can use this interface to make API calls because now we have the address and we have the API and we can even compile this and it'll compile fine so we can say aggregator V3 interface at address this and the combination of these two give us whatever code is at this address with all the functions from the aggregator V3 interface and just to test this out we can do something simple like dot version sense if we scroll up looks like there is indeed a version function put a little semicolon at the end so let's actually go ahead and actually copy this line give it its own function called get version this will have this public view turns what is the version of your return a unit 56 however return a unit 256 paste that line in here aggregator V3 interface at its address dot version we'll say return all of that now I'm going to go ahead and deploy this to the sapolia test net just to show you what this would actually look like however I'm going to recommend you don't do that for now just know that this will work this way you won't have to wait forever for your transactions to go through on the test net so to do this I'm going to go ahead and scroll up to the top go to injected metamask change the contract from aggregator V3 interface to fund me I'm going to go ahead and hit deploy my metamask is going to pop up I'm going to go ahead and hit confirm and we're going to scroll down and now we have a big blue button called get version which I'm going to go ahead and click and we can see we get a four return because at this contract address on the blockchain it has the functionality for get version for and for the rest of this lesson I'll be showing you guys and testing this on an actual test net however I recommend that you don't test all of these as I go along just watch me do them because again waiting for transactions on a test net can be really annoying sometimes the test tent might be having issues because again it's people running them out of the goodness of their heart so for this lesson just follow along write the code with me and then maybe at the end deploy everything so this is a really easy way and a common way that people use to interact with other contracts outside of their projects they get the interface of that contract using the interface keyword they compile it and the compiler actually gives us an API and then you just wrap an address around with that interface keyword and you can call any function at that address and and this is one of these things as we work with more and more it'll start to make more sense in the beginning it might be a little hard to grasp but just bear with me for now the more we do it the better you'll get don't get discouraged take a deep breath and exhale and let's keep coding and if this is confusing to you this is again where we can work with our AI friends or any of the forums that we're working with again very soon I'm about to show you how to ask really good questions and make really good prompts but one we could ask here is hey I'm confused how does the solidity function return the value 4 when I didn't Define any logic in aggregator V3 interface and I've posted that code from get version here because a common issue that I see new developers run into is they go oh wait wait how does this version return for my aggregator V3 interface doesn't have any code in it why does putting an address in here make it work like what's going on and let's see if our AI is able to help us here so this is chat gbt version 3.5 again I prefer version 4 but this is the cheaper one and it says in the code you provided the get version function is calling the version function of an instance of the aggregator V3 interface contract it appears that the contract address here is being used to create an instance of aggregated V3 interface the aggregator V3 interface is an interface contract that defines a set of functions that must be implemented by another contract it serves as a way to interact with the contract at the given address by providing a common interface the version function being called in your code is likely defined in the actual contract that implements this and this is pretty much correct right and so it gives us some more context here this is exactly correct this address has a version function and US surrounding it with this aggregative E3 interface like typecasting it in these parentheses like this is just telling our solidity compiler hey there's a version function at this address or there's a latest round data function or all the functions all the functions in this aggregator V3 interface are at this address if this address doesn't have a version function this would just break and this is a good example of again where we can actually follow up with these AIS they're typically very good at keeping context so we could even ask what would happen if that contract address didn't have that function and we see if the implementation contract at the given address does not have a version function or if it has a different function signature calling version on the contract would result in a compilation error or a runtime error so it wouldn't result on compilation error but the transaction would revert so so this is pretty helpful here but again we always want to double check this so this is where we'd probably go back to the discussions forum and follow up there so now that we actually have the interface we can start calling these functions and calling these addresses however having a ton of these interfaces is really going to clog up our contracts and clog up our files and be really gross to work with is there a better way for us to do this well when we worked with simple storage yes there was we just went ahead and used Imports right but that's when we had all the code in our locally in our directory we don't have all the code locally we didn't create the aggregator V3 interface we didn't create the price feed contracts so can we do something like import simplestorage.soul but with a contract outside of our project well again we could copy paste it to its own file and import a tour V3 aggregator V3 interface.sol and of course we're going to use this named import syntax because we're awesome developers we could copy paste it like this and do exactly what we did before we could create a new file called aggregator V3 interface paste the code in there or we could actually import directly from GitHub if we go back to the documentation associated with using data feeds we scroll down to using data feeds here scroll down we see at the top they do this import like this import at chain link slash contracts SRC blah blah blah this import actually has the same setup as as the path of what's in the GitHub repository so instead of us copy pasting from GitHub we can actually import directly from GitHub or npm so we can copy this line back in our remix we could paste it in like this remix is smart enough to know that this at chain link slash contracts is referring to the what's known as an npm package at chain link slash contracts at chain link slash contracts is what's known as a package manager and it keeps different versions of combinations of code for us to download at chain link slash contracts is created directly from chain link repository remix downloads all this code from mpm which is Created from the GitHub so it essentially downloads it from the GitHub so us doing this import like this is the same as is just copy pasting the entire interface at the top of our contract now we have this aggregator V3 interface that we want to work with we go ahead and compile and bada bing bada boom so great so now that we have the interface here which will give a minimalistic API for us to interact with the contract how do we actually get the pricing information well again if we go back to the docs we can see right here it gives us an example of the code we can use to get the latest price but let's write it ourselves just so that we know what's going on we'll say Agra gaytor V3 interface and we'll actually create a new variable called price feed equals aggregator V3 interface contract at this address which again only works for a sepolio now we can call this latest round data function on the price feed so we'll say price feed dot late round data and if we look at the interface on GitHub we can actually see latest round data it doesn't just return one variable it returns a whole bunch of different types of variables and to return multiple types we do some syntax that looks like this and we'll say you went 80 round ID and you can even flip back and forth between the documentation make sure you have it right int price which again we know in to Falls to an end to 256 you went 256 started out you went 256 timestamp and then you went 80 answered in round there's a lot of code in here since this function returns so many variables we have to set something up to capture them but we don't care about any of this other stuff we just care about price so what we can do is actually just remove them and leave the commas in there so we're going to remove started at remove timestamp remove answered and round and I hit command s to compile we're gonna get these yellow squiggly lines which are warnings but we're going to fix them in a minute now we have in price equals price feed dot latest round data because we only care about getting the price from the return the reason price is an into 56 is because some price feeds could be negative now that we have the price this price variable is going to be representing the price of eth in terms of USD and it's going to return a number that looks like this because again slitty doesn't work with decimals so we know that this price feed has eight decimals but it'll get a return like this boom like this it'll return a value that looks like this if we want to double check how many decimals there are in a price feed it actually has a decimals function which allows you to check that as well now as we know message.value is going to have 18 decimal places how do we know that well because we know that one ether is equal to this many way and this many way has 18 zeros one two three four five six seven eight nine ten one two three four five six seven eight so this massive number is equal to one ethereum right one point one two three four five six seven eight nine ten one two three four five six seven eight so right now message on value and price actually have different decimal places price has eight message.value is going to have 18. so to get them to match up we have to do return price times one E10 or to add those additional 10 decimal places and yes I know we have a red line I'll fix this in a minute price as we know is a int 256 and message.value is going to be a u and 256. so the types are actually different so we want to get the price in terms of U into the 56 instead of in 256. convert them we can again do a thing called typecasting there are a lot of different types that can be easily converted between each other not all types can be typecasted but an INT and a unit 56 can be so to make our price U into 56 we would just do uint 256 and wrap price like this or we could just wrap both of them like this now of course since we're not modifying any state but we are reading storage we can make this a view function and then we'll say it returns a uint256 like so and now if we compile we get rid of all those errors and warnings now math could be a little bit tricky in solidity but the more you do it the better you'll get and the reason math can be tricky is because there aren't any decimal places so you need to only work with whole numbers the more you work with it the better you'll get though awesome so now we have a get price function which is going to return the value of ethereum in terms of USD as a unit 256. now all we have to do is convert our message.value in terms of dollars using this get price function to do that we're going to use our get conversion rate function this get conversion rate function is going to take a u into 256 ether Mount as an input and we're going to convert this ether Mount to its value in dollars this will be a public view function that will return a uint 256. so first we're going to get the price of ethereum by doing U into 6 e price equals our get price function that we just defined and then we're going to do U into 256 eth amount in USD equals eth price times each amount and then we actually have to divide by one e 18. the reason we divide by one E18 is because both of these have 18 decimal places and if we multiply one one two three four five six seven eight one two three four five six seven eight nine ten if we multiply these by each other where both of these are representing one we're actually going to get a number that's absolutely massive with 38 decimal places so we need to divide by 18 to produce it back down to what it should actually be an important rule with working with math and solidity is you always want to multiply before you divide the reason for this is since again only whole numbers work in solidity if you were to do one divided by 2 you would end up getting 0. so you always want to multiply first when we get to The Foundry section of this course testing all this math is going to be a lot easier if you're really struggling with some of the math bits right now I wouldn't let that slow you down because one of the things that AI is really good at is doing a lot of these math conversions but in any case this eth amount in USD is the number that we're looking for so we can say return eat them out and USD and awesome now we have a get conversion rate function let's walk through this together just so that you can understand what's actually going on let's say we want to see how much one eth is worth well we're going to get the eth price which let's say it's two thousand dollars but it's going to be two thousand dollars with one two three four five six seven eight one two three four five six seven eight nine ten eighteen zeros so each price might look something like this so that means we're going to do this 2000 with 18 decimal places times one eighth which is going to be one one two three four five six seven eight one two three four five six seven eight eight nine ten we're gonna multiply those together and then since we're gonna get an additional 36 zeros then we just divide by one e 18 and that's how we would get two thousand dollars equals one eighth it's going to be two thousand of course with 18 decimal places one of the good reasons for using whole numbers in solidity is that it's not possible to have decimal places so we don't lose any Precision which is really good so normally we should test this function before continuing but since we're doing all this on a testnet and I promise you that I tested this all beforehand we're just gonna go ahead and keep going so now that we've done all this work if we want to make sure that our users are sending at least five dollars we can do get conversion rate of message.cender needs to be greater than minimum USD because get conversion rate takes an ether amount as input uses the pricing information to get the dollar value back and we're going to check to see that the dollar value of the message.value is greater than the minimum USD however since get conversion rate returns a value with 18 decimal places we need to update our minimum USD to say five times ten raised to the 18th or we could also do 5e 18 or we could do five times one e eighteen I personally like this 5e 18 syntax but whatever works for you I'm going to deploy this to a test net just to demonstrate this working but again you do not have to so we're going to go ahead delete our previous deployments injected web3 deploy metamask pops up I'm going to go ahead and confirm after a long delay we'll get our deployed contract here we have all this stuff we can call get price and we can see the value of ethereum right now is this with 18 decimal places which is awesome so it's around 1 896 dollars so if I were to try to fund this with maybe 100 way I know for a fact that 100 way isn't going to be enough so if we call this fun function we're actually going to get this gas estimation failed gas estimation error failed with the following message blah blah blah error execution reverted didn't send enough eth which is actually exactly the error message that we have here it's exactly what our error message is here in our require didn't send enough eth so if you try to fund it we're going to get didn't send enough eth and this gas estimation failed is a pretty common error that you'll see in remix and solidity and evm in general it's kind of just the boilerplane answer for something went wrong luckily we got the actual error message here so we could debug here's what's actually going on now you see here we could still send this transaction like I said we would actually spend gas to send a failed transaction and this isn't something that we want to do so we're going to go ahead and cancel however if we did send maybe one one two three four five six seven eight one two three four five six seven eight nine so if we go to Google actually we can even see like an eighth to dollar conversion rate so if we sent 0.01 0.01 eth right now is worth 18 it might be different depending on when you actually do it so we send 0.01 eth in our remix and we can do that by doing one one two three four five six seven eight nine ten one two three four five six so that's one e16 and we hit fund now we actually see metamask pops up we don't get that gas estimation error we can go ahead and confirm and we can see that our function is working as expected which is great it's reverting transactions that have less than five dollars and it's letting transactions go through that have at least five dollars awesome if we select minimum USD we can obviously see that here and we can see we have 0.01 Ethier fantastic and since we don't have a withdrawal function here we actually can't pull it out which is another reason why I say hey maybe don't test this right now but great we've confirmed our get conversion rate is working so let's move on fantastic so what's the next thing that we should do in this contract well we probably want to keep track of the users who send us money in this contract so we can keep an array of addresses called funders and keep updating that depending on who actually sends US money so up at the top we'll make an address array or an address list we'll make it public and we'll call it funders and anytime somebody sends US money we'll say funders dot push message dot sender like message.value message dot sender is another Global variable we can use in solidity which refers to whoever call this function the sender of the transaction to this contract so if we're on sepolia and we initialize a transaction from our metamask the message.sender is going to be this account right here and then maybe we want to even make a mapping of addresses to to make it easier to look up how much money each funder has sent so it will make a mapping of an address to a you went to 256. we'll call it public address to amount funded now something that's new or in solidity is you can actually name the types in your mapping so you could say address funder mapped to un256 amount funded usually this is what's known as a little syntactic sugar it's just to make it easier to read what this mapping is Right funder to amount funded and then our variable name is very explicit address 2 amount funded now if somebody funds our contract we'll of course do address to amount funded the message.senders address plus equals whatever they previously have funded plus message.value whatever they're additionally adding all right great and now we have a way for us to keep track of funders sending money to our contract and have an easy way with a mapping to look up how much they've spent in total now I know we've gone over a lot of advanced solidity here so let's do a quick refresher of what we've learned so far whenever we interact with a contract we always need the address and the API compiling an interface allows us to get that ABI very easily for us to interact with another contract when we combine the contract address with the interface we can easily call the functions on that contract chain link price feeds are an easy way to get data especially pricing data from The Real World into our smart contracts when working with math and solidity and the evm in general decimals don't work so we need to always make sure we're using the correct number of units whenever we interact with our contracts message.value and message.sender are known as globally available units in solidity and they refer to the sender of a message of the current call or the number of ways sent with a message or transaction there's a whole bunch of these and you can view them all in the solidity documentation all right great so we've got a way to actually get this pricing information pretty easily however our code is getting a little bit cluttered with these get price and get a conversion rate you'd think that these are functions that would be reused pretty often anyways for anybody looking to work with chain link price feeds so is there an easier way for us to work with this pricing information maybe doing some math like this is pretty common and we'd want other contracts to be able to import this conversion functionality and a way that we can do that is actually creating something called a library there's a site out there called solidity by example which has great examples of using libraries and what they work with libraries are similar to contracts but you can't declare any state variables and you can't send either a library is embedded into the contract if all Library functions are internal otherwise the library must be deployed and then linked before the contract is deployed that's a little bit confusing don't worry too much about that right now using libraries can actually add functionality to different values and what do I mean by that well I mean we can have our get conversion rate function b a function of any value of Type U into physics mean means we could take this get conversion rate and do something like message.value dot get conversion rate so we can create our own custom function with any type we could work with get conversion rate as if message.value was a class or an object or contract that we actually created to do this let's go back to our files create a new one create a new one called price converter dot Sol and this is going to be a library a price converter Library so how do we create a library and what is a library well a library is going to be very similar to a contract we're going to start of course with spdx license identifier we're going to do pragma solidity and we'll give it a version of 0.8.18 the little carrot and instead of typing contract we're actually going to type library for the name of the library and we're going to call this Library price converter so libraries can't have any state variables and all the functions have to be marked internal so what we're going to do is we're going to go back to fundme.sol and zoom out a little bit we're going to grab get price get conversion rate and get very version delete them well I hit copy first go back to price converter paste them in here and work with them in here of course we're going to need the aggregator V3 interface so we're going to go back to our fund me we're going to copy this named import from aggregator V3 interface paste it in at the top here hit command s and we're going to go ahead and compile this successfully fund me is no longer going to compile but we're going to fix that in a little bit now the first thing that we're going to need to do in here is make these all internal so we're going to say internal like this and do internal get conversion rate and internal get version now that we have our price converter Library we can actually import it back in our fund me and attach it to aun256 and let's actually delete this aggregator V3 interface line for now and we'll do import price converter from dot slash price converter that's all and now to attach the functions in our price converter library to all you and 256s will say using price converter or you went 256. of course if we compile our fund me we're gonna get an issue because it doesn't really know what get conversion rate is so for now let's actually just comment out this line I'm going to remove these comments up here as well so what we can do now though is we can do message.value dot get conversion rate hit conversion rate and in your library whenever you're working with a library the first input variable for a library is going to be the type that you're using with the library so message.value is of type un256 so this gets passed inside of get conversion rate as the first variable into ue256 eat them out even though we don't pass any variables inside of these parentheses here or get price and get version we don't really care to have an input parameter at all so it'll pass it in but not do anything so now instead of require get conversion rate of message.value we can actually do let's uncomment this slide now and let's delete this line we can actually do message.value dot get conversion rate convert generate and now if we compile this this is going to compile successfully this works because we're attaching the price converter library to all you want 256s so now all you and 256s have access to this get conversion rate function and since message.value is a un256 it can call Dot get conversion rate and it'll pass itself so that message.value as the first input parameter to the function here if we wanted another variable in here like you into six something else that would be the first parameter inside these parentheses so maybe like one two three or something right this one two three would be the something else but message.value would still be the initial parameter which in this example would be etham out so let's go ahead and undo that and undo that but all right great we've moved a lot of the math into our own Library congratulations nice work one of the most common libraries that was used for a long time was this Library called safemath.soul and in your solidity Journeys you'll probably see it pop up from time to time now we're going to go off on a little bit of a tangent here about safe math in the library safe math and this is an excerpt from my course last year so you might see stuff like rank B and some other stuff but just focus on the safe math stuff just know and refer to the JavaScript virtual machine that's talking about the remix virtual machine one of the most common libraries that was used for the longest time was this Library called safemath.soul and you'll probably see it a lot of different places we're going to go off on a quick little tangent here and teach you about safe math so let's close fund me and close price converter and let's create a new file called safe math tester .soul and let's start with some basic stuff in here safe math was all over the place before version 0.8 of solidity and now it's almost in no contracts what happened why is safe math no longer used as much well let's create a sample contract this is a section that you don't have to follow along if you don't want to code along with me but if you want to you absolutely still can this is going to be a contract we are going to deploy on a JavaScript virtual machine we can use any version of solidity before version 0.8 of solidity so for example we use pragma current 0.6.0 and we'll create contract safe math tester dot Sol now if I create a umint 8 I set it to public big number and I set this to 255. oops safe math tester let's go ahead and compile safe math tester with 0.6.7 ragma solidity the maximum size of a uint 8 is going to be 255. this is going to be the biggest number that we can fit in a new and eight and if I were to deploy this to a JavaScript VM or even a test Network save math tester let's go ahead and deploy it if I hit big number we're going to get 255. well what happens if I create a function called add that sets big number equal to big number plus one let's save that delete that old contract and deploy well right now big number is 255 what happens when we add one to big number when 255 is the max size a uint 8 can be well let's hit add now let's check what big number is big number gets reset to zero so what's going on well prior to version 0.8 of solidity unside integers and integers ran on this concept of being unchecked which means that if you passed the upper limit of a number it would just wrap around and start back from the lowest number it could be so if I call add a whole bunch more times and hit big number now it's eight if I were to hit this add button a ton more times and get it back to 255 it would then continue to wrap over to zero so one of the most popular libraries that was out there was this safe math Library which would basically check to make sure that you weren't wrapping around you and 256 or an n256 basically it was a way to say hey you've reached the max this number can be and now your transaction is going to fail if we switch this to 0.8 of solidity let's delete the old contract we'll switch this to 0.8 we'll go ahead and compile it and now we deploy this to JavaScript VM if I hit big number we get 255 but if we hit add it actually fails and we still get 255. in version 0.8 of solidity they added this bit where it automatically checks to make sure if you're gonna do what's called overflow or underflow on a variable we can actually revert back to the unchecked version by using an unchecked keyword so if we wrap this big number equals big number plus one in this unchecked bracket let's delete our old contract we'll compile we'll redeploy we hit big numbers 255. now we hit add we hit big number again it reverted back to zero so that's a little bit more about safe math checked and unchecked so in version 0.76 and below this code that you see in front of you is going to be the exact same as this code in 0.8 and above with this unchecked keyword now you might be thinking in newer versions of solidity why would I use this unchecked keyword well you'll find out later that this uncheck keyword makes your code a little bit more gas efficient so if you're absolutely positive that your math is never going to reach the top or bottom limit of a number then it might make sense for you to use the unchecked keyword let's head back over to our fund me contract where we are now using the price converter library that we just created awesome we have a lot of the basics of the math that we need in our fund me contract so all right so this is great people can actually send us money and we're going to keep track of them as well which is fantastic so the next thing obviously that we're going to want to do is we're going to want to be able to withdraw that money out so now let's go ahead and Implement our withdraw function when we withdraw the money we're probably going to want to reset all the mappings back down to zero to show that hey we've withdrawn all the money and there's nobody left to do this we're going to use something called a for Loop a for Loop is a way to Loop through a list of something or to do something in a repeated amount of time if you're familiar with other programming languages it's the exact same concept if we wanted to get all the elements in this list for example which where one is at the zeroth index 2 is at the first index three is at the second index and four is at the third index which I know is a little bit confusing these are the different these are the indexes these are the elements we would Loop zero through three to get all the elements out of this array to do this loop we're going to use the four keyword we're going to say four put some parentheses and in a for Loop we can add a couple things and by the way this is a way to do comments inside of a line in solidity you do a backslash star start backslash and now everything in here is a common so in a for Loop you first need to give it the starting index then you give it the ending index and then you can give it the step amount for example let's say we want to start on the zeroth index we want to go all the way up to the 10th index and we want to go by up each time we would do 0 1 2 3 4 Etc let's say we want to start with the third index we want to go to the 12th index and we want to up by two every single time well we would do 3 5 7 9 Etc so our starting index is going to be a unit 256 and we'll call it under index and we're going to say we're going to start with zero and we're going to end once the funder index is less than the funders.length so I know I said up here it's the ending index but instead it's a Boolean once the funder's index is greater than funders.length which is how you can get the length of an array then we're going to end and then finally we're going to say every single time we do a loop we're going to say funders index equals funders index plus 1. now there's a shortcut you can do to do some variable equals itself plus one and that's just plus plus this plus plus means every time we go through the loop just add one and we actually don't need that here and then we put these curly braces to say okay execute everything inside of this Loop here for the duration that we specified here and this final piece means that every time we run through all the code inside of these brackets we're going to add one to this funders index that's how we go from zero to one two three four five six seven Etc to access the zero width element of our funders array we're going to say funders of under index and this is going to return an address since it's an array of address is so we'll say address under equals funders of funder index and we want to use this to reset our mapping address to amount funded so we can say address to amount funded at the funder address is now equal to zero so we're going to reset whatever we added when they funded us down to zero because we're withdrawing all the money out and additionally how there's a nice little shorthand like plus plus down here up here in the fund another nice little shortcut whatever you want to add something to whatever you want to add something to something that already exists instead of doing something equals itself plus the new thing you can just do plus equals this means that we're going to set address to a malfunded of message.c sender equal to itself plus message.value so let's walk through this for Loop a little bit we're going to start with the zero with index we're going to get the funder at the zeroth index in our funder array we're going to take that address stick it into our mapping and reset the amount that they've sent us to zero then we're going to do funder plus plus we're going to check to see that 500 plus funder index plus plus is less than funders.length obviously fund 0 plus 1 is going to be one so we're going to check if one is less than the total amount of funders and then we're going to get the address of the funder at the first index we set them to zero get the address of the second index we need to set the zero third index et cetera Etc until we finally reach the index that is equal to or greater than the length so if we have 10 funders and we reach funder index 10 the for Loop will exit and be done but we still haven't done two things we need to reset the array still and then we also need to withdraw the funds since we've accumulated all this message.value in the fund function to reset the funders array we could do the same thing we did with the mapping and reset each single address at each index or we could just create a brand new funders array which is what we're going to do so to reset the array we're now going to say funders equals new address array and to start off at a length of zero previously we used the new keyword to deploy a different contract now we're using the new keyword to reset the funders array to a brand new blank address array this part's a little confusing don't let it hold you back you can land it later in the course while we make the choices here that we do so great we've gone ahead and reset the array so now how do we actually withdraw the funds for this section I'm going to go ahead and again refer to a previous course that it did because the content is exactly the same just remember JavaScript VM is remix VM so great we've gone ahead and reset the array but how do we actually now withdraw funds from this contract how do we send the funds back to whomever is calling this now to actually send ether or send native blockchain currency there are actually three different ways to do this we're going to look at all three and say what the difference is between the three of them are three different ways are going to be transfer send and call let's go ahead and start with transfer since transfer is the simplest and at surface level makes the most sense to use so if we want to transfer the funds to whomever is calling this withdrawal function we would do we would say message dot sender dot transfer and then we'd get the balance of our contract here by saying address this that this keyword refers to this whole contract dot balance and we can get the native blockchain currency or the ethereum currency balance of this address like this and we can just do that only thing that we need to do is we need to cast we need to Typecast message dot sender from an address type to a payable address type so message.sender is of type address whereas payable message.sender is of type payable address and in solidity in order to send the native blockchain token like ethereum you can only work with payable addresses to do that so we just wrap it in this payable type Caster so this is the first way that we can actually send ethereum or send tokens from different contracts to each other we wrap the address that we want to send it in in this payable keyword we do dot transfer and then we say exactly how much we want to transfer but there are some issues with transfer here we are on solidity by example for sending ether which again is a fantastic resource to refer to if you get lost the method that we just looked at was this transfer method now we saw way earlier in the course that if I sent ethereum from one address to another it costs about 2100 gas or two thousand one hundred gas our transfer function is capped at 2 2300 gas and if more gas is used it throws an error the next one that we're using is going to be send which is also capped at 2300 gas and if it fails it'll return a Boolean so with transfer if this line fails it'll err and revert the transaction with send it won't err it'll return a Boolean of whether or not it was successful so using send will do payable message.sender dot send address this balance but we don't want to finish our call Here If This Were to fail the contract wouldn't revert the transaction and we just wouldn't get our money sent so we want to do Boolean send success equals this whole bit here and then we want to require send success and if this send fails we'll throw an error saying send failed this way if this fails we will still revert by adding our require statement here transfer automatically reverts if the transfer fails send will only revert the transaction if we add this require statement here so great what's the third way that we can actually send ethereum or native currency well it's with this call command Now call is going to be one of the first lower level commands that we actually use in our solidity code because this call function is actually incredibly powerful and we can use it to call virtually any function in all of ethereum without even having to have the ABI we'll learn the advanced ways to use this call much later for now we're just going to learn how to use it to send ethereum or your native blockchain currency call is going to look very similar to send we're going to do payable message.sender dot call and this is where we'll put any function information or any information about the function we want to call on some other contract we actually don't want to call a function so we're going to leave this blank we can show that we're leaving it blank by just putting in these two quotes here we instead want to use this like a transaction and as we saw in our deployment there's always this message.value bit so we're going to use this call function as if it's a regular transaction and we can add stuff like message.value so in here we're going to add these squiggly brackets and we're going to say value address this dot balance this call function returns actually two variables and when a function returns two variables we can show that by placing them into parentheses on the left hand side the two variables it returns are going to be a Boolean that we're going to call call success and also a bytes object called Data returned since call allows us to actually call different functions if that function returns some data or returns a value we're going to save that in the data returned variable it also returns call success where if the function was successfully called this will be true if not this will be false and since bytes objects are arrays data returns needs to be in memory now for our code here we're actually not calling a function so we don't really care about data returned so similar to what we saw with the price contract we can just go ahead and delete that and leave the comma to tell solidity yeah we know this function returns two variables but we only care about one and then similar to the send piece above we're going to do require call success call failed meaning that requiring call success is true otherwise we'll revert with an error that says call failed now if learning the difference between these three is a little complicated for you right now don't let that slow you down feel free to come back to this after you've learned more about how some of these lower level functions work and a little bit more about how Gas Works solidity by example does a fantastic job though of saying what the difference is between all three are transfer has a maximum of 2300 gas and throws an error if it fails send has a maximum of 2300 gas returns a Boolean if it fails call forwards all gas so it doesn't have a capped gas and similar to send returns a Boolean if it is successful or if it fails as of recording right now using call is the recommended way to actually send and receive ethereum or your blockchain native token for now if this part's a little bit confusing for you for now just look at this and see Ah that's how we send and transfer ethereum or native blockchain currency tokens and I'm going to delete this part for the video but I'll keep those comments in the code repository associated with this course all right great and actually the exact same code from that video we're going to use for this as well so we're going to use this call call success to work with sending a balance however there's a bit of an issue here right now anybody can call this what draw function and take all the money out of this contract we don't want that we want anyone to be able to fund the contract but we don't want anyone to be able to withdraw money from the contract we only want the owner of the contract to be able to withdraw so how do we set this contract up so that the withdrawal function can only be called by the owner of this contract well we want to set this contract up so that whenever we deploy it whenever we create this contract an owner gets assigned to this contract we assign some address to being the owner and then we add some parameters so that withdraw can only be called by that address so what we could do is we could set up some function well to call me right away and when we deploy this contract we would just immediately call this call me right away function which will set us up as the owner however that would take two transactions and remember when Engineers we want to work incredibly hard to be incredibly lazy so instead solidity has something called a Constructor and if you're familiar with other programming languages a Constructor is the exact same as really every other programming language and the Constructor is a keyword and a special function in solidity so we can create a Constructor function without the function keyword we just call it structure and we also don't even need the public keyword you'll see remix even highlights it pink this is going to be that function it's going to be a function that is immediately called whenever you deploy your contract this function will be called in the exact same transaction that is used to deploy your contract for example if I were to take this minimum USD add it in our Constructor and say minimum USD equals two this minimum USD would immediately get updated to 2 right after this contract is deployed in that exact same transaction since we want this withdrawal function to only to be able to be called by the owner of this contract in our Constructor we can set set up an address right away to be the owner of this contract so let's create a global variable called address public owner and then right in our Constructor we'll say owner equals message dot sender message.sender of course being the sender of the caller which in this example is going to be the deployer of the contract don't worry we're going to demo all of this very soon to show you everything that's going on if you want to test all this right now absolutely go for it but just remember it's going to take you a little bit longer on a test net and I'm going to show you how it all works anyways now that we have our owner set up we can actually modify our withdrawal function so that only the owner can call this function easily enough we're already familiar with the require keyword we could add a require the message.cender of whoever calls this withdrawal function must be equal to and this is how you do equals and solidity with this double equal sign a single equal is set a double equals means equals so message.sender must equal the owner and if it's not the owner we could revert with something like must be owner awesome so now we have a quick way to require that over calls the withdrawal function is indeed the owner awesome but let's say we have a lot of admin functions or only owner functions or functions that should only be called by the owner would we have to put this line on every single function remember we want to work incredibly hard to be incredibly lazy we don't want to have to copy paste this line to every one of these functions and this is where something called modifiers come into play so we're going to go ahead and actually delete this line and at the bottom we're going to create our first modifier a modifier is going to allow us to create a keyword that we can put right in the function declaration to add some functionality very quickly and easily to any function to create a modifier you use the modifier keyword and then you set it up very similarly to a function so our modifier is going to be called only owner we don't give it a visibility like functions and in here we can put our code so again we'll say require the message dot sender is equal to not set to is equal to the owner and if it's not the owner we're going to say sender is not owner like this and then underneath we're going to put this little underscore with a semicolon what we can do is we can take this only on our keyword and stick it in the function Declaration of our withdraw and what's going to happen now is it's going to execute what's in this modifier first it's going to execute this require and then this little underscore says and then add whatever else you want to do in the function so we're going to execute this require then whatever else is in the function and for our withdrawal function it's going to be everything else in here in our modifier if we had the underscore above the require this means that we would execute the code inside the function first and then the require so the order of your underscore matters so now with this modifier keyword in the withdrawal function whenever you call the withdrawal function we first go up there's a modifier I gotta drop down here well execute this oh here's an underscore time to go back to the function let's do what else is in the rest of the code and then it'll come back down to the only owner modifier and say oh is there anything else to do oh there's nothing else so I guess we're good so let's see this all go through end to end and remember you don't actually have to deploy this to a test net if you don't want to but if you want to follow along feel free to do so of course as well get started let's of course compile fundme.sol looks good let's delete any contracts deployed previously let's make sure we're on injected provider metamask and let's make sure that we are on a test net we are indeed let's make sure we have a little bit of testnet eth in our wallet and we sure do and let's go down to the contract and make sure we're on the right contract if you try to deploy some like an interface you'll get an alert like this this contract might be abstract blah blah blah so we're not going to do the interface we're going to do the fund me contract of course we'll hit deploy metamask will pop up we'll go ahead and hit confirm on the metamask and then we're going to have to wait a little bit for the contract to actually finish deploying if we pull up the terminal we can see the contract go through and we can also see it in remix here now we've got a number number of buttons in here we've got our red fund button of course which is because we have our fund function which is payable and this allows us to send eth with this function we have our withdraw function which is just orange because it is not payable although it is going to be withdrawing money out of the contract and then we have our typical blue View and pure functions the owner of course is going to be our metamask since we are the ones who deploy this contract minimum USD is going to be 5 and these are of course going to be empty we can call our fund function only if we send some value with it if we try to call fund without any value we're going to get this gas estimation error failed and we'll even see didn't send enough eth in the error log so let's go ahead and cancel this again we could send this but that would be a huge waste of gas so we'll cancel it and let's get a value that's going to be enough so I believe 0.01 eth should be enough let's say 0.01 eth it looks like that's about 18 so back in remix let's do 0.01 eth in terms of way which is this value here paste that in and we'll scroll down now if we call fund it does indeed go through and we can go ahead and hit confirm on this as well and we see that transaction pop up on etherscan and we might have to wait a little bit for this transaction to finish finish going through finish indexing Etc so let's give it a couple minutes oh it looks like it's gone through fantastic we can even see in the fund me contract the balance has gone up to 0.01 and we can see if we look at funders at index 0 we can see our address and if we copy our address and paste it into the mapping address to AML funded we do indeed see an amount in here with this transaction fund being called of course on the test net etherscan we can see all the data and information associated with this and we can even scroll down and see the input data we can see that this was calling the fund function we'll learn more about the input data later so now we could do is we could do the reverse we could go ahead and withdraw and that should reset the mapping and the array back down to 2-0 for our modifier to work we have to use withdraw on this account if we switch to an account that isn't the owner of this contract and we go ahead and reconnect and we scroll down we make sure value is zero and we scroll down and try to hit withdraw we'll see we get gas estimation failed and we'll even say sender is not the owner so we'll go ahead and cancel that we'll switch back to account one we'll make sure we're working with account one now we'll call withdraw we'll see metamask does indeed pop up and we can go ahead and confirm and in just a minute we'll see the balance reset and if we call our funders and mapping they should also have band reset so let's wait a little bit now if I try to call address to amount funded with that same address we now get zero and now if we look at funders at index 0 it actually errors and this isn't correct following our more advanced load accountants if you don't understand them the first time don't let them stop you they are not required to know to continue the following is an excerpt from a slightly older edition of this course you'll see that I don't use named Imports like a noob and a few other pieces of the code look slightly different but this next section we're going to go over a lot of really Advanced solidity pieces here that are really Advanced solidity fundamentals these are going to be fantastic for saving gas making your code look a lot cleaner and just better coding practices overall for those of you who are looking to go super far with this definitely be sure to pay attention to this section because this will make you look like a badass when you code later on just remember when we say JavaScript VM we just mean remix VM additionally whenever we deploy to the rink B test net just know that you should be deploying to the simpleia test net or whatever the most up-to-date testnet is or just don't deploy to the test net and just follow along we're going to modify this contract to make it a little bit more professional it's not going to be end to end amazing but it's going to be a little bit better and you'll see why in a minute so the first thing that we're going to do is we're looking we're going to look at some of these variables here in particular owner and minimum USD owner gets set one time in our contract here and then it never changes again minimum USD gets set one time even outside of the Constructor if we have variables that only get set one time we can actually use some tools and solidity to make them more gas efficient for now let's compile our fund me contract and then deploy it to a JavaScript virtual machine remember we can go ahead and deploy it right now however funding and withdrawing and doing any of the money stuff isn't going to work because again we don't have a chain link Network on our JavaScript VM so those aren't going to work so well but for what we're going to do right now we don't really care so much here's what we do care about you do care about how much gas this costs to actually send we do care about how much gas this costs to create right now creating this contract costs about 859 000 gas and we're going to add a couple of Tricks right now to bring this number down we're going to add some stuff back in in a bit which will bring it back up but for now we're going to learn some tricks to bring this number down the two tricks that we're going to learn are the constant keyword and the immutable keyword in their solidity there are two keywords that make it so that your variables can't be changed and those keywords are constant and immutable you can learn more about them in the solidity documentation if you assign a variable once outside of a function and then never change it so if if it's assigned at compile time you can go ahead and add this constant keyword we'll learn later about storage but when you add a constant keyword this minimum USD no longer takes up a storage spot and is much easier to read to so now we recompile this and we deploy this new contract let's see if we saved any gas if you look in the transaction logs now we can grab the transaction cost of how much this costs to deploy let's compare it to how much it was before wow we saved almost 19 000 gas that's almost as much gas as it cost to send ethereum typically constant variables have a different naming convention typically you'll want to do them all caps like Min Imam underscore USD so all caps with underscores so now let's just find minimum USD and replace that with all caps as well with this interaction we know that this variable is a constant variable and it's much cheaper to read from now if we go ahead compile this and redeploy in our fundry contract even though this is a view function remember view functions do have gas costs when when called by a contract as a constant variable we can see the execution cost of this variable 21 415 gas so let's put a little note right underneath it if we remove the constant variable we delete this contract we redeploy click fund me and we hit minimum USD again we can now see how much gas this was cost if it wasn't a constant variable we can see the gas cost did indeed go up now on chains that are much cheaper this gas difference probably won't make it that much of a difference but on more expensive chains like ethereum this is going to make a big difference for example on ethereum we can actually see current gas prices on ethereum here we see the current gas price of ethereum is about 141 gray so we'll go to our converter right away we'll copy the way price times this we'll get the gas price of calling our minimum USD which is this number here which if we put back in our ethereum unit converter we can see it costs this much gas and if we times that by the approximate current price of ethereum which is around three thousand dollars calling minimum USD as a constant is going to cost nine dollars calling this that is at a non-constant is going to cost almost an entire dollar more you you can see how all these little gas optimization tricks are going to make your life a lot better so let's keep this constant keyword in here we'll learn more about constant and storage in later sections of this course now as you're just getting started with this course and with solidity do not struggle and do not worry about making your contracts as gas efficient as possible in the beginning and especially right now just write your contracts as best as you can once you get really good at gas and once you get much later on in the course and much more advanced with solidity then you can start going back and working on gas optimizations but do not let gas optimizations hold you back or if you start stressing over it just let it go don't worry about it and just write your code as best you can so long story short do not stress about gas organizations right now now another variable we only set one time is going to be our owner variable owner equals message.sender we set this one time in the Constructor variables that we set one time but outside of the same line that they're declared and we set them for example in the Constructor we can Mark as immutable typically a good convention for marking immutable variables is going to be doing I underscore so that we know that these are immutable variables they have very similar gas savings to the constant keyword owner of course is a variable that we can't set on the line here because inside the global scope there's no function going on however inside functions because inside the global scope there's going to be no message.sender there's only going to be a message.cender when we're inside of a function so inside here we might say I owner equals mesh dot sender and then of course we'll scroll down and we'll change this require only owner now equals I owner now if we compile that and deploy it we can see how much gas we can see how much gas calling ioner is going to be by with the immutableness we get 21 508 which we'll go ahead and copy for now and we'll put right here we'll say immutable now if we remove the immutable keyword let's close this redeploy now if we scroll down to ioner scroll up the logs we go down to the call scroll down we see the execution cost was much more so we'll do the backslash paste that in here gas or non-immutable so you want to keep some of these tricks in mind when it comes to storing variables the reason that these two save gas is because instead of storing these variables inside of a storage slot we actually store them directly into the bytecode of the contract and like I said don't worry too much about that for now later on in the course we'll teach you more about storage and a lot of this low level stuff that comes with these contracts but for now just know that these exist and they're nice gas Savers if you're only setting your variables once all right great so we've just made our contract a little bit more gas efficient little gas efficiency improvements are going to be Concepts I sprinkle throughout this course and when we get to the more advanced section I'm going to break down exactly what's going on and why all these gas efficiencies exist and what's going on behind the scenes for these gas efficiencies to occur it's a little bit in the weeds which is why I'm going to gloss over it right now so if it's confusing don't worry I wouldn't let these gas efficiencies be the thing that slow you down awesome so we have these two gas optimizations how else can we make this contract a little bit more gas efficient well one of the ways we can make this more gas efficient is by updating our requires right now with our require statement we actually have to store this sender is not an owner as a string array every single one of these characters in this error log needs to get stored individually this the string may not seem very big but it's a lot bigger than the alternative with what we can do as of 0.8.4 of solidity you can now actually do custom errors for our reverts we declare them at the top and then use ifs instead of require and then just add a revert statements this ends up saving a lot of gas since we just call the error code as opposed to calling the entire string associated with the error so for example with our required down here and with actually with all of our requires what we could do is instead of having this required we could create a custom error so at the top what we could do is we could say error not owner and you'll notice that this is actually outside of the contract here now what we can do is we can take this error not owner scroll down into our only owner instead of doing a require we'll do an if statement we'll say if message dot sender is not ioner then we're going to go ahead and revert with a not owner error this ends up saving us a lot of gas since we don't have to store and emit this long string here now in a lot of code today you'll still see require a lot of places because these these custom errors are pretty new in solidity so you'll want to get used to writing it both ways I wouldn't be surprised if in the future the Syntax for some of these errors looks like this so that it's more readable but for now if you want to do a more gas efficient way than requires you can use something like this we could update all of our requires here for these custom errors but for now I'm going to leave both in just to show you the differences this revert keyword does the exact same thing that require does without the conditional beforehand so you can actually go ahead and revert any transaction or any function call in the middle of the function call now let's look at one more way to improve this contract sometimes people will try to interact with the contract that takes ethereum or the native blockchain token without actually going through the required function calls that that are needed for example on a JavaScript evm here I could actually try to send this contract money without calling the fund function however if I were to do that what would happen would our fund function get triggered no it wouldn't get triggered we wouldn't keep track of that funder we wouldn't have that person's information updated in this contract so if later on we want to give rewards or something we wouldn't know about those funders and this wouldn't be great because people would send our contract money without us ever knowing and we wouldn't be able to give them any credit or anything additionally maybe they called the wrong function by accident and they they weren't using metamask and they weren't using a tool to tell them hey this transaction is likely going to fail so what can we do in this case what happens if someone sends this contract eth without calling the fund function right now if we were to send this fund me contract eth it would just go to the contract right and this contract just wouldn't keep track of those people but there's actually a way for when people send money to this contract or people call a function that doesn't exist for us to still trigger some code and now there are two special functions in solidity one is called receive and one is called the fallback now in solidity there are actually a number of special functions and two of these special functions are the receive special function and the fallback special function a contract can have at most one receive function declared using the receive external payable without the function keyword this function cannot have arguments cannot return anything it must have external visibility and payable State mutability what does that actually mean and or look like well let's create a separate contract to go ahead and play with this so in here we're going to create a new file called fallback example.soul and in here we're going to add our basic pieces SPX license identifier MIT pragma solidity 0.8.7 and we'll do contract fallback example like so feel free to pause the video to catch up to this point once we create our fallback contract let's create a variable to go ahead and try to test this function we'll create a un256 public result variable and let's create this receive function so we'll say receive it's going to be an external payable function we don't add the function keyword for receive since solidity knows that receive is a special function whenever we send ethereum or make a transaction to this contract now as long as there's no data associated with the transaction this receive function will get triggered what we can do in here now is we can say result equals one so let's go ahead and test this out on the JavaScript virtual machine if we compile this so we're going to go ahead and compile this we'll go deploy it on the JavaScript virtual machine we're going to deploy our fallback example and we're going to see what result is initialized to since we haven't set anything for result result of course is initialized to zero but what if we were to send this contract some ethereum well receive would go ahead and be triggered here we can actually send this contract some ethereum directly by working with this low-level interactions bit here don't worry about what call data means for now just know that this area down here is a way we can send and work with different functions and we can add parameters to this transaction by going up here and adjusting the variables up here if we keep call data blank it'll be the same as if we were in metamask and just hitting send and then choosing this contract address again we can actually use metamask since this is a virtual machine and not one of the networks that we're working with so if I do for example I change this value to one way and I keep everything blank and I go ahead and hit this transaction button which again is going to be the same as hitting this send button but only sending one way what do you think will happen well let's try it we can see in the log area that we did indeed send a transaction and if you look at the description here you can even see it says from so and so to fallback example dot receive it looks like it called our receive function which should have updated our result to one so if we hit result now we can indeed see that result has been updated to the value of one well let's go ahead and delete this let's deploy this contract again and this time let's have value be zero does receive get triggered this time so let's pull this down let's hit transact let's leave the call data blank we'll leave value at zero so this will be the same as if we had sent zero ethereum to this contract let's hit transact looks like that went through do you think result is going to be one or zero you thought one you were correct a receive function gets triggered anytime we send a transaction to this contract now and we don't specify a function and we keep the call data blank when working with any other contract like fund me for example when we call one of these functions we're actually just populating this call data bit with certain data that points to one of these functions up here if we send a transaction and we add data to it we could actually call one of these functions now let's try this again let's delete the contract again we'll redeploy open this up result is currently zero receive like I said only is triggered if our call data to it is blank now this time if I add some call data to this transaction you think receive will be triggered this time if we hit transact and remix we actually get a pop-up saying fallback function is not defined this is because whenever data is sent with a transaction solidity says oh well since you're sending data you're not looking for receive you're looking for some function so let me look for that function for you I don't see any function that matches the 0x00 so I'm going to look for your fallback Function Remix is smart enough to know that we don't have a fallback function the second special function in solidity is called the fallback function this is very similar to the receive function except for the fact that it can work even when data is sent along with transaction so our fallback will look something like this fall back external payable result equals two fallback is another one of these functions where we're not going to put the function selector because solidity is expecting this actually you're already familiar with one other special function we go back to our fund me our Constructor for example is another type of special function there's no function keyword solidity knows that this Constructor is immediately called when we deploy this contract so now we have our fallback function let's go ahead and compile this what's the leader old contract let's go ahead and deploy this new contract click here we hit result we do indeed see it's set to zero now if I add this zero X zero zero and I send this and I hit transact this is equivalent to calling our contract here without a valid function so our contract goes hmm I don't recognize what you're trying to tell me here I'm going to refer you to our fallback now if we hit result we see that it's been updated to two if we take this away solidity will go hmm it looks like you're trying to send some ethereum or call this contract without specifying what you want to do well I have a receive function so I'm just going to go ahead and forward you to that so if we call transact we hit result we see it updates back to one add some data hit transact we see it up gets to two no data updates to one solidity by example.org has a wonderful little chart that we can use to figure out whether or not receive is going to get triggered or fallback is going to get triggered if it is empty and there's a receive function it'll call the receive function if it is data and there's no receive function it'll just go to the fallback function and if there's no fallback function it might just it might error out so this is a lot of really fantastic information here how can we apply this to our fund me contract here well what we can do now in our fund me is we can add these fallback and receive functions just in case somebody actually sends this contract money instead of calling the fund function correctly so what we can do is let's add a receive function so if somebody accidentally sends it money we can still process the transaction we'll say receive is going to be external payable and we'll just have the receive function call fund and we'll do the same thing with our fallback function we'll have fallback external payable we'll just have it automatically call fund now if somebody accidentally sends this money without calling our fund function it'll still automatically route them over to the fund function this means too that if somebody doesn't send us enough funding it'll that transaction will still get reverted so let's go ahead now and let's switch to rank B to test this on a real test net I'm on rink B in my metamask let's switch over to injected web3 and we'll scroll down we'll choose our fund me contract and we'll go ahead and deploy this meta mask pops up I'm going to go ahead and confirm the transaction and we see our fund me contract here right now we can see the own we can see I'm the owner we can see minimum USD and we can see of course that it's a blank contract and there's nothing funded in here if we copy the address and then go to rank B etherscan paste the address in we can see that there's no ether in here and the only transaction associated with this has been the contract creation we saw what happened before when we hit the fund function our contract was updated with a new balance and that funder was added to our array let's see what happens now if we just directly send this contract money without calling the fund function here if we did this right our receive function should pick it up and kick the transaction over to fund so let's copy this address we'll go to our metamask we'll hit send Casey address in here with 0.02 each again because this should be more than the minimum amount in USD we'll hit next I'll go ahead and confirm this and after a slight delay if we did this right we should see this transaction having called the fund function here now that our transaction has gone through and after a brief delay and waiting for etherscan to update we do indeed see that our balance has updated to 0.02 which of course this makes sense and we see in the transactions list here we see that this actually went through as a TR as a transfer instead of what's calling the fund function let's go ahead and remix and see if our funders was updated it looks like it was at the zeroth position of funders we have our address if we take our address and pop it into address to amount funded we can see exactly how much we had funded this means that since we added this receive function in here we automatically had to call our fund function up here so awesome work we were able to add a receive function to help people who accidentally call the wrong function or accidentally send this contract money instead of correctly calling the fund function now if they had directly called the fund function it would have cost them a little bit less gas but at least this time they're going to get credit and add it to our funders array for having sent our funding contract money we've even learned some Advanced sections of solidity and this is going to be the last time that we start our projects in remix we're going to be moving over to a code editor now where we can get even more advanced with our solidity and our setups for the most part you've gone over the vast majority of solidity Basics there are a number of things that we still haven't learned yet and the reason we haven't gone into them is because they get more advanced and understanding the real use doesn't really make too much sense until a little bit later some of the things that we're going to go over are enums events try catch function selectors ABI encoding hashing and then you will slash and then you will slash assembly however if you've gotten this far you probably can read most solidity code and understand what's going on which is absolutely fantastic so you should give yourself a huge round of applause for getting this far and doing this let's do a quick summary of this more advanced section and make sure we understand what we learned in solidity there are a couple special functions some of them are receive fallback and Constructor these functions don't need to have the function keyword and instead can just be called like so receive and fall back are two very special functions if data is sent with a transaction and no function was specified the transaction will default to the fallback function if that fallback function exists if data is empty and there's a receive function it'll call the receive function there are a couple of keywords that can help us save gas in the long run some of those keywords are going to be constant and immutable constant and immutable are for variables that can only be declared and updated once once we say minimum USD is 50 times 1e18 this minimum USD can never be changed again and this helps us save gas immutable can also save gas similar to constant however immutable variables can be declared one time in the Constructor once an immutable variable is declared it can't be changed later on in fact if we even tried to update an immutable variable or constant variable and we compiled our compiler would give us an error saying can't write to immutable here or if we tried to change a constant variable our compiler would say hey you can't assign to a constant variable sorry in remix if we want to send ether to a contract that's on the JavaScript virtual machine we can deploy that contract and then in the contract we can just hit the transact button without any call data and update the value that we send with the transaction if call data is blank it'll trigger a receive function if it exists but if there's data that doesn't specify any of the other functions it'll trigger the fallback function all right my code's done time to ship it delivery free boxed you dog water zero earn copr in the age of AI debugging and getting into software engineering has never been easier you're the exact six steps you need to take to unblock yourself from any software engineering area you'll ever get number one Tinker try to pinpoint your error you can usually use an AI buddy to help you out here pin Parts in your air will potentially solve your problem before you even go into an AI and allow you to craft a better question to an AI once you've pinpointed the issue you can move to step two which is ask your AI you can use chat should be T find Bing's AI or if you want to get wrong answers Google's barred there are six principles to prompt engineering so you can get the best out of your AI write clear and Specific Instructions give as much context as possible use the limiters to clearly indicate distinct parts of the input and especially look out for something called hallucinations hallucinations are when your AI gives you an output that it thinks is right but is completely wrong for example if I write about writing solidity and varying tests and Foundry ubt disgraces Us by saying with the mpam install it from open Zeppelin these can be tough to spot but once you try it out you'll see it doesn't work and finally you want to understand the limitations of the AI you're working with and iterate constantly large learning language models are trained on human conversations so you can interact with them as if you're having a conversation but it's important to know the limitations of these AIS as most AIS have a limit on how many tokens or words they keep in context at one time AI is trained off human language so if you're good at asking other humans questions you'll probably be good at asking robots questions too asking questions is a skill so keep practicing I've got a link in the description to learn.deeplearning.ai which is a free course to help software Engineers be better prompt Engineers now when the AIS can't help you you'll have to go back to the old standbys actually doing work yourself and one of the first pieces of work is reading the documentation you probably should have done this already however we can still use Chad gbt because a strategy that I constantly use is I'll copy paste sections of the documentation add to BTS context and say something like the above or the docs for Tool X based on those docs how do I do why so Google might be crying because Chad GPT is eating its lunch but Google still has what AI doesn't have the entire internet previously anytime I ran to an issue I prayed someone else had run into it before I made a post on it so I could Google search that exact issue there's a new tool called find that combines web search with AI as it does a web search and it crawls through all the data of the sites reads them all and then gives you an answer based off of what it reads 5. asking a form sometimes the information just isn't out there and we need to ask human beings we always want to ask her a question on a webbed indexed Forum like stack exchange stack Overflow irana or Reddit this way web crawlers and more likely AIS can scrape the data from these sites and learn from us that way the next time we have this question we can get our answers quickly asking on Discord and Twitter because your knowledge will get lost to the unsearchable conversations that Discord is and web crawlers don't index them the super secret alpha is to ask a question on stack exchange and then post your stack exchange link to Discord you should 100 always ask your questions and format them with markdown and if you're not sure how to do markdown you can ask chat WT to help you format your questions and markdown ask on the support GitHub or forum is the tool you're working on open source awesome ask a well-formanded question on their git page not open source never use that tool again this is how we improve our tools by creating issues engaging with each other and even taking on issues and contributing to the open source code and then finally iterate do all these same steps over again and as always keep hopping through the code and until next time stay riveting my fellow blockchain ears foreign [Music] fantastic so now we know a little bit more about the different tools and techniques we can use when we do in fact get stuck we knew something like chat TBT forums ask questions we obviously want to Google search and especially for this course you definitely want to make sure you use the discussions Channel but I wanted to give you some very specific tips about working with this course number one limit yourself triaging to 15 or 20 minutes for example if we're trying to compile our priceconverter.soul and maybe we forgot to add the address in here right and we're going to go ahead and compile and we're getting this error this is exactly one argument expected for explicit type conversion now this should be pretty obvious what the error is hey it's expecting one argument and we obviously just removed that argument but maybe you're having a really hard time and you're trying all this different stuff and you can't seem to figure it out limit yourself to 15 or 20 minutes we do not want to be messing around for so long that we can't figure something out right something like this would be very easy for us to compile copy this error go to chat gbt and say something like hey I'm getting an error compiling my solidity here is the error the three back ticks paste it in here like that three backticks is marked down and like we said in the video we want to use delimiters to clearly identify what is Code versus what is not oops and I hit and I hit enter whoops the daisy we're actually going to hit stop generating and we're gonna copy paste the question again now we're going to say here is my solidity it's wrong and then we'll copy the solidity line once again three back ticks we'll say solidity here we'll paste it in three black ticks to end it hit enter and it'll probably give us the answer here and turn off the error message suggests that you need to provide an address when using explicit type conversion so we go ah okay whoops we need to actually add an address in here gives us an example and we can go back to our code and you know paste that address in here and be good to go so limit self triage to 15 20 minutes that's gonna be the first step number two don't be afraid to ask AI but don't skip learning the purpose of this course is for you to be able to learn everything here AI is going to get things wrong and it's only the people who actually have learned what's going on under the hood who are going to be able to call out when AI gets something wrong when AI gets something wrong it does something called hallucinate and we talked a little bit about that in that AI video we just watched so hallucinations are when the AI makes something up that it thinks is right but it's completely wrong and that's something we absolutely need to watch out for when we're coding and when we're learning a perfect example of this is with Foundry which is a tool we're about to learn very soon in order for us to install Foundry we actually need to run this Command right get founder.sh it's the first thing that it tells us to do at the time of recording chat gbt has not been trained on The Foundry tool so if I ask it a question like I'd like to initialize a Foundry project with solidity can you show me how to do that and will that enter so the first sentence out the gate is wrong it's not aware of Foundry so it tried to guess what Foundry was and it got it wrong it is not a rust-paced framework for building blockchains at all and it is directly related to solidity so it's really important that we use AI to augment our learning but we don't skip over the learning with AI it's really good to bounce questions good ideas off of but in order for us to be even able to recognize when Foundry is hallucinating and making stuff up we need to have that knowledge ourselves simply of course use the forms web3education.dev will have a place for you to ask questions but in the meantime definitely be sure to use The Foundry full course discussions use this to your advantage and use this to help other people out who have questions this is a community project we're all going to be helping each other out learning number three Google the exact error if AI doesn't know the forums aren't no Google the exact error maybe somebody else has come across this error previously asked the question online and you can just Google it and then of course post your question in stack exchange or piranha and like we said in that AI video you want to use markdown and format your questions as best as possible so if you're unfamiliar with how to use is markdown if you're unfamiliar with how to format your questions again please be sure to ask chat gbt or some other AI how to best format your questions you can even simply say ask Chaturbate could you give me an example of a well-formatted stack Oracle question with Cod or code and it'll actually give us a really good formatted question so it gives us the question it formats the code for us it's using this with the three backticks that I showed you in order to get this code block here it's using three backticks and it's being very verbose in giving all the details of the question so be sure to ask questions like judge BT awesome again let's say we're in here compile get this error exactly one argument expected for explicit type conversion if we copy this error go to Google we paste just the error in we'll remove this our specific code looks like the first thing we get in Google is actually contract inheritance and we can see that this is actually exactly the error that we're getting it looks like this does actually explain the answer but it's a little bit confusing to understand here so maybe you would copy paste this into chat GPS context right there's a lot of creative ways you can approach debugging some of your issues obviously when you're out in the wild and you're actually building things yourself obviously the education site and the discussions channel of the GitHub repo the people in these aren't going to have context for the new creative thing that you're working on so I want you to get used to doing that methodology that we're teaching here right asking your AI buddy if your AI buddy doesn't know Googling asking questions on stack exchange ethereum asking questions on piranha piranha is arguably better because you're asking your questions in a decentralized location as opposed to a centralized server but I definitely want you to practice asking questions and go to piranha go to stack exchange make accounts for these so that when you do run into an issue because you will you'll know where to post them I'll encourage you to pause and post a question on one of these forms right now just so that you get used to it just so that you get out of your shell and you're going to suck at asking questions in the beginning and that's okay you will get better at asking questions as you continue with this course asking good questions is a skill in itself and if you learn how to ask very good questions that's the secret sauce to being amazing at AI prompting as well now the final step in all of this is actually going to be posting an issue on GitHub git a surprisingly incredibly important part of being a software engineer and being a developer in web3 is interacting with the community the vast majority of these tools that we're working with are going to be something called open source meaning that the code associated with them is actually available for anybody to view this tool Foundry that we're going to be working with is one such example and if you see it has this issues tab where there's just a ton of issues people are posting while using this tool this is how code is able to be improved and move forward all this code is public for people to use and work with and if there's a question that isn't answered you can post here and tell the developers of this tool hey I'm running into an issue maybe we should make a project Improvement I would say be very respectful with the way that you make issues you definitely want to do some searching on issues to make sure that nobody else has asked the question that you're working with and be sure to use these other resources first like piranha like stack exchange but in the future once you leave this core it's going to be incredibly important for you to participate in the ecosystem by making issues by making pull requests and actually improving some of the tools that we're going to be working with yourself even ethereum has GitHub and if there's any improvements that you want to make you can add an EIP to actually improve ethereum we'll talk about EIP some more later you can improve some of the clients that ethereum runs so interacting with each other is incredibly important and in fact if you don't have a GitHub we are going to get you set up with GitHub right now because GitHub is a platform that most developers use to share code and write code and interact with code in between each other so if you don't have a GitHub let's sign up right now and we're going to use the GitHub to create our own portfolios of all the different cool coding projects that we've created this way when you go to apply for a job you can say hey go look at my GitHub I've got all these really cool projects so we're going to make you a GitHub right now if you don't have an email you're going to need an email I made a burner account just for this video and I'm also going to walk you through formatting a question I know I'm belaboring the point here but I really really want to stress the importance of formatting these questions really well so we're actually going to show a clip from my past video so we're going to be using the full blockchain facility course JS but again for this video just be sure to use the GitHub repo associated with this course and not that other old GitHub repo all right let's watch this video in fact if you haven't already let's sign up for GitHub right now and let me walk you through formatting one of these questions because the better you format your questions the better chance you have of actually getting the answer and remember when asking questions on these forums when asking questions in these discussion communities people answer these questions out of the goodness of their heart right so if you don't get a response there's a chance that maybe nobody knows maybe it's your question isn't formatted very well and Etc so we're going to learn how to ask really good questions here and if you're new to blockchain do not skip this section okay this is going to be that piece that's going to give you the super power to unblock yourself from any coding issue you run into so don't skip this part be sure to follow along okay so if you don't have a GitHub already you do need an email to get started so I'm going to go ahead and sign in I made a burner account just for this video so what we're going to do we're going to go ahead and sign up GitHub enter your email and we hit create account they're going to send us an email so we're going to come back to our email we're going to get our launch code here paste it in answer a little bit of information we're going to choose the free version in fantastic we've now created a GitHub profile awesome so now we've created a GitHub so I'm actually using a GitHub that I used in my last course so that's why I have all these repositories over here now in order to create a new discussion over The Foundry full course f23 let's go over to the discussions tab we'll hit new discussion and we'll hit General and I'll say something like test discussion if you like feel free to say hello here start discussion now I'm going to show you a question that's formatted poorly and I want you to never ever ever ask a question like this and if you see somebody ask a question like this please help them format their question correctly hey why my code not be good and then just have it be the issue like this right what's wrong with this okay well why my code not be good obviously isn't clear what's going on the code isn't formatted well and even an AI would have a hard time answering this so let's fix this to be a little bit better as we know we want to copy the exact error we're getting so we'll say We'll copy the error we'll go back we'll say I am receiving this error we'll do the three little backticks paste our error right in here like that actually let's be even more explicit I'm receiving this error while compiling here's my code three backpicks we'll put solidity here copy the whole line that is erroring paste it in here and someone help me figure out what the issue is right and you see how this is much much better right we have these two blocks that pop up because we did the back text and the secret is that this is going to get you a much better answer from an AI as well right if we edit this we can copy the whole thing of markdown go over to chat jbt paste it in zoom out a little bit and we're going to get it actually an answer hey you're receiving this error because you're trying to create an instance of aggregated V interface without providing the necessary argument blah blah blah oh and it actually gives an outdated version of that but it helps us out here so ask format your questions correctly you will get better answers from both AIS and humans and I know I'm spending a long time on this but I really really need you to understand that the secret to prompt engineering is actually just being able to ask better formatted questions with human beings and it's better for interacting with human beings as well now the other thing that I did really well here was I only posted the relevant code to the error that I was getting what we see a lot of people do is they just copy paste their entire code base into here this is not very helpful as it's going to make somebody who wants to help you their job a lot harder if they have to read your entire code base right if we reply here this is so much more reading for them to do it's going to take them a lot longer and they might not actually read it and we didn't actually highlight this with the backticks and it goes the same thing with AI if you give your AI too much text it can't read all the text because again some of these AIS have limitations and how much text they can read so it's the exact same thing with working with human beings so feel free to take some time to either in Chaturbate tea or whatever AI you're using or in this test discussion forum to post some well-formatted questions and remember you can use AI to help you get those formatted questions in markdown be sure to ask chapter BT to give you the output in markdown so if you haven't worked with markdown before that's okay you'll learn as you go along but one of the biggest differences especially when working with markdown that's going to make your code so much more readable and I 100 need you to always do this whenever you ask questions is you see how this got like some syntax text highlighting in this above question well if we go click edit again we can actually see why up here we did those three back ticks and then we typed the word solidity when you do these three back ticks in your questions if you type the word or you type the language next to the first three back ticks it'll actually add some formatting to make it more readable so if we scroll down to this poorly formatted question you can see that this is just all white and like impossible to read it would be at least slightly better if we hit edit and next the three back ticks we wrote solidity if this was like Java code or python code we could write python or Java or whatever but since this is solidity we'll write solidity I'll hit update and you can see that it is substantially nicer and it is much more readable now so even though this is still a bad question obviously because we just copy pasted all of our code it's at least much more readable so anytime you do a code block like this of any of your code absolutely 100 be sure to do the three back ticks and then the language of the block of code so just remember this there are no bad questions but there are poorly formatted questions make your questions well formatted for both human beings and for AI and then most importantly be sure to join these forums and like I said a hundred times interact with these people interact and help and give back the more people that use and are good at the tool that you're working with the more likely that they're going to help you sometime in the future and this is how I've met so many people in the industry is just giving back and interacting with other people so whenever you ask a question especially in the beginning because in the beginning you're gonna have more questions than not be sure to at least try to go back and answer a question think of it as question and answer debt every time you answer a question make a little mental note and say ah in the future I need to at least try to answer one of somebody else's questions this is how we grow and move so much faster now this next piece that I'm going to show you is actually outside of this course but it's a resource that I wanted to show you in case after this course is done you want more resources to learn about ethereum and learn about the ebn it's with my good friend Austin who's going to show you speedrun ethereum and definitely something you might want to check out after taking this course what's up I'm Austin Griffin happy bow tie Friday I want to show you the best way to get started building on ethereum it's speedrun ethereum.com it'll teach you how and why you'll you'll build a simple nft you'll build a decentralized staking app you'll learn that the superpower of ethereum is allowing you the Builder to create a simple set of rules where an adversarial group of people can coordinate financially you'll build a token vendor you'll build a dice game and you'll learn about Randomness on chain and where it works and where it doesn't and what you can do about that you'll learn about a DEX and what a hyper structure is and how people can use liquidity to swap you'll learn about State Channel and scalable ability and sign messages and multi-sig wallets and account abstraction and SVG nfts lots of fun stuff along the way like I said not just the how but the why go to speedrun ethereum.com and get started today uh it'll have you do a quick video uh and then it says to use scaffold eat to start tinkering I want to show you how to do that first of all all this stuff is open source uh it's all ungated and open source just get in and get get in get learning okay but the scaffoldee thing uh scaffoldeeth is a great way to Tinker uh with solidity and kind of get your your your bearings right so let me show scaffolding too just for a second if we zoom in I've already kind of gone through the whole readme and installed everything I want to show this right here here's a smart contract and I have my front end that's uh Auto adapting to the smart contract and so uh when in speedrun ethereum it tells you to Tinker with each one of these Concepts let's just go look at mappings structs or modifiers let's just go look at a mapping and let's grab a mapping right and let's copy and paste it right into our smart contract so something called my map I don't even know what it is right and then we yarn deploy and we'll see that my map show up over here and this is kind of the feedback loop I want you to get into where you can grab some stuff from solidity by example paste it into your smart contract deploy it locally and then Tinker with it there's my my map let's see what vitalik's balance is in my map it's zero oh okay so check out speed run ethereum check out scaffoldeth get started building cool things on ethereum today happy bow tie Friday parts foreign wanted to show you all of these debugging things right now is because we are about to move off of remix remix has been this phenomenal IDE or this phenomenal integrated development environment that allows us to quickly try things and quickly deploy things but we're actually going to move off of remix to a more professional setup and we're going to be using a modern set of tools that most of the rest of the development Community also works with and I'm going to tell you this right now often installing these new tools and often just getting your local development environment set up not using remix or not using what's called a cloud IDE can often be the actually most difficult step in this whole process so I want you to be absolutely Vigilant in using all of the resources that I just showed you using the chat using chat gbt using piranha using stack exchange eth using web3education.dev once we get this up and live be sure to use these tools and don't let installing these slow you down because in my mind installing these can be the hardest part of this whole course and it's okay things might not work the first time and that's okay just be sure to ask questions and be very specific with the errors that you're seeing and installing these things that's what we're going to learn how to do right now so remix is a phenomenal tool but now we're going to move over to this more professional setup called Foundry Foundry is one of the most popular smart contract development Frameworks similar to hard hat or brownie if you're familiar with those and it's known specifically for its speed Foundry is easily the fastest to work with smart contract development framework one of the unique aspects about Foundry is that whereas hard hat is Javascript based brownie is python base Foundry is completely solidity based so we don't have to learn any other programming languages other than solidity to work with Foundry and similar to everything that we've been doing so far all of the code for all of our Foundry products are going to be in the GitHub repo associated with however the documentation for Foundry I think is also phenomenal so be sure to use this as you code along and something very interesting that I really love to do most of these pages are pretty small so even if your AI isn't trained off of Foundry which as a recording it's not what we can do is something called context injection when we have issues so we can copy the entire page of documentation we can say I'd like to start I'd like to install Foundry here are the documentations or installation how can I do it do the three back ticks paste the whole thing in there and by giving our AIS the documentation for working with Foundry it's actually going to give us outputs to install Foundry so this is a methodology you'll see me use from time to time this context injection you can find more information in the GitHub repo once again associated with this course on installation and setup Mac OS and this would be Linux and then we have some Windows setup stuff down here we're going to go over how to set up all the important things for this course so be sure to use this as a reference now a great question you might be asking is well what's even the purpose of Foundry why do we need to use this other tool remix is working great well in remix you notice that we did a lot of stuff manually like I came in here I had to go to compile maybe I want to test something out I would go deploy it I got to put a price feed in here or Price feed in here deploy okay does the get version work something's wrong with my Git Version okay my oh I owner works okay minimum USD works oh crap I gotta go make some little change here you know maybe I want get version to actually return you know seven plus two or seven plus one now I gotta go you know delete this I gotta go redeploy I'm gonna go click this I'm gonna go down I gotta click ever and then if I have a hundred things that I change testing all this is going to take a really long time and anytime you do something anytime us as human beings changes our code in some way there's a chance that we break something and remember these smart contracts are immutable so if we break something if we mess something up that's really bad because that mess up will be permanent on the blockchain so we want a framework that helps us deploy our smart contracts test our smart contracts and interact with them in a much more programmatic way rather than we having to manually click around right if I change 10 functions and I wanted to test they all work I would have to go click 10 buttons that's ridiculous in Foundry we can do all of that in one command or one button so that's why we're going to be using Foundry here and I'm so excited for you to be using this Foundry tool because like I said it's the fastest smart contract development framework out there right now but additionally it's also the framework of choice for smart contract security engineers and Auditors and I expect more and more projects in the future to be built in Foundry so incredibly excited for you here now for the rest of the course I'm going to be using a code editor called Visual Studio code code this is one of the most powerful code editors on the planet and if you've already got it set up feel free to go ahead and skip this part you'll often hear people refer to this as vs code or Visual Studio code or just Visual Studio however it's important to note that Visual Studio code this is different than Visual Studio which you might see look like this so visual studio code is what you want not Visual Studio Visual Studio is a different application make sure you're on Visual Studio code now if you choose so and you're a total Hardo you can absolutely work just with your terminal or just with Powershell or just with whatever coding environment that you want like atom or Sublime however for us we're going to be working with Visual Studio code and I'm going to be going through setting up visual studio code the way that I like to set it up you can absolutely set it up whatever way that you feel comfortable now we're going to go through three different installation processes and pick the one that's most appropriate for you the first one is going to be for mac and Linux users the second one is going to be for Windows users and then our third one is going to be a last ditch effort if for whatever reason you can't get Windows or Linux or the Mac instructions to work we're going to use a git pod installation now I highly highly recommend that you try to get everything working locally without using gitpod however if for whatever reason you can't get those installation pieces to work we will have gitpot instructions for all of the repos that we work with here but to get started we'll start with the mac and Linux installation instructions the first thing you're going to want to do is download the Mac or if you're working with Linux download the Linux installation of Visual Studio code once you have it installed it'll look a little something like this and if it's a fresh installation it'll even give you some tips and tools to actually get started if you've never worked with Visual Studio code before I highly recommend going through any get started or getting instructions tips that come with opening Visual Studio code additionally we have a visual studio code crash course in the GitHub repo associated with this course now one of the awesome things about Visual Studio code is it has this thing called terminals which are command line prompts that allow us to run scripts basically it's where we're going to be running all of our code the way we can open up the terminal is we can go ahead and hit terminal and select new terminal it'll get something like this now you might have bash or zch or some other type of shell the type that you have doesn't really matter because on Mac and Linux it's going to be Linux based and like I said sometimes installing this can be the hardest part of this entire course so so don't get discouraged and please use stack overflow stack exchange ethereum and the GitHub repo to move past any issues you run into now if you're on Mac or Linux you can actually hit control back tick to actually toggle your terminal mode this will pull the terminal up and down for you getting familiar with keyboard shortcuts will actually make your life a lot easier because you'll be able to move around Visual Studio code much more effectively we have a link to a list of keyboard shortcuts additionally in the GitHub repository associated with this section as we move along I'll give tip on different keyboard shortcuts that you can optionally use otherwise you can just go ahead and click as well you can click the trash can to delete the terminal go back up terminal new terminal to pop it back up now the next thing that we're going to need a little bit later we're not going to need it for this section but it's good to install it now is going to be git we will have links to the installation instructions in the GitHub repository installing git on Linux you're going to use one of these two commands and on Mac OS if you just type git on the command line it should go ahead and prompt you to install it so if we're back in our command line and we just type Git it should prompt you to go ahead and install it and if you do git dash dash version should get something that looks like this you can also use a Mac OS git installer by clicking this link here and running through the installation process alright now that you have git and visual studio code installed we can continue on to the next section awesome if you're not planning on using Windows or git pod feel free to skip the next two sections and for this Windows setup we're going to be learning about a tool called WSL and to introduce that to us we have my friend basili who has done amazing work helping me on some of my past courses and he's going to be helping us here today so take it away this tutorial is going to be useful for any Windows version from Windows 10 and above let's get started by installing our code editor in this case Visual Studio code so let's type BS code on the browser and hit enter black or version for Windows like the destination and click save and the installation process is going to be the same as any other program so let's select an accept the agreement click next add code to the path create a desktop icon next and install this shouldn't take a lot and this is how the editor is going to look like the first time we install it we can customize the theme create shortcuts and sync with another devices and if you want to go deep into Visual Studio code well I suggest you to pause the video for a moment and go through all these steps one by one now we could 100 go forward and install the rest of our Tools in a Windows environment but basili is actually going to explain to us that the windows environment isn't really actually the best way in the best place to do our installations Microsoft has definitely increased their support for developers in the recent years but when it comes to Smart contract development there is a better option to consider using WSL the windows subsystem for Linux trust me is a game changer you see a smart contract development often involves working with tools and utilities that are commonly found on Unix based environments well Windows has come a long way in accommodating developers there can still be some challenges when it comes to running certain command line tools and setting up the right development environment not mentioning that if you want your code to run phone on any machine using a unit's bait system Mac and Linux is better for your developer needs here is where WSL shines by installing a Linux distribution through WSL you can access to a full-fledged unix-like console right on your Windows machine and don't worry you don't need to be a hacker or wear a hoodie to make it happen is actually quite simple so let's do it for that let's open the windows terminal this is a pre-installed application on Windows 11. and something you can easily install through the Microsoft store on Windows 10 just type terminal and here you are going to have the windows one so let's install WSL by typing WSL minus minions in that hit enter this is going to trigger us a admin operation and installation is going to start and here we just have to wait until the process finishes once the process is done this will require you to reboot your operating system so I'll see you on a second once rebooted this is going to automatically open this terminal and the installation process is going to proceed now you have to input a new Unix username for me it's going to be Chrome bar and then you have to set up your password don't worry the password is always hidden on Linux operating systems and as this is that we already have an operating Linux terminal inside or Windows machine so we can now close this now we open a new instance on the Windows terminal we click here on this drop down arrow we can have now this Ubuntu shell from which we are going to style all the development requirements we are going to use during the course so the next step is to make Visual Studio code compatible with WSL so let's do that let's go to the extensions tab let's search for remote development and install all these extensions this is going to automatically install the compatibility to connect our Visual Studio code with WSL and as you can see over here I have a new icon called open a remote window by click here I can directly connect to WSL however there is an easy way to do this let's close Visual Studio code and on the Linux terminal let's just create a new folder for example M cadir solidity course let's move to that folder and now let's open Visual Studio code inside this folder just type code dot hit enter this is going to install the latest server for WSL on Visual Studio code and once this is done we are going to have a new instance of Visual Studio code but using WSL let's just trust the outdoors and as you can see here I'm getting this WSL Ubuntu Banner over here and it's because I already connected this with the Linux instance so you have two options from now on you can start using just the windows terminal to execute all the things we are going to need or you can use the integrated terminal which comes with Visual Studio code just go to terminal new terminal and now we are going to have a terminal using the exact same W cell instance so we can start using sudo commands for example sudo apt update and this is going to work properly now just take something in consideration maybe you are going to develop all your projects on a folder called development inside your documents on Windows and you can do so however if you take a look to the Linux terminal with the ls command as you can see here you are going to have just access to the local files and folders inside of the W cell instance and I highly recommend you to do that because of course you can do something like type in the address of your local development folders and use the projects from here by the communication from the WSL console and the local Windows files are actually quite slow so I prefer just to keep Simple and use all the folders inside W cell remember that you have to just manage simple commands such as LS to know all the folders on the current directory and CD to navigate through them now if you go back to your vs code and you hit terminal new terminal and open up a terminal we're going to want to then install git we're not going to use git for this lesson however we will definitely be using it in the future save kits installed type git dash dash version sometimes Linux will automatically come with get installed and you'll see something output like this however if you are the ones who decided to keep using power shell and just Windows instead of WSL don't forget to go to the official git page and install it for Windows the process is the same as we did before really a standard just the common sequence of clicking next and of course please to read the license agreement and now if you've made it this far you should be able to follow along with the mac and Linux constructions as if you're running on a Mac analytics even though you're running on a Windows just be sure that whenever you're in your vs code you take a look at the bottom left and make sure you're on WSL Ubuntu like I said before if you want to run in Powershell or in a Windows environment you're more than free to do so but like I said if you've made it this far huge congratulations awesome work and then finally our last setup is going to be using a tool called gitpod starting from lesson five the lesson that we're on right now ether's JS simple storage all of our code repos are going to come with a button and the repo scroll down they'll come with this open in git pod button now gitpod is a cloud development environment where you can actually run your code on a remote server it's kind of similar to remix IDE but it allows you to run Visual Studio code in the browser or connected to another server this is good because then you don't have to do any installation on anything since all the tools that you want to use are just going to be running on this remote server this has its downsides though obviously since you'll only be able to code if gitpod is up and working for you additionally when it comes to private Keys you absolutely do not want to run any code with a private key that has real money in it on GitHub why well once again since you're running your scripts on a remote server those servers have access to your private keys but since you've pinky promised that you for this course you're not going to be using a metamask or a private key with actual money in it it should be fine the other downside is that these often cost money to use and get pod isn't free but it's an option if you absolutely cannot get any of the installation working so if you go ahead and you hit this opening get pod button you'll get a welcome to gitpod showing up we're going to go ahead and continue with GitHub since you've signed up for GitHub here you'll want to go ahead and authorize gitpod and it'll go ahead and start creating this workspace for you and you'll notice it looks exactly like Visual Studio code since I opened the repo up in gitpod it came with all the code and you can even open this workspace up in vs code desktop so this is might be a little bit confusing but basically you can run off of gitpod using your local Visual Studio code and if you see gitpod here that's how you know that you're running off of gitpod if you see this pop-up do you want to open this workspace in vs code desktop you can hit open and it'll ask you if you want to open up visual studio code which I'm going to go ahead and hit yes and you'll get something that looks like this on your Visual Studio code it'll tell you that it wants to install the gitpod extension and then open that gitpod URL so you can go ahead and install it reload window and open and it's going to go ahead and start connecting to our the gitpod workspace and this is going to be the same as running gitpod in the browser here or you can also do it manually by hitting the git pod in the bottom left and then type in open in vs code and then you should be able to run an individual Studio code for now I'm going to recommend that if you're using gitpod just stay in the browser just so that you know okay I am running this on a remote server and just as a reminder for you that you're not actually locally developing and hopefully this will be a trigger to not actually put any special private keys or anything like that but you can make workspaces you can make new folders and you should be able to run all the commands on here as if you were running locally with Visual Studio code to open up the terminal you can hit this little bar in the top left go to terminal your terminal or use control tilde exact same as Mac OS and Linux keyboard shortcuts to create a new folder we can change directory CD dot dot mkdir new folder mkdir makes make directory called new folder and then we're going to change our directory into new folder and hit enter and now we're in that new folder for each section you can either open up the entire source code right into gitpod or you can create a new folder for each section yourself and start from blank and then you just type code period and you'd be in a brand new folder and if you're using Windows this should say WSL or Ubuntu or something like that and if you have all that that means we're ready to go now a quick note something that you'll see me do a lot and you can do this as well oftentimes when my terminal gets really really big or there's a ton of commands in here it gets a little bit overwhelming for me so one thing that you can do is you can type clear and hit enter to clear it or what you can do is you can hit command K if you're on a Mac or control K if you're on a Linux or a Windows and it's one of my favorite keyboard shortcuts that I use all the time additionally the trash can and the X here are very different if I go do a couple of enters here and we're down here if I hit the X here and then pull my terminal back up by doing the toggle or by doing terminal new terminal you'll see all those lines are still here but if I hit the trash can and then pull the terminal back up you'll see it actually refreshes mine is a special command that prints the fount trashing your terminal is basically deleting whatever is running in it and the x is just hiding it and a setting control tilde or toggling our terminal or whatever command it is on your environment that's equivalent to hitting the hide not the trash so if we want to remove and start a terminal over we hit the trash can and then we pull it back up so after we have that set up the next thing that we're going to want to install is actually Foundry itself in The Foundry book you can find this in the installation tab or you can go to get foundry.sh and it'll have this command that you can actually just go ahead and copy Windows users we're going to teach you how to do it the Linux or Mac OS way so just stay tuned so we're going to go ahead and copy this and run this command again we can go terminal new terminal and there are also some shortcuts to do this I'm just going to go ahead and paste this in here and hit enter you will need internet access for this to work because it's actually downloading Foundry from this website and let me just move this up zoom in a little bit here and you'll see me do this a lot in the terminal I'll type clear a lot to remove anything that's been coded or output in our terminal here or you'll also see me do command K like that which clears the screen when I'm typing the terminal you'll see me hit Ctrl w a lot which actually removes the most recent block of code you've written you'll also see me do control U which deletes the entire line so I'm going to use command C for copy and command V for paste a lot for those of you on Windows and Linux it might be control C and control V and if you're unfamiliar you can Google the keyboard shortcuts for for copy and pasting for Windows or Linux if you're on a Windows these keyboard shortcuts might be a little bit different we've got a list of keyboard shortcuts in the git repo associated with this course but if you've just run that curl command you'll see an output at the bottom down here that says something like detected your preferred shell is whatever your shell is here and added Foundry up to path run Source or simply start a new terminal session to use Foundry up and once you run that we can go ahead and run Foundry up and this will actually install and update Foundry to the latest version now whenever we want to install an update Foundry we can just run Foundry up like this it'll automatically install everything and Foundry comes with four components Forge cast Anvil and chisel well no we've installed these right if we run Forge dash dash version and we'll see an output that looks something like this now something important to note if you hit this trash can in the top right this actually kills the terminal it's different from the ax which is just close the panel if we close the panel and then we reopen our terminal by hitting terminal new terminal like this this actually creates a new terminal which we can kill like this but our old terminal is still up in order to actually delete this terminal we have to hit the trash can now you want to try this out now delete your terminal like we just did open up a new terminal and run Foundry up if this doesn't run we might have an issue with your path and you might need to add Foundry to your path if this is an issue that you have please make a discussion on the GitHub repo associated with this course or check please first check this lesson six of the GitHub repo associated with this course and we'll add some debugging to to make sure that that does indeed happen or if there is no debugging tips here make a discussion on the course but first be sure to check to see if that discussion already exists and you should be able to do Forge dash dash version however what can happen is if you trash can the terminal and open up a new terminal if you run Forge dash dash version now it might say Forge command not found this means that you have to re-run this command this Source command that Foundry told us to do if you're working with bash most of the time this bash RC file automatically gets loaded but sometimes it actually won't depending on what your setup is if this happens for you another thing that you can do is you can type CD and go to your home directory and type this line Echo source and then whatever boundary up told you to do double carrot dot bash profile and hit enter for example when we just ran Foundry separate here it gave us this command here the source userspatrick.rc that's what we would want to Echo however this will change depending on your terminal setup so look to the GitHub repository for the command that you should be using for your setup please make a discussions thread if one does not already exist what this will do is it'll add this command to the end of your bash profile make sure you do double like this otherwise you could override whatever's currently in your bash profile now I'm going to give you a command that if you screw up you could accidentally override some stuff if you've never used bash profile before you kind of don't have to worry about it though the other command you can run is something like this if you do get an issue we can just ask an AI something like how do I get my Dosh bash RC to load by default and there's a couple of different ways for this depending on what system using and what you're working with all I'm going to say though is if this happens to you if you run Forge dash dash version and instead of getting an output you get something like command not found ask an AI or come into the discussions of the channel and ask people run into this we'll build and start a discussion and if enough people have issues we'll create a new file here to help people debug that issue so what it looks like chat gbt does give a pretty good output of what we can do we can edit our bash RC our bash profile our profile Etc and work with it like that so if you run into that issue there's plenty of things we can do to fix it don't worry but if you're a little nervous feel free to use the discussions channel of the course got it okay great if you see an output like this you've done it right if you see an output like we don't know what you're doing you've done it wrong all right great and again installing these can be some of the hardest parts of this course so don't get discouraged if this doesn't work right away if it worked right away for you that's actually amazing now also the control backtick shortcut toggles the terminal visibility between up and down I also have command J as a toggle for panel visibility as well this is a key binding that you'll see me use pretty often because we often will flip back and forth between the terminal and our code which is going to be up here in fact if we click this explore button on the left we can select this area select new file do something like hello.txt or better yet hello.soul and we can add some code in here what's important to note is if you see this white dot in the top section here this means that this file isn't saved command s or control s depending on if you're on a Windows or Mac or Linux we'll save it and make that white dot go away unsaved saved unsaved saved it's important to recognize if file is saved or not because if it's not saved it might not do what you think it should do so I kind of by default will always automatically save by hitting command s and it's a good practice to get into just always auto save everything you do we can also delete this file we just created by right clicking it and selecting delete move to trash final thing that we want to install and we'll install a lot of these as we go along is actually an AI extension something in vs code to help us actually have ai inside of our Visual Studio code if you select this little box looking thing that says extensions you get a search box which allows you to search for extensions the AI that I work with the most is GitHub copilot but you can use whatever AI you want or you could just not even use an AI GitHub copilot does cost money to use so feel free to also not use it there's some other free vs code extensions that use AI so feel free to browse around and choose which one you like for me I'm going to go ahead and install GitHub copilot you'll get a little guy in the bottom right for your vs code that will let you know that you've done it correctly you'll need to sign into GitHub which is something that we've recently made in order for it to work now you'll see me using GitHub co-pilot pretty often when I write my code because I have this little doodad on down here I can start writing some code and GitHub copilot will start giving me suggestions as to what I should write for example if I were to add spdx like sense identifier get a copilot actually automatically starts to gray out and give me a suggestion if I hit tab I can auto complete my code with GitHub copilot suggestion alternatively what I could do then for example I could keep coding and I can see it's already giving me a suggestion here and if I hit up key enter I'll actually open up this bit on the side where GitHub co-pilot will give me a ton of different solutions on what it thinks I'm trying to write and I can just pick one of these Solutions obviously some of these aren't doing anything we'll learn about the command palette soon and we can also use any of the GitHub copilot commands that come with the command palette an alternate to vs code is a tool called vs codium so vs code is a tool that's owned by Microsoft and it sends up Telemetry data up to Microsoft so basically it can send data about ways to make your experience better with vs code for people who have a more security mindset this is an open sourced version of vs code that I highly recommend you check it out another extension that you might want to add is GitHub copilot Labs GitHub copilot Labs has AI features that are experimental so it might be worth installing as well all right fantastic at this point you should be 100 set up with Visual Studio code and git if you're using gitpod that's great as well and if you're using Windows you should be 100 using WSL because the rest of the commands are all only going to work if you're using WSL and we're only going to be working with Linux bash or zsh commands moving forward if you want to be a Hardo like I was saying do everything in Powershell that's great too moving forward what I want you guys all to do is open up your terminal the different ways I showed you and create a folder by typing in mkdir boundary hyphen f 23 and then you do CD boundary f23 you'll notice something else I do a lot is I'll type the first couple letters of the folder I want to go into and then I'll hit tab which will auto complete a lot of stuff for you in the terminal sometimes it doesn't work you'll get better at figuring out what autocompletes and what doesn't if I hit enter this means I'm now inside of my Foundry f23 folder and I can run commands inside of this folder moving forward I want you to put all of your repositories inside this folder this way moving forward in the future when you start actually working on projects in real life you can refer back to this folder and refer back to code that you wrote and refer back to your notes to make sure that you understand stuff moving forward we've got git Dash version orange dash dash version we have cast dash dash version which cast came with Forge and Foundry we have Anvil dash dash version and we also have chisel dash dash version I'm going to type clear or hit command K to clear everything in the terminal and all right now that we have everything set up let's go ahead and start creating our simple storage project in a professional environment this is going to be the exact same environment that the big protocols use these are the environments that uniswap Ave curve Etc these billion dollar groups use you are learning the exact same tools as them additionally for those of you who are interested in security and auditing Foundry is the most popular tool amongst Auditors so for those of you who want to become security researchers you're going to learn the exact same tools that the best of the best use you ready I sure am so let's go ahead and create a new folder inside of this folder here to do this we're going to type MK dir boundary simple storage f23 and then we're going to CD into Foundry simple storage f23 and you'll notice I hit tab there to autocomplete again now everyone's terminals are going to look a little bit differently mine tells me the exact path of the folder that I'm in but I have a Alias called video shell which just shows me the current folder that I'm in and I'm going to use that for the rest of the video so if you see my terminal look like this it means I'm at this location now if you're inside of this folder you can actually type in code and then hit a period and then you should get a new Visual Studio code which is now defaulted to that folder if you don't you can also hit file open folder and select the folder that you want to open which will also open up a new Visual Studio code inside of that folder if you open up your terminal now you'll see that we are indeed in the folder for this project and now on the left hand side over here this explore piece we create a file you'll see it pop up in the left hand side of our Explorer touch is a command to create or touch a file and we go ahead and click it and type stuff in this file now all these CD and mkdir and all these commands are known as bash or zsh or like Linux terminal commands and we're going to be using them a lot throughout this course if you want it's a great lesson on working with bash and CCH and Linux commands on the free code Camp YouTube but at the same time most of the time chat gbt and most AIS are actually very well versed in bash and Linux commands so anytime you have a problem doing something you can often just ask one of these AIS and it can help you out as a recording this one just came out a couple weeks ago so it's incredibly up to date so if you want to get the basics down it's only about 45 minutes long I definitely recommend watching this so you can at least be familiar with some of the power that bash has ads you can absolutely continue on with the course as is and just use AI to augment you but for those of you who want to get more knowledge definitely check that out again the reason I have this Dash f23 is to let everyone know that this is associated with The Foundry 2023 course but awesome we can actually begin getting set up with our own local environments similar to that remix VM that we saw when we were working with remix we can work with our own local blockchain and do a bunch of stuff locally as you can tell by the name of this project and from what I was saying earlier this is going to be our simple storage project but coated with Foundry which again is a smart contract development framework that's going to make our deployments and interactions with a code much more professional to get started with Foundry what we can do is we can open up our Explorer to see what's in here let's go ahead and delete i.txt move to trash I'm going to do my video shell command here which won't work for you but it works for me what we're going to do is we're going to run a command to create a new Foundry basic project for us and if you go through The Foundry documentation this is going to be basically this creating a new project section of the documentation and if you want to follow along with the documentation you can do that as well but to do this we're just going to run Forge init like this and we'll see it created a ton of folders over on the left hand side for us if you run into an error because you accidentally have some files in here for example if I run forge.net right now it's going to say oh it's not an empty directory what we can do is type Forge net dash dash Force period to say let's do it in this directory hit enter and it's actually going to give us an error because it's going to go hey it already has everything that I was going to do so it's just it's just not going to do anything but if you have files in here already you just add this dash dash Force piece now if you get a different error about git basily is actually going to help us triage that so take it away and we are getting this error and this is pretty common don't worry the reason is because even though git becomes pretty installed on our WSL install we still have to configure or username and or email so we can just use these commands change this one my actual email and now let's also configure the username after we have these configurations we can run that command again Purge init hello Foundry and if we check this out we have our first Foundry project ready to be used with all the things we are going to need and let's walk through what we have over on the left hand side here so so we have this dot GitHub workflows file which we're going to ignore for now but we'll explain this later we have lib which we're also going to ignore for now but we'll explain later we have script with a file in here which for now we're going to go ahead and delete we have SRC which is where we're going to put all of our smart contracts that we want to deploy right now it comes packed with this counter dot Sol which we're also going to delete move to trash and then we also have tests which we haven't learned about yet but we will and for now once again you guessed it we're going to go ahead and right click and delete source is going to be the main section that we're going to be working with SRC stands for source and you'll see in a lot of projects this is where they put all their main contracts test is where we're going to put code to test what's in SRC and script is where we're going to put code to interact with our contracts that are in SRC git ignore is going to be files that we're not going to push up to GitHub if we push our code to GitHub which is going to be really important get modules we can ignore for Now teach about that later and founder.tommel is a file that is going to give us configuration parameters about working with Foundry and as we go along in this course we're going to update this folder because we're going to update how we're going to work with Foundry now for us to get started here we're going to add our simple storage code into the SRC or Source folder if you close your remix we can just come on back to the repo associated with this course we'll scroll down to the remix simple storage select the code base and we'll code here and just copy all the code in here come back over to vs code and then SRC we'll right click new folder simple storage dot Sol paste it in here and hit save now one of the first things that you'll notice is this is formatted horribly it's just all white text this cute little eth logo comes up which is really nice but we want a way to actually format this code correctly so there are a lot of different vs code extensions that actually will format our solidity code for us one of them is the solidity if we if we simply type solidity in the extensions bar we'll get a whole bunch of options that we can use I'm a big fan of the hard hat solidity extension even though hard hat is another framework it also can format our code in Foundry another one that a lot of people like is the solidity visual developer so that's another option if you want to use that one and this one by one blacko is probably the most used on the planet but we're going to go ahead and hit install to install this nomic Foundation solidity vs code extension and if we go back to our simplestorage.soul you'll see it is now formatted with syntax highlighting similar to what we saw in remix if it doesn't automatically highlight for you here what we can do is hit command shift e or Ctrl shift p which opens up our Command bar here and we can type in settings and we want to open our user settings in Json you can also hit code and then settings as well in here and a lot of you might have nothing in here so what you can do is you create these little brackets to say hey whatever is in here is going to be our new settings and we want to type these little quotes little brackets and say solidity like this a little set little colon here some more brackets and since I'm using GitHub copilot it's even starting to give me suggestions which I'll explain much later but we could do editor dot we could paste in this editor.default formatter nomic foundation.hearthead solidity I'll have this code in the repo associated with this course so you can just copy paste this if you want to I've got a whole bunch of other stuff in here so I'm going to go ahead and delete this though but that way your solidity code will default format using that hard hat extension that we just installed great additionally this foundry.tomel file also isn't formatted very well so we'll go to extensions we'll type in Tamil and we'll install this better tomml here we'll close this now if we go to foundry.tomel we'll see this is now highlighted very nicely too great now just remember whenever you see this little dot here this means that it's not saved so hit command s or file save and do that a lot the other thing that's really good about us adding that default formatter is in our code here you know maybe this isn't formatted very nicely right maybe we've got this over here and and this over here and it's kind of not looking very nice here if I go ahead and save without formatting it'll save it here but what we can do is if we add that auto formatter now if we do command shift p again that brings this up this command palette up you can also get it by hitting view command palette and we type format document it'll format our code automatically depending on what formatter we're defaulting to since we opened our Json and we defaulted to the solidity hard hat it'll automatically format with that if your code isn't Auto formatting that's okay don't worry about this too much be sure to use AI a web search and the forums to get your formatting good the other thing that I like to do is we'll go over to settings again we're not going to go to the Json we're going to open the user settings and we're going to type in format on Save and we'll check this box on this way every time we save it'll automatically format so if I have this and I hit save it'll automatically format my solidity code for me if I don't want it to format again we open the command palette with command shift p or view command palette and we could say save without formatting and it'll save it see the white dot is gone and it will not be formatted but I'm going to save and reformat it because I like it formatted and just to note we pretty much never want to open these default settings Json so avoid that one all right great and just with this little pieces of code and Foundry installed we can go ahead and compile our simplestorage.soul right in our terminal so what we can do is we pull up our terminal and we can type in Forge build or Forge compile and this will compile our code like so once we compile we see a couple new folders show up one of them is out and this file and out has all the different information that the remix compiler would have for example it has the ABI we go back to remix we go to the compiler tab we go to one of our contracts we scroll down we can see we have the ABI section or it's also in the compilation details in vs code we can even click this little drop down thing next to it and it'll minimize the API and we can see the rest of this stuff like bytecode method identifiers and all this other stuff which we'll learn about later we also get this cache folder this is a folder that you would basically ignore now anytime in our terminal we hit up we can actually cycle through commands that we've recently run so if I run some crazy long command like this Echo here which is a bash command don't worry about it and I want to run it again I can just hit up all right great so one of the things that we did in remix quite a lot was we deployed our code to a remix VM or a JavaScript virtual environment we want to be able to do the exact same thing in Foundry in order to test and interact with our contracts Foundry actually comes built in with a virtual environment in the shell and if you run Anvil you'll get an output that looks and we pull this to the top you'll get an output that looks something like this Anvil and we get some fake available accounts with some fake private Keys you'll also get a wallet mnemonic the derivation path which you can ignore some details about the blockchain and then this endpoint or RPC URL which we're going to learn about soon for now if you want to close this hit Ctrl C or just delete your terminal to end running the Anvil blockchain now moving forward we're going to work with Anvil but I do want to give you an intermediary step and that's going to be with the ganache eth chain and we'll have a link to this in the GitHub repo associated with this lesson ganache is a one-click blockchain and it gives us a user interface or an app for us to look at our transactions in an easier way so if you go ahead and download it for your system we can get started there now a note for Windows users if you're using WSL the setup here is a little funky we ran into some issues with it in our previous course and we'll have some troubleshooting tips for those of you who are using Windows and WSL if you want to work with ganache everything that we're going to be doing moving forward though does work with Anvil ganache just allows us to see transactions a little bit better than viewing all this stuff in the terminal so if you're having a hard time with ganache don't worry we can do everything that we're doing with Anvil which should work for you no problem once you have ganache installed when you open it up it'll look something like this and if we hit quick start for ethereum we'll actually actually create a brand new locally running blockchain with a nice little UI to view things same as Anvil and same as remix we get some addresses we get each of them has balances they come with some dummy private keys and dummy addresses and the likes what's nice about this is that we can see the blocks we can see different transactions and if we're working with truffle we can see contracts we're not going to work with truffle though but these are going to be very helpful for us to view stuff additionally we're not going to use ganache again in the future so if you have trouble setting up with it don't worry just use Anvil I'm going to use it to show you what's going on remember though don't use these private keys on a public blockchain it's for development purposes only because everyone knows these private keys because they're dummy private Keys now in order for us to learn how to actually deploy to this blockchain or how to deploy to Anvil if we're working with Anvil we need to understand how even remix was able to deploy to a public blockchain when in remix when we switch to objective provider metamask we know that metamask popped up it asked us to add our password and we went ahead and got connected and if we looked in metamask we saw our count is indeed connected to sepolio when we hit deploy our metamask popped up again and it was able to deploy our contract to a real test Network well how did it know where to send our transaction how did it know where to send our contract well let's go ahead and open up our metamask here if we click the three little dots and hit expand view we hit the little button now and we go to settings and we go to networks you'll actually see in here that each one of these networks ethereum Maniac released or whatever you have comes with a whole bunch of information let's go to each mainna and check that out for a second it has a name an RPC URL a chain ID currency symbol and block Explorer this RPC URL is the actual https endpoint that we actually send API calls to when we're sending transactions so whenever you interact with metamask and you send a transaction or you deploy a contract you're actually making an API call to whatever is in here you'll see this is an inferior endpoint and infuria is known as a node as a service project that allows you to send transactions to a blockchain node without having to run one yourself if you wanted to send transactions to your own blockchain node you would just Swap this out with your own blockchain node address we can't actually change the ones that come built into metamask but we can add new networks which is what we're going to do now in here if we scroll the bottom we can hit add Network manually and we can add information about our own custom Network so for us we're going to make this new network called localhost or local chain or whatever you want to call it or RPC URL if you're working with ganache it's going to be this RPC server right here if you're working with Anvil I the bottom we have this listening here so what we would do is we would copy this or we would copy this from ganache and paste it in here just note that you always need the HTTP or https colon slash most of our local applications aren't going to be https they're just going to be HTTP so if you're working with ganache let's go ahead and copy the ganache endpoint paste it in here like so every single blockchain gets their own chain ID it's an easy way for us to know which blockchain that we're interacting with ganache has 1337 and Anvil doesn't say it but it's 31337 so Anvil is three one three three seven since I'm using the ganache endpoint here I'm going to type in 1337 if you're using Anvil it would be 31337 but what's kind of nice is metamask can actually identify where you're using and identify the chain ID and basically tell you what chain ID to use just to note it looks like the newer versions of ganache are using a different RPC server and a different network ID and make sure you're on this hard for the merge here as well although in practice I've found that even when you have 577 it still is expecting one three seven seven so be sure to use the correct chain ID when you're working with this currency symbol we're going to do eth and since this is a local blockchain we don't actually have a block Explorer etherscan has no way to connect to our own local blockchain so we don't get a block Explorer for this one but if I go ahead and hit save now it says Network added successfully and I can go ahead and switch to my local host chain boom and now we can see it in my list of Networks of localhost I've got no assets no nfts and no activity now if your local Anvil organized chain isn't running after you've put it in your metamask if you actually try to swap to your Anvil or to your local host or to your ganache you'll just get this spinning wheel of death here right and eventually you'll get this little X that'll show up and you'll have to switch to a different network so if you ever want to switch to one of these that isn't running it won't work you'll have to either run it or you can hit X here and then in your meta mask you could just delete one of these right here while we're not running our ganache or our Anvil we're just not going to have one of these selected great and so this is where on both Anvil and ganache they have these available accounts and these private keys since I'm using ganache what I can do is I can select this show Keys copy this private key and import it into my metamask so I can go up hit this little button I can hit import account paste my private key in here and hit import now you'll see in my memos I have a couple different accounts account three the one I just imported has 100 eth why does that have 100 each well because I'm using one of these dummy accounts from ganache and again if you're using Anvil they have they start with a thousand each this process that we just did to add our new ganache local chain is also how we're going to add any evm compatible chain on the planet we'll just hit add Network and metamask actually comes built in with a lot of these and for example if we wanted to work with arbitrary one we could just hit add and it would add all this information in for us approve Network addict successfully but if metamath doesn't have those built in that's the process now if we go back to settings network localhost this endpoint is the most important thing you need to send a transaction to a blockchain you need a connection to a node in order to send transactions to if you wanted to send transactions to your own node you would run something like gath which is an execution client and then something maybe like techu a prism which is a consensus client and send transactions there I'm not going to go over this right now but I highly recommend that those who are curious maybe you take some time and you try to run your own ethereum node I run many ethereum nodes and it's a lot of fun it's kind of a weird thing to say it's fun to running nodes whatever it is fun to run nodes each one of these blockchains has different methods you could send to them to do things if you're familiar with apis and HTTP endpoints and you go to this ethereum jsonr PC specification site you can actually see all the different methods that ethereum blockchain nodes can make and most evm blockchain nodes can make and when we actually sign and send transactions it's these calls that we're actually making like each sign sign transaction send transactions send raw transaction Etc we're actually not going to be going over interacting with these because Forge actually handles a lot of sending these transactions itself if you want to learn how to send a raw transaction making raw API calls to your own ethereum node or an ethereum node as a service like inferior or Alchemy you would do that in a different programming language like bash python or JavaScript all right awesome now that we have our endpoint and our private key we pretty much have everything that we need to deploy to our own local blockchain be it ganache or Anvil same as working with a real blockchain we need an actual balance to spend gas to deploy our contract now there's actually two ways that we're going to learn to deploy contracts and the first way is actually with just working with the command line if we're in our command line if we're in our terminal here and we do Forge dash dash help you can actually see all the different commands that Forge comes built in with the one we're going to be working with right now is this create command and if we read it it says it deploys a smart contract which is perfect that's exactly what we want to do and if we're in our Command here let's hit clear we do Forge create dash dash help we can see a ton of different options for deploying our contract click show Keys copy the private key again if you're using anvil use the private keys there if we do Forge create simple storage which is the name of our contract it'll compile and then it'll throw an error actually or it might actually work but because I'm working with this RPC server but this RPC server is different from the one that Forge actually defaults to so instead what I can do is Forge create simple storage dash dash RPC Dash URL copy this paste it in here it might be upset with the uppercase let's just make that lowercase and I'll hit enter and this won't work either well of course we forgot to add a private key so if I hit up I can hit dash dash interactive as well and now it'll prompt me for a private key now in a really important note that I want to tell you never use a real private key in your vs code if you're using an application that potentially will send your information a much better option is to use your own terminal as opposed to something like vs code which might send data or gitpod since we are just developing and we're just practicing it's fine to paste our private Keys here because this is a private key that's not going to have any real money right it's a fake private key so for now we can go ahead we can go back to our ganache or back to our endville hit show Keys copy this private key paste it in here it won't show up if you hit paste but I'll hit enter and we'll go ahead and see information about our transaction now if you're working with ganache you know hit done here we go to blocks we see we created a new block we go to transactions we can see that we sent a transaction and we created a contract and then you can see logs about working with this as well fantastic if you're working with Anvil and you send a transaction you're not going to see any of those details for those of you who want to continue to see these blocks and these transactions I want to keep working with ganache feel free to do so moving forward we're going to work with Anvil so I'm actually going to close ganache now I'm going to hit clear in the terminal and I'm going to run Anvil here and what I'm going to do is I'm going to create a new terminal by hitting the plus button here and we're going to run that command again but we're going to run it with a private key from Anvil so if we go to here we do Forge create this time we don't have to put an RPC because Forge defaults to the Anvil one but I can say simple storage interactive it'll do enter the private key I will paste it and we'll go ahead and deploy go to Anvil we don't get any logs like this but we can see we went ahead and actually deployed it to our Anvil blockchain awesome work another way we can do this Forge crate it's by running Forge create simple storage if we wanted to be incredibly explicit we would do dash dash rpc-url copy this HTTP colon slash paste it in there dash dash private key and back in Anvil copy the private key paste it in like this and we will get the same thing now here's what I'm going to tell you and this is incredibly important pasting in your private key like this is no bueno very bad we pretty much never want to have our private key in plain text especially our production or our private keys with actual money putting this private key in plain text is not a big deal because this is a fake dummy one it's also bad to have our private keys in our shell or bash history if I hit up once on my terminal I can see the private key in here which is why the interactive is a little bit better because it at least obfuscates the private key to remove your private key from your history in bash you can do history Dash C now if I hit up I can't see any commands and if I do history I can see my entire history which is just the history keyword now if I type clear I'll do history now I see history clear history great and we don't have the private key in our Command history anymore we will learn more about proper private Key Safety in the future sure but I want you to do something for me right now in a new file I want you to right click and I want you to write promise dot MD we're going to hide the terminal and in here we're going to say I promise to never use my private key associated with real money in plain text in fact take this and tweet this I promise to never use my private key associated with real money in plain text and I can't spell and that's fine and then if you want to at me or you want to add site for an audits or whatever go ahead and send that we are going to have more of these promises that you're gonna do but this is the first one that I need you to understand right now it's cool because these are dummy keys but in the future it will definitely not be cool and I'm stressing this because I've seen a lot of multi-million dollar companies not follow this and get their private Keys hacked great now of course though the basic way to deploy to any blockchain would be Forge create the name of your contract add the RPC URL and then add your private key we're going to learn how to get RPC URLs for free using Alchemy for any blockchain that we want and like I said more safe private key methodologies in the future but now you've just learned how to deploy your contracts to any chain from the command line this is great all right great so now we've learned how to actually deploy a contract to any blockchain that we want using the command line but now I'm going to teach you the second way we're going to deploy our contracts and this is the way we're actually going to do it for the rest of the course when we're deploying our code we want to make sure we have a continuous reproducible way to deploy our smart contracts and when we test our code in the future we want the tests to test the deployment processes as well as the code so instead of just doing the command line we're actually going to write a script for us to deploy our code and because Foundry has everything written in solidity this script that we're going to write to deploy our code is also going to be written in solidity and this is where solidity has a contract language versus solidity as a scripting language is a little bit different Foundry has a whole bunch of built-in stuff to give our solidity even more functionality outside of just smart contracts and you'll learn about how later in the course but for now we're going going to learn how to create a script to deploy our simple storage contract the way we create a script to do it is first we come to our script folder we'll right click new file we'll create deploy simple storage dot s dot Sol this dot s dot Sol is just a Foundry convention most of the time scripts have a DOT s dot Sol instead of just being dot Sol and then here we're actually going to write a contract in solidity to deploy our smart contract which sounds a little bit weird but don't worry too much about that this deploy script is going to be written in solidity but it shouldn't be considered a contract that we actually ever want to deploy it's just for deploying our code but it is written in solidity so since it's written in solidity we'll do the same thing as usual spdx license identifier MIT and if you're using GitHub copilot it might even Auto suggest like this and I'm just going to go ahead and hit tab I'll do pragma solidity 0 0.8.18 and then I'll create contract deploy simple storage like so and I'll hit save if you go to The Foundry docs we can actually scroll down to this solidity scripting section in the tutorials and you can learn how to actually write scripts and work with scripts the first thing that we need to do in order to tell that Foundry that this is a script is we need to actually import some additional code now one of the things that we saw in here was this lib folder and this lib folder actually starts with another folder called Forge STD this Forge STD stands for Forge standard library in here there's a ton of helpful tools and Scripts for working with Foundry and to tell Foundry that this contract deploys simple storage is actually a script we need to import from Forge STD so we can do import Forge Dash STD script dot Sol and we'll have our contract deploy simple storage inherit all the functionality of this script by saying is script and I know we learned about inheritance before so you should know what that means is script and then additionally our deploy simple storage is going to need to know about our simple storage contract so we'll go ahead and import that import we'll go down a directory since we're in the script folder and we need to go to the SRC folder these two dots is how you go down a directory we'll do slash SRC vs code even might help prompt you here Dash and it again Auto prompted for me and I hit Tab and now we've imported simple storage now since we know that this is the new way to do Imports we're going to do the cool way but using named Imports instead of nameless Imports okay great now inside every deploy or script contract we need our main function which is going to be called run and this is going to be the command that gets called when we go to deploy our contract so we'll create a function called run we'll make it external and we can have it return a simple storage contract and in here we're going to use a new keyword that we haven't used before we're going to say vm.startcast VM is a special keyword in the Forge standard Library the VM keyword is a special keyword that we can only use in Foundry it's related to something called cheat codes we're not going to go over that too deep right now you can see a whole list of Foundry cheat codes in the documentation and Forge standard Library references which have even more cheat codes as well this VM stuff is only going to work in Foundry if you actually were to try to deploy this and Re Max or some other framework it wouldn't work these VM cheat codes only work in Foundry it's not valid in regular solidity but if we're inheriting Forge STD code this VM keyword exists if you're using the hardhat solidity extension we can actually control or command click into VM and we can actually see where it's defined but if that's confusing ignore that for now this vm.start broadcast says hey everything after this line inside of this function you should actually send to the RPC and then when we're done broadcasting we're going to do VM dot stop broadcast so everything inside of these is what we actually want to send and deploy the reason we have this is because maybe we have some stuff like we want to set some boilerplate code before we actually send transactions and we don't want to spend any gas to like set starting value to one right so any transaction that we want to actually send we need to put in between these vm.startbroadcast and vm.stop broadcast and for us to deploy our simple storage contract we just do simple storage lowercase simple storage right these are different simple storage the variable simple storage the contract equals new simple storage like this and remember what does this new keyword do well the new keyword creates a new contract in solidity it's also going to create a new contract in between our vm.star broadcast this being in between these vm.star podcasts is going to send a transaction to create a new simple storage contract if this is a little bit confusing for you right now that's okay it's going to make more sense as we go on later in the course but for now just do this and follow along with me and then of course we can say return simple storage okay great now if we pull our terminal back up we can see we have Anvil running right now we can actually kill it with Ctrl C we'll clear to the top and what we can do now is run Forge script script deploy simplestorage.s dot Sol hit enter and oops looks like I got some different solidity versions so let's change this to a carrot in here and let's change this to a carrot in here this being an 18 so that they're both on the same version let's type clear close these or minimize these out we'll hit up twice and we'll run this again and now what you'll see is it's compiling it compiles both the script to deploy and our simple storage contract using 0.8.19 because we did the compiler successful script successful tells us the gas and then we went ahead we returned our simple storage contract which was deployed here now you might be asking wait wait wait Patrick we don't have Anvil running we don't have a local blockchain running where did this deploy to well in Foundry if you don't specify an RPC URL it'll just automatically deploy your contract or run your script on a temporary Anvil chain so once I ran Forge script it saw there was no RPC URL so it spun up a temporary Anvil blockchain deployed our simple storage and then tore it back down at the end you can see at the bottom if you wish to simulate on-train transaction pass an RPC URL so if we do clear we run Anvil and then create a new terminal we could run Forge script script deploy simple storage.soul and I'm hitting tab to auto complete that dash dash RPC URL go back to Anvil copy this go back to bash HTTP dot dot slash slash we actually almost deploy this to the blockchain we actually did a simulation of deploying to our Anvil chain here it gives us one more piece of information to broadcast these transactions add dash dash broadcast and wallet configurations to the previous command and now we get a new folder which gives us information about our previous deployments in case we forget for example if we deploy a contract we can flip back here and see where we actually deployed code so let's pull up our terminal once more and actually deploy this to the blockchain so we'll hit clear I'll hit up we have our RPC URL so now let's do dash dash broadcast and we'll do dash dash private key and we'll grab a private key from Anvil and paste that in here and hit enter boom and we see at the bottom on chain execution complete and successful and we see we get some transactions here we waited for receipts Etc so fantastic so we learned how to actually deploy our smart contracts through the scripting command now awesome job now let's learn a little bit more about what actually just happened right because right now sending transactions is still kind of this magic thing right so let's hide our terminal and let's go up to our Explorer let's pull this out a little bit and let's go into here now what's important to note is that there's actually a couple different folders in here dry run is the folder whenever we don't have a blockchain running otherwise this gets separated by Chain ID and we'll talk about this a little bit later but if we go into one of these either dry run or even just run latest we'll see details about the transaction we'll see a hash transaction type contract name address blah blah this right here this transaction section is actually what is getting sent on the Chain when we do Forge script or Forge create this is the transaction that we send to that RPC URL right this is the API data if you're familiar with https post this is the data that we actually send we send the type which for now just everything is Type 2 because we're in the merge don't worry about type 1 for now we have a from which is of course the from address that we want to have we have a gas here and this is the hex value of gas now if we pull our terminal back up we'll clear this out I'm about to show you an amazing trick that's going to make your life a lot easier Down the Line cast actually can convert between hex and numbers really easily and cast comes built in with Foundry we do cast dash dash to base paste our hex in here and write DEC for decimal it'll convert this hex value to its decimal value 0x714c2 whatever is just this number and I use this cast to base all the time you can put some value in here and then what you want to convert it to and it's a very easy way to see what some values there's some other stuff in cast as well if you do cast dash dash help there's some other ways to convert different units to each other like from way bytes 32 and some other stuff but two base is going to be one that we're going to use a lot so we have the gas we have the value with the transaction yes since deploying a contract is just a transaction we can add a value to it if we want in our deploy script right in here we would just do some brackets we would say like value and like one ether if we wanted to deploy this with one ether we can't send a value here because in solidity you can't set the option value if the Constructor is not payable we'd have to make the Constructor payable but we could send value just like any other transaction there's this huge data piece here this is actually the contract deployment code and the contract code in here we have the nuns which is going to be that number that's only used once and then don't worry about access list for now but this is all the transaction information and then of course we have our RPC now what's not stored in here is is a couple other pieces of the transaction now additionally there are these VR and S values that account for the transaction signature it's not getting saved here because it's technically part of this from anyways they're public values and these are s and V allow our private key to sign the transaction so what's really happening when we send this the reason we need our private key is we need the private key to actually sign the transaction that we built and that's happening a little bit under the hood so whenever we send a transaction there is a signature happening we are signing a transaction and then we are sending it and that's important for later in the course they don't save it here but signing the transaction does happen when you sign a transaction it's very similar to doing that hex thing we showed you way way at the beginning of the course with the blockchain only the private key can sign the transaction this is how when we send our data to a node it knows that it's able to execute it because it's signed by our private key I'm not going to go too deep into that right now this nuts piece is a little bit important every single wallet has a counter of transactions which is basically the nuts whenever you send a transaction you give it a nuns or this value this number only used once to basically count your transactions this is really good because if you want to replay transactions you would just send the same transaction data with the same nunts for example if we have a transaction that didn't go through you'll see that this is in this run latest with the dry if we run this again if we hit up we'll see that if we run our transaction again with our Anvil deployed here we'll actually deploy another transaction if we go back to our broadcast folder we see there's actually two runs and a new run latest if we go to our run latest now you'll see that the most the latest one now has 0x1 so this increments every single time we send a transaction your nuns increments every time you send a transaction and again contract deployments are transactions now we went over a lot of stuff in here but the most important takeaway I want you to have from this is anytime you change State on the blockchain it does it in a transaction and the differentiator is going to be whatever in this data field this data field contains the opcodes to tell the blockchain hey I'd like to create a new contract we're not really going to go too deep into what these op codes are or this evm byte code we'll briefly talk about op codes later in this course but if you want to really learn about op codes and assembly we have another course on security coming out that we'll go over that but this is the most important thing to take away when we're in remix and we're sending transactions with these buttons we're doing the exact same thing we're populating the data field of a transaction but instead of the data being associated with creating a contract the data is associated with sending a transaction all right great now that we've actually deployed our contracts though we should learn how to interact with them in the same way that remix allows us to interact with them with our buttons here now there's two ways to actually interact with our contracts one is going to be doing what we did before with scripts but the other way is actually going to be doing directly from the command line so we're actually going to learn the command line Parts in this project and then we're going to learn how to do scripts in a later project so let's pull up our terminal here and just to make sure that we have this deployed let's hit up a couple times and we'll rerun this deploy script now in just a second we're going to learn how to actually interact with our contracts from the command line as well similar to how remix has all these buttons that we can press however first we're going to make this a little bit better and we're going to take a couple of different approaches to not having this in the command line as you saw before we could use Forge create interactive paste our private key in and it wouldn't be in our command line we actually can't use interactive for when we're sending scripts at the moment I'm sure in the future they'll make it a little bit easier for us to do this but right now we really don't want to have to do dash dash private key and paste our private key in plain text so what else can we do what alternatives can do we have now what I'm about to show you once again only do this for your development environments do not put a real private key in here the reason I'm showing you this is because it is much quicker to test however it's terrible to use in production so this is cool for development purposes this is not cool for actual production purposes what we're going to do is we're going to create a new file called dot EnV and whenever you create a DOT EnV the first thing you should do is go to a git ignore file make sure that a EnV is in this git ignore I'll explain what the docket ignore does in the future but for now just have that be the first thing you do in our.env file we can put in what's called environment variables these are variables that might be a little bit sensitive that we don't want to actually write in the command line or actually expose to the public one of those of course is going to be our private key so let's go to Anvil scroll up grab that private key copy and paste it in here and we have this private key equals this typically you'll also see RPC URL equals what's our Anvil RPC irreleances right here so we'll do HTTP paste that in there and great now that we have those in there what we can do is now run source.emv which will add these environment variables into to our shell here and we can do Echo private key like that and we'll see our private key actually show up like so we can also do Echo dollar sign RPC URL and we'll see our RPC URL actually show up like this and then what we could do is we could go back to our Forge script and instead of typing in our private key we would just do dollar sign private key and dollar sign RPC URL so now our rpcrl and our private key at least aren't being run in our command line so that it's not stored in our Shell's history the issue of course is that okay well now we have it stored in this dot EnV anytime you have your key stored in plain text you should be afraid you should be a little bit nervous so we can actually take one more step to make this even more secure and this is going to be one of the steps that I recommend that you take when you're actually working with production code you definitely do not want to launch production code with the dot EMV file and I'm going to summarize all this very soon just stick with me I promise this is a little bit boring but it's incredibly incredibly important that you get this right I'm going to try to prevent you from getting wrecked now Foundry is a tool that is constantly being improved and updated and there's an issue in The Foundry repo right now called improve wallet management using keystore I would love a way for you to actually encrypt your private keys so that none of you accidentally push a private key up to GitHub or expose a private key that it's in plain text if you run Forge script dash dash help and you scroll up you'll get this wallet options section where you can actually pass the path to an encrypted keystore file and a password a keystore is a file that has your private key but encrypted by a password instead of having your private key in plain text you would have it encrypted and you would just need the password to decrypt it that is a much safer way to deploy your contracts I've added some context and another issue on Foundry as well and if you all could come in here give this a thumbs up that would be fantastic a way to encrypt your private key into a keystore file natively doesn't exist in Foundry yet but I've put out a bounty for someone to actually implement this so be sure to just check the GitHub repo associated with this course to check to see whether this feature is implemented so what I'm really trying to get at is for the moment a private key in our DOT EMV file is cool so long as we don't expose the dot EMV file but for real money you're not going to do that we're not going to do that okay for real money we're going to use the dashish interactive to paste our private key or we're going to use a keystore file with a password once Foundry adds that there are some tools like daptools esign that you could optionally download if you want to deploy and interact with walls that have real money in them and it does have this import keyword where you can import your private key into a keystore file and then you just obviously encrypt that with a password so for the moment this is your setup but in the future this is going to be your setup okay this is cool now but not in the future and additionally if you go to The Foundry full course f23 you go to discussions and this will also be in and this will also be somewhere on this side at some point you'll see this the EnV pledge which has a whole bunch of information about working with DOT EMV files and keeping your private Keys safer for the rest of this course we are going to be working with this dot EV syntax because it is easier however I'm really hoping that Foundry in the future adds this keystore encryption by default so that we don't accidentally expose our private keys and I'm not doing this to scare you but I'm doing this to impress upon you the importance of making sure you keep that private key and that mnemonic safe the other reason that we're okay to put our private key in our av file is that you have already promised me that you're only going to work with a development private key or a private key that you're not going to add any real money into so if you expose it it'll be fine but you still want to practice not exposing it so please take some time to read this and then if you do agree to everything just say I will be safe as a comment on this dotting V pledge so I'm going to read it out and it's important for you to understand this moving forward so it's going to be a little dry here but I am just going to read it I solemnly swear that I will never place a private key or secret phrase or mnemonic in a dotting view file that is associated with real funds I will only place private keys in a dotting view file that have only test that eth link or other cryptocurrencies when I'm testing and developing I will use a different wallet than the one associated with my real funds I'm aware that if I forget a DOT get ignore and push my key slash phrase to GitHub even for a split second or show my key slash phrase the internet for a split second it should be considered compromised and I should move all my funds immediately this is a really important line even if you show your private key to anywhere on the internet for even a split second it is considered compromised and you should move all your funds immediately if I'm unsure if my account has real funds in it I will assume it has real funds in it if I assume it has real funds in it I will not use it for developing purposes I'm aware that even in my meta mask if I hit create account or add account on my metamask or other youth wallet I will get a new private key but it will share the same secret phrase slash mnemonic of the other accounts generated in that metamask these are some additions that I made from the last course for this course I will only use funds associated with my brand new never before used metamask or other wallet and again most browsers you can choose a different profile you can install a metamask on a different profile and use that metamask for this development purpose if I must use a private key associated with real funds of the future until I'm 100 sure what I am doing I will always either use encryption methods like the daptools keystore file I'm not going to show you how to work with this because some of the installs might be a little bit tricky but they have a way to actually import and encrypt private keys to a keystore file use the foundry's built-in keystar Creator which is an implemented yet anybody here who is a rust developer or knows some rust or wants to participate definitely be sure to check out this issue which is on Foundry and I would love somebody to take a crack at this or if you must use the command line as a way to pass your private keys and then delete the command line history immediately afterwards if I never actually deploy anything to mainnot myself or work with a private key with real funds I do not need to be concerned for any of you who are getting a little bit nervous about this just remember if you don't work with any real money you don't have to worry about this okay so a lot of you people who are who are newer here who are going to be going through this course we're not going to use any real funds so you won't have to be worried about this for those who are doing the extra credit which is with real funds you will need to keep this in mind moving forward and I would try to load your real metamask with real money with small amounts so that if it all gets stolen you won't lose sleep at night okay great and I'm telling you all this to arm you with this knowledge that you can be more secure moving forward take a look at this read this internalize it and if you want to copy paste this on Twitter in a huge tweet thread shout this from the rooftops put this in an article make a tick tock with this dotting me pledge have an absolute blast the more people who know about this and the more people who understand this the better thank you for coming to my TED Talk all right so I know that was a lot of private key information and there's going to be more soon too so but the reason I'm harping on this is because I really really really really really want to make sure that all of you don't actually mess this up since you are the developers you are going to be the ones responsible for dealing with all this and I want to make sure that you get it right one final option that we can do as well which again saves us from having to have our private key in plain text is going to be using something like third web deploy so we actually have Kira from the third web team to explain third web deploy now she is going to use the MPX command which comes with node.js and npm installation which we haven't gone over in this course but we will leave some links in the GitHub repo associated with this course to download that if you're interested so take it away Kira in this video we are going to learn how to easily deploy any contracts to any evm chain using one simple command this command requires no setup hard-coded private Keys RPC URLs or scripting required third web handles all of the complexities for you because there's no need to export your private key this is much more secure the deployment is done through the dashboard UI using your own wallet so with that said let's jump to deploying our contracts so let's say we have cloned this repo or written our own contract this can obviously be any contract at all but I have gone ahead and cloned this simple storage contracts just to demonstrate how we can deploy our contract as you can see in the sidebar um so yeah so I've opened this up in my code editor in the sidebar there is no.env file I haven't set up an RPC URL I haven't exported my private key there is no setup needed here I want to reiterate this you do not need to pre-install anything there are no dependencies so to deploy our contract we are going to run the simple command npx third web deploy so what this done is detected our project type which is Foundry and also could be hard hat or Brownie and then it has compiled our contract and then it's allowing me to select which contractor deployed so I'm going to select the simple storage contract so this is now uploading the contract metadata to ipfs and it means that our contractor is going to be automatically verified if you would like more details on how this actually works then please go ahead and visit the third web developer docs which you can see here which is at portal.thirdreb.com deploy and you can read all about how this works so what's happened now is that a browser tab has popped up in my browser and this allows me to deploy my contract from a front end so if I had construct params which I do not in this case there are no construct parameters then I would be able to fill these out from the front end right here next what we need to do is select the chain that we want to deploy to as I said this can be any evm network so we can select ones that are popular such as base or we could add a custom network if this is not already in the list but I'm going to select Mumbai when I click deploy now this is going to trigger two transactions the first one is going to be the transaction to deploy my contract the second one is going to be a message which I will sign and this is a gasless step and this just adds your contract to your dashboard so that you have a user interface in which to interact with this contract a little bit like remix so I'm going to click this button I'm just going to assign these two transactions and then I will be right back as you can see our contract has now been successfully deployed how easy was that awesome so you can see the contract address here which we can copy if we need to use that later I'm just going to give you a very quick overview of the dashboard so there's this build tab here which just enables you to build your contracts into a front-end with easy to use hooks for different languages Hooks and functions to different languages the Explorer tab allows you to see all the read and write functions on your contract so you could add a person and then input the parameters here you can store list the people name to favorite number and retrieve all of the functions that we wrote in the contract you can see and interact with here you can see the events on the contract and the source code as you can see this was a super simple easy and safe way to deploy your contracts using third web third web is the fastest way to build web3 apps we can have sdks in multiple languages we have pre-built contracts we have a solidity SDK an infrastructure for your web3 development needs for more information please head to thirdweb.com or visit our documentation and if you have any questions please head to our Discord oh in any case let's go ahead and let's learn how to interact with these contracts from the command line first and then later courses we'll learn how to do it from scripts so we have our Anvil running and we've deployed our contract using our deploy using at least something marginally better using private key as an environment variable as opposed to just pasting it right in here so we can do now is we can take this contract address and we can actually start to interact with it Foundry has another tool built in called cast and if you type cast dash dash help you'll see we get a whole bunch of commands to work with cast one of the commands that we can work with is going to be send which is to sign and publish a transaction so what we can do is we can do cast send dash dash help we can see the help of send and we can see the arguments it takes is going to be two the signature and the arguments so on remix for example we have our simple storage contract and we deployed it if we wanted to call our store function and send the transaction we just add some numbers in here and then click store like this right if we want to call store from the command line we can do cast send the address we want to do the signature which for now just know is the is the function and the input types it needs so we could call store with a parenthesis un256 because we're calling the function store which takes a u into 56's input parameter and then the arguments or the values we want to pass to our store function and we'll go ahead and hit enter of course this fails because we need to add our private key and our PC URL so we'll hit up we'll do RPC URL we'll do dollar sign RPC URL and then we'll do dash dash private key and then private key like that and now you'll see we'll get all this data about our transaction back we get the block hash block number contract address is blank probably because it's a local chain logs we can learn we'll learn about logs later the transaction hash Etc now in order to read this we're going to use cast call which is going to read off the blockchain and if we do cast call dash dash help and we scroll up a little bit we'll see call takes two signature and arguments exact same as send but the difference is it's like call is like doing one of these blue buttons it's calling as opposed to sending a transaction it's just doing a view function not actually sending a transaction so we'll do cast call we'll paste the contract address we'll call retrieve r-e-t-r-i-e-v-e-r-e-t-r-i-e-v did I spell retrieve wrong I don't know I guess we'll find out no input parameters here and no arguments we can just hit enter and we'll see we get the hex value back this is where I said you're going to be converting stuff from hex back and forth a lot then we do cast dash dash 2 base paste the hex and say decimal and we can see we get back one two three which is exactly what we've stored on chain so if we hit up a couple times back to our cast send transaction our cast send command and we change one to three to seven seven we hit enter we'll send that transaction now if we hit up three times two or three times we'll call cast call retrieve now and we should see the new number which we get back as a hex and then we'll do cath-2 base paste it in deck and we do indeed see 777 Return To Us awesome so now we know how to actually interact with our contracts from the command line and this is going to be the same way we can actually interact with our contracts on an actual test net or on an actual mainnet all right so now you might be asking okay Patrick what does this look like on a test net or a live Network so let's go ahead let's go to our DOT EMB file and let's update this so that it's a DOT EMB file for an actual test net so the first thing is we're going to need an RPC URL for an actual test app for an actual Network and this is where in our meta masks actually have inferior connections built in remember before we went to our settings networks ethereum main net we saw oh we saw we have this inferior connection we can't use this one because this one's designed specifically for our meta mask so we're going to have to get our own RPC URL for an actual test net well one of the things we could do is we could run our own blockchain node but a lot of people don't want to do that so what a lot of people do is use something called a node as a service to do this what I'm going to recommend you do is actually come over to The Foundry full course repo scroll down and there's going to be a section called deploying to a test net or a mainnet we click this link we'll actually go ahead and we'll get sent to the Alchemy platform where we're going to sign up for a free node as a service that we can actually send transactions to and we're going to go ahead and sign up for their platform you can sign up with Google sign up with SSO whatever you want to do I'm going to go ahead sign in with Google I'm indeed human and we're going to come to their user interface that looks something like this we're going to deploy this to sepolia but remember go to the recommended testnet section of this course so what we're going to do now that we're in here is we're going to go ahead and create a new app and you can name it whatever you want I'm going to call it the polia testing I'm just going to copy this for our description this is on the ethereum Chain but on ethereum sepolia we're not going to do any advanced features we'll go ahead to create app and now we have this ethereum sepolia app where we can view details we can see how often we're calling this and we can see different details about our node and if we hit view key we see we have this https endpoint and this is going to be the exact same thing as that Anvil or ganache or metamask endpoint that we saw and we're going to go ahead and copy this and back in our main V what we could do is we we can create a new RPC URL called sepolia RPC URL equals and we'll paste that in here now we have an RPC that points to an actual test net with our private key we can't use this as a private key because this is an anvil private key it doesn't have any real money in it and it doesn't have any test net ethernet but what we can do is instead we can use our one of our private keys in our metamask so if we switch back to sepolia in our metamask we can pick one of our accounts that actually has some money in it I'm going to pick account number one we'll hit the three little dots Account Details export private key and remember it's okay for me to show the private key here because this is just a dummy private key but I'll add my password in and remember I'm never going to actually do any real moneying with this and I'll copy this hit done and paste this in here and maybe I'll maybe I'll comment this line out in dot EMV file this hashtag or this pound sign is what the comment is but maybe we'll do a new private key equals and I'll paste this in here and now I have the private key for metamask I have the RPC around and those are all I need to actually deploy a transaction so what I can do now pull my terminal back up so we're going to run this command to actually deploy this to a real test net from our Foundry using Alchemy as our node as a service and you'll see in the user interface of alchemy you'll see a transaction actually come through our node This Is Us sending a transaction to a real node and we'll be able to see the stats here on our Alchemy dashboard so let's go ahead let's do this again so first we're going to need to run source.amb to make sure all of our DOT AMV stuff is loaded then we're going to run Forge script script deploy simplestorage.s dot soul and I'm hitting tab to auto complete here dash dash RPC URL seppolia RPC URL with the little dollar sign dash dash private key dollar sign private key dash dash broadcast if you don't add the dash dash broadcast it won't actually send it it'll simulate sending it now if I hit enter we'll see compile and now we're running this script deploy simplestorage.s that's all which actually deploys it and we'll see we went ahead and deployed our contract simple storage on the simpolia Chain we see all these details about it it's sending the transaction right now it's storing the latest run under the broadcast folder under its chain ID in here in this run latest.json and after a brief delay we'll see it went through and what we can do is we can grab this hash go over to sepolia.etherscan.io paste that hash in here and we'll see we actually successfully sent a transaction and if we click on our contract address we just created we'll see we actually just created this contract on a real test name we go back to our Alchemy dashboard and we hit refresh we'll see we actually sent we sent some requests we scroll down we can see some of the different requests we sent you send raw transaction was the request that we sent to actually send our transaction to the blockchain but we also got some stuff about the chain ID fee history Etc one thing that you'll notice though when looking at this on etherscan is that the contract it's just a whole bunch of bytecode here right this isn't very readable what we can do is we can actually verify this contract now I'm going to show you the hard way first and I'm going to teach you the easier way later but you can manually verify a contract on etherscan or other block explorers by selecting verify going to solidity this is a single file contract so we're gonna do single file I know that we're on 0.8.19 and our open source license is MIT we'll hit continue we'll go back to our simplestorage.sol and we'll copy the whole contract scroll down we'll hit paste optimization is going to be yes there's no Constructor args no contract Library addresses no missed settings I'm not a robot and we hit verify and public sometimes this can be a little bit tricky to get right and we're going to work with programmatic verification pretty soon that makes it a lot easier but if we did it correct correctly what will happen then is if we click on our contract address here and we go to contract and we scroll down we can actually see our contract right in etherscan this will also give access to these read and write contract buttons which we can see it now looks really similar to what's on remix and we can actually interact with our contract right from etherscan or another block Explorer like I said that's the manual way to verify your contracts and you can run into a lot of issues doing that so I don't recommend doing it I recommend doing the programmatic way which I'm going to teach you very soon all right so now we're just about done with our very basic project here which is fantastic we've learned a ton already but there's a couple things we want to keep in mind here moving forward and one of those things is when it comes to formatting so we are using the vs code Auto formatter to auto formatter code but if somebody else comes and I'm going to actually save that formatting if somebody else comes to our code base we're going to want to have them format it the exact same way that we format it so all we can do is we can use the forge format command which if we run it you see favorite number actually went ahead and formatted so I'm going to save that formatting again run Forge format and it's going to Auto format our code here so this is a command that will automatically format all of our solidity code awesome and additionally for every single repo you ever work with you always want to make a readme.md file so right click new file readme.md I actually already made one over here and this is where you're going to put information about your project here I put some notes about the private key usage which I'm just going to delete for now readme files are generally where you put information about your project instructions to work with it places to contact you really any information that another open source developer should know when they want to interact with your project because we are going to push this up to GitHub as well we're not going to push this up to our GitHub because it's kind of easy but in the next project we're actually going to push the code up to GitHub and I'm going to teach you how to do that readme.mds are this markdown syntax remember how we were talking about ants answering questions or asking questions using markdown syntax well this is going to be the exact same if I do a hashtag or pound sign like this and I say hello and then some text down here and if I hit save what I can do is I can actually preview this markdown so in my extensions over here we're going to look for a markdown extension I actually already have one marked down all in one or markdown preview or whatever you want to install and we can do open up our Command palette with command shift p or view command palette we can do markdown preview open preview like this and we can see what this looks like as if it was on a GitHub repo we can see Hello is Big we can see our hex down here is small and if I were to do like some back ticks like this I could say like code here save that look at our preview again we can see this is formatted now as code you can also do command shift V to automatically go to preview mode or it might be Ctrl shift V for windows and Linux users there's a lot of different ways to go preview your markdown and remember if formatting your your readme is difficult usually AIS do a pretty good job at formatting your markdown for you if you just ask them politely now Alchemy has a couple of other really cool features about it especially when it comes to learning more about what's actually happening with our transactions whenever we send a transaction to a blockchain node it actually enters something called the mempool it's basically the place where transactions go before they get actually sent and the Alchemy dashboard is a great place to actually view those transactions and see their status so I'm going to go ahead and turn it over to veto from the Alchemy team who's going to explain more about what Alchemy has to offer some of the other cool parts of alchemy and more everyone and welcome this brand new video and video and today I'm gonna walk you've this is not my channel this is not even asking this channel oh my God this is the latest Patrick Collins video about boundary that everyone must watch uh well welcome everyone I'm Vito and thank you Patrick for hosting this Cameo I guess my job today is to tell you a bit more about what Alchemy is what we do how we do it and how you can get the most out of it well before getting started let me quickly quickly introduce myself I am Vito lead developer experience at Alchemy blockchain developer and web free content creator on a mission to onboard 1 million developers onto web free of course today we're not here to talk about me but we're here to talk about how Alchemy can appear decentralized applications scale to billions of users so to get started what is alchemy well Alchemy is a node provider and web free developer tooling platform borrowing hundreds of thousands of what three and webqo applications out there things like open C Nifty Gateway but also Xerox Argent Dapper but as well as big massive web 2 companies such as Adobe Shopify and stripe the question here probably is why do these companies use us why Alchemy well that's the question we tried once we're here briefly the thing is when you need to develop an application chances are you won't run the servers your code your code will run on and most likely you won't even develop the deployment and integration pipelines for it to do this you will do the services such as AWS Azure Google Cloud well Alchemy does exactly this but for web free you can see it as the AWS or web free with apis sdks libraries that will simply make your developer experience better but how do we do that well we do it in mainly three ways the first one is the super node a blockchain proprietary engine that hacks as a load balancer on top of your node and make sure you always got the latest available data from the blockchain on top of the super node we built the announced apis the announced apis are a set of apis that will allow you to pull data from the blockchain with ease here you can see how we envision this with the Alchemy super node at the center as the core infrastructure powering its ecosystem all around such as our announced apis but also our monitoring tools and of course supporting all the chains that we support to date I will get back to it in a few seconds but the question is of course how do you get started well the first thing that we're gonna do is navigating on alchemy.com and we're going to create a new account creating an account on alchemy.com is completely free and actually cool thing is that you'll be able to scale your application using our Premium plan because it's quite generous so don't be concerned about paying anything everything you'll see today and probably in Patrick's course is completely free to use let's go back creating a new account in this case I would just sign in of course I already have an account so click on sign in and as soon as we'll open this window you will see all of your applications of course if this is the first time you logging in on Alchemy you will only see the demo application but no worries we're gonna learn how to create a new application right now super important click on create app and let's give it a name so we're gonna call it Patrick is cool and I'm going to use underscores just because of personal preference feel free to use spaces or name your application the way you want we're going to also give a description this is optional you don't have to but I really think that Patrick is cool and then we're going to select a chain as we said before we support the majority of EDM compatible chains as you can see here we support ethereum polygon POS also GK VM as well as optimism and a star and on top of that we support Solana and non-evm chain here you can select your chain and here you can select your network in this case we will go for a hero mainnet but feel free to try out all the other networks and test Nets of course we have one for all of these mainnet that we support so we've created the new app and once the app is being created I can just go and search for my name so Patrick is cool and click on my application here we go once the application has opened you will be able to see the application specific dashboard and this is a big change big game changer for all decentralized application developers because this gives you full visibility over your application and infrastructure Health you'll be able to see things such as latency compute units that that is how many RPC calls are eating your notes as well as the success rate of your calls the throughput and so on and so forth super useful when you need to debug so let's say that here you see 98 of success rate you'll be able to understand why your transactions are not going through well let's actually do an example let me go back and find an application that has actual calls so here we go I just navigated to this demo key application that as you can see has a ton of calls but also as you can see it has a success rate of 98.5 that means that 1.5 percent of our holes are failing to go through but how do you understand that how do you debug this well if you're not using Alchemy chances are that to debug your RPC calls you will have to spin up your own nodes or B run a local node and in that case you'll be able to see the logs coming from the node otherwise there is no possibility to see the logs coming from the node this is not something you will see on etherscan using Alchemy you'll be able to see all the issues related to your calls as well as the known issues related to your course in this dashboard so let's say that we have 1.5 percent of course not going through what we can do is go on the recent invalid request Tab and here all the requests that didn't go through will be listed as well as the reason why they didn't go through for example here we have an Ethan row transaction that didn't go through because they weren't sufficient gas funds well let's take another one here execution reverted for example means the probably there is a problem with the smart contract so as you can see the bugging as well as you can see other information on the left hand side but I will go back at this in a few seconds because I want to show you another tool that is even more precise to see the information about the actual requests here you'll be able to debug your RPC calls with super Ease on top of that as I was saying we have other tools to help you debug and get more visibility on your application so if you click on the menu and here what we can do is navigate on the mempool and the man pool is actually just like the mempool that you might think about when you're thinking about ethereum so it's a place where all of your transactions are and you can see the status of the transaction the information about the transaction what if the transaction is going through it didn't go through if it's spending for hours if you got mined how much it costs and so on and so forth so let's say we we just navigated on our mempool Watcher and here we have all the transactions going through on our applications here I have a bunch of applications so that's why I'm seeing a lot of transactions here on the top you can see all the mine transactions so the transactions that already went through that can be mined or validated the pending transactions um let me just select one application because of course otherwise it's gonna take a long time here you have all the pending transactions the mean all the transactions that are waiting to be mined or validated and here you have dropped and dropped and replaced so transactions that have been dropped canceled or replaced by other transactions with the same nouns the same call data and the same gas fees or dropped means there are transactions that have been canceled and won't be validated or mined but on top of that you can get even more information on these calls on these transactions if I click here on the ash this one bring me on ether's gun well will bring me on the mempool transaction summary page and here I can see all the information about the transaction I can see how much gas it costed uh which network it was on of course uh the transaction hash as well as the from address so who signed the transaction and who's sending the transaction to as well as the value inside transaction the time it took to get sent and the time it took to get validated this is more clear on validated transactions where everything has already been filled out so I can go back in my mind page so here we go I can select one and as you can see here I have all the information so I have Max fee for gas I have the transaction type so this was using the EAP 1559 and a bunch of other information about the transaction itself super helpful to debug and get full visibility over it all right another video quickly gone through our Alchemy Works what it is and how its features can help your developer experience become way better and develop faster I don't want to steal much more of your time while learning during this amazing course so what I'm gonna do is leave you with a couple of resources that will make your developer experience with Alchemy even better the first one is our documentation so our documentation has everything you need to get started using our apis SDK libraries and also tools that we didn't have the time to go through today such as our generalized custom graphqlware books that allow you to pull data real time from the blockchain through graphql queries on top of that you will also add tutorial and guides to build your applications and complement the knowledge you're creating during this course of course follow us on Twitter at Alchemy platform or Alchemy learn and if you want to shoot me a message telling me the amazing things that you're building while learning from the Patrick's course please shoot it at veto stock on Twitter thank you so much Patrick once again for hosting us and thank everyone for speaking with us for 12 minutes it's been a pleasure see you around and happy building but for this one you should be incredibly proud of yourself you just did an entire project in Foundry huge congratulations so let's do a quick recap of everything we learned and then we'll move to the next project and yes we are going to push our next project up to GitHub into a lot more advanced Foundry and a lot more advanced tooling here so let's do a quick recap of what we learned so far well first we learned how to create new Foundry projects with Forge Dash Dash and knit which will give us all these folders on the left hand side here to actually start working with our projects in a more professional environment we learned about some of the basic Foundry commands such as cast Anvil and Forge Forge is used for compiling and interacting with our contracts cast is used for interacting with contracts that have already been deployed and Anvil is used to deploy a local blockchain similar to ganache which is another local blockchain that we worked with we learned that whenever we send a transaction on our metamask we're actually making an HTTP post request to this RPC URL and we can also take an RPC URL from a notice a service like Alchemy and use it to actually send transactions from our Foundry projects we learned both how to actually compile our code in Foundry and then also write a script to deploy it directly in solidity we've learned some very basic information about keeping our private Keys safe for the rest of the course we're going to be working with a EMV file but when we work with real money we might not want to actually have our private key in plain text ever so we learned how to deploy our contracts to a blockchain programmatically and then we learned how to interact with them using the cast keyword and send to send transactions and then cast call to read from those contracts we've learned how to auto format our contracts with Forge format and we learned the manual way to actually verify one of our contracts on the blockchain we learned a lot here so be absolutely sure to take a minute to go on a walk go get a cup of coffee go grab some ice cream don't post on Twitter that you've taken an extra step in your web3 developer Journey you should be incredibly proud of yourself for getting this far, like I said earlier installing some of these tools like VS code and Foundry can be one of the hardest parts of this entire course so if you're in here if you're working with me you're doing fantastic we've got a lot more to go but just by getting this far you've done incredibly well so with that being said take that break remember breaks are good for your brain take that break and we'll see you in the next one